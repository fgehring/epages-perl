.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Record 3"
.TH Data::Record 3 "2017-06-14" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Record \- "split" on steroids
.SH "VERSION"
.IX Header "VERSION"
Version 0.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  use Regexp::Common;
\&  use Data::Record;
\&  my $record = Data::Record\->new({
\&    split  => "\en",
\&    unless => $RE{quoted},
\&  });
\&  my @data = $record\->records($data);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Sometimes we need data split into records and a simple split on the input
record separator (\f(CW$/\fR) or some other value fails because the values we're
splitting on may allowed in other parts of the data.  Perhaps they're quoted.
Perhaps they're embedded in other data which should not be split up.
.PP
This module allows you to specify what you wish to split the data on, but also
speficy an \*(L"unless\*(R" regular expression.  If the text in question matches the
\&\*(L"unless\*(R" regex, it will not be split there.  This allows us to do things like
split on newlines unless newlines are embedded in quotes.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Common usage:
.PP
.Vb 4
\& my $record = Data::Record\->new({
\&    split  => qr/$split/,
\&    unless => qr/$unless/,
\& });
.Ve
.PP
Advanced usage:
.PP
.Vb 12
\& my $record = Data::Record\->new({
\&    split  => qr/$split/,
\&    unless => qr/$unless/,  # optional
\&    token  => $token,       # optional
\&    chomp  => 0,            # optional
\&    limit  => $limit,       # optional (do not use with trim)
\&    trim   => 1,            # optional (do not use with limit)
\&    fields => {
\&        split  => \*(Aq,\*(Aq,
\&        unless => $RE{quoted}, # from Regexp::Common
\&    }
\& });
.Ve
.PP
The constructor takes a hashref of key/value pairs to set the behavior of data
records to be created.
.IP "\(bu" 4
split
.Sp
This is the value to split the data on.  It may be either a regular expression
or a string.
.Sp
Defaults to the current input record separator (\f(CW$/\fR).
.IP "\(bu" 4
unless
.Sp
Data will be split into records matching the split value \fIunless\fR they also
match this value.  No default.
.Sp
If you do not have an \f(CW\*(C`unless\*(C'\fR value, use of this module is overkill.
.IP "\(bu" 4
token
.Sp
You will probably never need to set this value.
.Sp
Internally, this module attempts to find a token which does not match any text
found in the data to be split and also does not match the split value.  This is
necessary because we mask the data we don't want to split using this token.
This allows us to split the resulting text.
.Sp
In the unlikely event that the module cannot find a token which is not in the
text, you may set the token value yourself to some string value.  Do not set it
to a regular expression.
.IP "\(bu" 4
chomp
.Sp
By default, the split value is discarded (chomped) from each record.  Set this
to a true value to keep the split value on each record.  This differs slightly
from how it's done with split and capturing parentheses:
.Sp
.Vb 1
\&  split /(\e,)/, \*(Aq3,4,5\*(Aq;
.Ve
.Sp
Ordinarily, this results in the following list:
.Sp
.Vb 1
\& ( 3, \*(Aq,\*(Aq, 4, \*(Aq,\*(Aq, 5 )
.Ve
.Sp
This module assumes you want those values \fIwith\fR the preceding record.  By
setting chomp to false, you get the following list:
.Sp
.Vb 1
\& ( \*(Aq3,\*(Aq, \*(Aq4,\*(Aq 5 )
.Ve
.IP "\(bu" 4
limit
.Sp
The default split behavior is similar to this:
.Sp
.Vb 1
\& split $split_regex, $data;
.Ve
.Sp
Setting \f(CW\*(C`limit\*(C'\fR will cause the behavior to act like this:
.Sp
.Vb 1
\& split $split_regex, $data, $limit
.Ve
.Sp
See \f(CW\*(C`perldoc \-f split\*(C'\fR for more information about the behavior of \f(CW\*(C`limit\*(C'\fR.
.Sp
You may not set both \f(CW\*(C`limit\*(C'\fR and \f(CW\*(C`trim\*(C'\fR in the constructor.
.IP "\(bu" 4
trim
.Sp
By default, we return all records.  This means that due to the nature of split
and how we're doing things, we sometimes get a trailing null record.  However,
setting this value causes the module to behave as if we had done this:
.Sp
.Vb 1
\& split $split_regex, $data, 0;
.Ve
.Sp
When \f(CW\*(C`split\*(C'\fR is called with a zero as the third argument, trailing null values
are discarded.  See \f(CW\*(C`perldoc \-f split\*(C'\fR for more information.
.Sp
You may not set both \f(CW\*(C`limit\*(C'\fR and \f(CW\*(C`trim\*(C'\fR in the constructor.
.Sp
\&\fBNote\fR:  This does \fInot\fR trim white space around returned records.
.IP "\(bu" 4
fields
.Sp
By default, individual records are returned as strings.  If you set \f(CW\*(C`fields\*(C'\fR,
you pass in a hashref of arguments that are identical to what \f(CW\*(C`new\*(C'\fR would take
and resulting records are returned as array references processed by a new
\&\f(CW\*(C`Data::Record\*(C'\fR instance.
.Sp
Example:  a quick \s-1CSV\s0 parser which assumes that commas and newlines may both be
in quotes:
.Sp
.Vb 7
\& # four lines, but there are only three records! (newline in quotes)
\& $data = <<\*(AqEND_DATA\*(Aq;
\& 1,2,"programmer, perl",4,5
\& 1,2,"programmer,
\& perl",4,5
\& 1,2,3,4,5
\& END_DATA
\&  
\& $record = $RECORD\->new({
\&     split  => "\en",
\&     unless => $quoted,
\&     trim   => 1,
\&     fields => {
\&         split  => ",",
\&         unless => $quoted,
\&     }
\& });
\& my @records = $record\->records($data);
\& foreach my $fields (@records) {
\&   foreach my $field = (@$fields);
\&     # do something
\&   }
\& }
.Ve
.Sp
Note that above example will not remove the quotes from individual fields.
.SS "split"
.IX Subsection "split"
.Vb 2
\&  my $split = $record\->split;
\&  $record\->split($on_value);
.Ve
.PP
Getter/setter for split value.  May be a regular expression or a scalar value.
.SS "unless"
.IX Subsection "unless"
.Vb 2
\& my $unless = $self\->unless;
\& $self\->unless($is_value);
.Ve
.PP
Getter/setter for unless value.  May be a regular expression or a scalar value.
.SS "chomp"
.IX Subsection "chomp"
.Vb 2
\&  my $chomp = $record\->chomp;
\&  $record\->chomp(0);
.Ve
.PP
Getter/setter for boolean chomp value.
.SS "limit"
.IX Subsection "limit"
.Vb 2
\&  my $limit = $record\->limit;
\&  $record\->limit(3);
.Ve
.PP
Getter/setter for integer limit value.
.SS "trim"
.IX Subsection "trim"
.Vb 2
\&  my $trim = $record\->trim;
\&  $record\->trim(1);
.Ve
.PP
Getter/setter for boolean limit value.  Setting this value will cause any
previous \f(CW\*(C`limit\*(C'\fR value to be overwritten.
.SS "token"
.IX Subsection "token"
.Vb 2
\&  my $token = $record\->token;
\&  $record\->token($string_not_found_in_text);
.Ve
.PP
Getter/setter for token value.  Token must be a string that does not match the
split value and is not found in the text.
.PP
You can return the current token value if you have set it in your code.  If you
rely on this module to create a token (this is the normal behavior), it is not
available via this method until \f(CW\*(C`records\*(C'\fR is called.
.PP
Setting the token to an undefined value causes Data::Record to try and find
a token itself.
.PP
If the token matches the split value, this method will croak when you attempt
to set the token.
.PP
If the token is found in the data, the \f(CW\*(C`records\*(C'\fR method will croak when it is
called.
.SS "records"
.IX Subsection "records"
.Vb 1
\&  my @records = $record\->records($data);
.Ve
.PP
Returns \f(CW@records\fR for \f(CW$data\fR based upon current split criteria.
.SH "BUGS"
.IX Header "BUGS"
It's possible to get erroneous results if the split value is \f(CW\*(C`/\ed+/\*(C'\fR.  I've
tried to work around this.  Please let me know if there is a problem.
.SH "CAVEATS"
.IX Header "CAVEATS"
This module must read \fIall\fR of the data at once.  This can make it slow for
larger data sets.
.SH "AUTHOR"
.IX Header "AUTHOR"
Curtis \*(L"Ovid\*(R" Poe, \f(CW\*(C`<ovid [at] cpan [dot] org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-data\-record@rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data\-Record <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Data-Record>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to the Monks for inspiration from
<http://perlmonks.org/index.pl?node_id=492002>.
.PP
0.02 Thanks to Smylers and Stefano Rodighiero for catching \s-1POD\s0 errors.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2005 Curtis \*(L"Ovid\*(R" Poe, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
