.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Mockify::Sut 3"
.TH Test::Mockify::Sut 3 "2018-03-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Mockify::Sut \- injection options for your System under test (Sut) based on Mockify
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Test::Mockify::Sut;
\&  use Test::Mockify::Verify qw ( WasCalled );
\&  use Test::Mockify::Matcher qw ( String );
\&
\&  # build a new system under text
\&  my $MockifySut = Test::Mockify::Sut\->new(\*(AqPackage::I::Like::To::Test\*(Aq, []);
\&  $MockifySut\->mockImported(\*(AqPackage::Name\*(Aq, \*(AqImportedFunctionName\*(Aq)\->when(String())\->thenReturn(\*(AqHello\*(Aq);
\&  $MockifySut\->mockStatic(\*(AqFully::Qualified::FunctionName\*(Aq)\->when(String())\->thenReturn(\*(AqHello\*(Aq);
\&  $MockifySut\->overrideConstructor(\*(AqPackage::Name\*(Aq, $Object);#  hint: build this object also with Mockify
\&  my $PackageILikeToTest = $MockifySut\->getMockObject();
\&
\&  $PackageILikeToTest\->do_something();# all injections are used here
\&
\&  # verify that the mocked method were called
\&  ok(WasCalled($PackageILikeToTest, \*(AqImportedFunctionName\*(Aq), \*(AqImportedFunctionName was called\*(Aq);
\&  done_testing();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Use Test::Mockify::Sut to create and configure Sut objects. Use Test::Mockify::Verify to
verify the interactions with your mocks.
.PP
You can find a Example Project in ExampleProject <https://github.com/ChristianBreitkreutz/Mockify/tree/master/t/ExampleProject>
.SH "METHODS"
.IX Header "METHODS"
.SS "mock"
.IX Subsection "mock"
To mock methods or functions of your Sut is a really bad idea. Therefore this method throws a Error when used.
.SS "mockImported"
.IX Subsection "mockImported"
Sometimes it is not possible to inject the dependencies from the outside. This is especially the case when the package uses imports of static functions.
\&\f(CW\*(C`mockImported\*(C'\fR provides the possibility to mock imported functions inside the mock.
.PP
Unlike \f(CW\*(C`mockStatic\*(C'\fR is the injection with \f(CW\*(C`mockImported\*(C'\fR only in the mock valid.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
.Vb 11
\&  package Show::Magician;
\&  use Magic::Tools qw ( Rabbit );
\&  sub pullCylinder {
\&      shift;
\&      if(Rabbit(\*(Aqwhite\*(Aq)){
\&          return 1;
\&      }else{
\&          return 0;
\&      }
\&  }
\&  1;
.Ve
.PP
In the Test it can be mocked
.PP
.Vb 4
\&  package Test_Magician;
\&  use Magic::Tools qw ( Rabbit );
\&  my $Mockify = Test::Mockify::Sut\->new( \*(AqShow::Magician\*(Aq, [] );
\&  $Mockify\->mockImported(\*(AqMagic::Tools\*(Aq,\*(AqRabbit\*(Aq)\->when(String(\*(Aqwhite\*(Aq))\->thenReturn(1);
\&
\&  my $Magician = $Mockify\->getMockObject();
\&  is($Magician \->pullCylinder(), 1);
\&  Rabbit(\*(Aqwhite\*(Aq);# return original result
\&  1;
.Ve
.PP
It can be mixed with normal \f(CW\*(C`spy\*(C'\fR and \f(CW\*(C`mock\*(C'\fR
.SS "spyImported"
.IX Subsection "spyImported"
\&\f(CW\*(C`spyImported\*(C'\fR provides the possibility to spy imported functions inside the mock.
.PP
Unlike \f(CW\*(C`spyStatic\*(C'\fR is the injection with \f(CW\*(C`spyImported\*(C'\fR only in the mock valid.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
.Vb 11
\&  package Show::Magician;
\&  use Magic::Tools qw ( Rabbit );
\&  sub pullCylinder {
\&      shift;
\&      if(Rabbit(\*(Aqwhite\*(Aq)){
\&          return 1;
\&      }else{
\&          return 0;
\&      }
\&  }
\&  1;
.Ve
.PP
In the Test it can be mocked
.PP
.Vb 4
\&  package Test_Magician;
\&  use Magic::Tools qw ( Rabbit );
\&  my $Mockify = Test::Mockify::Sut\->new( \*(AqShow::Magician\*(Aq, [] );
\&  $Mockify\->spyImported(\*(AqMagic::Tools\*(Aq,\*(AqRabbit\*(Aq)\->when(String());
\&
\&  my $Magician = $Mockify\->getMockObject();
\&  is($Magician\->pullCylinder(), \*(AqSomeValue\*(Aq);
\&  is(GetCallCount($Magician, \*(AqRabbit\*(Aq), 1);
\&  1;
.Ve
.PP
It can be mixed with normal \f(CW\*(C`spy\*(C'\fR and \f(CW\*(C`mock\*(C'\fR
.SS "mockStatic"
.IX Subsection "mockStatic"
Sometimes it is not possible to inject the dependencies from the outside.
\&\f(CW\*(C`mockStatic\*(C'\fR provides the possibility to mock static functions inside the mock.
.PP
Attention: The mocked function is valid as long as the \f(CW$Mockify\fR is defined. If You leave the scope or set the \f(CW$Mockify\fR to undef the injected method will be released.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
.Vb 11
\&  package Show::Magician;
\&  use Magic::Tools;
\&  sub pullCylinder {
\&      shift;
\&      if(Magic::Tools::Rabbit(\*(Aqblack\*(Aq)){
\&          return 1;
\&      }else{
\&          return 0;
\&      }
\&  }
\&  1;
.Ve
.PP
In the Test it can be mocked like:
.PP
.Vb 6
\&  package Test_Magician;
\&  { # start scope
\&      my $Mockify = Test::Mockify::Sut\->new( \*(AqShow::Magician\*(Aq, [] );
\&      $Mockify\->mockStatic(\*(AqMagic::Tools::Rabbit\*(Aq)\->when(String(\*(Aqblack\*(Aq))\->thenReturn(1);
\&      $Mockify\->spy(\*(Aqlog\*(Aq)\->when(String());
\&      my $Magician = $Mockify\->getMockObject();
\&
\&      is($Magician\->pullCylinder(\*(Aqblack\*(Aq), 1);
\&      is(Magic::Tools::Rabbit(\*(Aqblack\*(Aq), 1); 
\&  } # end scope
\&  is(Magic::Tools::Rabbit(\*(Aqblack\*(Aq), \*(AqsomeValue\*(Aq); # The orignal method in in place again
.Ve
.PP
It can be mixed with normal \f(CW\*(C`spy\*(C'\fR and \f(CW\*(C`mock\*(C'\fR
.PP
\s-1ACKNOWLEDGEMENTS\s0 Thanks to \f(CW@dbucky\fR for this amazing idea
.IX Subsection "ACKNOWLEDGEMENTS Thanks to @dbucky for this amazing idea"
.SS "spyStatic"
.IX Subsection "spyStatic"
Provides the possibility to spy static functions around the mock.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
.Vb 10
\&  package Show::Magician;
\&  sub pullCylinder {
\&      shift;
\&      if(Magic::Tools::Rabbit(\*(Aqblack\*(Aq)){
\&          return 1;
\&      }else{
\&          return 0;
\&      }
\&  }
\&  1;
.Ve
.PP
In the Test it can be mocked
.PP
.Vb 5
\&  package Test_Magician;
\&  use Magic::Tools;
\&  my $Mockify = Test::Mockify::Sut\->new( \*(AqShow::Magician\*(Aq, [] );
\&  $Mockify\->spyStatic(\*(AqMagic::Tools::Rabbit\*(Aq)\->whenAny();
\&  my $Magician = $Mockify\->getMockObject();
\&
\&  $Magician\->pullCylinder();
\&  Magic::Tools::Rabbit(\*(Aqblack\*(Aq);
\&  is(GetCallCount($Magician, \*(AqMagic::Tools::Rabbit\*(Aq), 2); # count as long as $Mockify is valid
\&
\&  1;
.Ve
.PP
It can be mixed with normal \f(CW\*(C`spy\*(C'\fR and \f(CW\*(C`mock\*(C'\fR. For more options see, \f(CW\*(C`mockStatic\*(C'\fR
.SS "mockConstructor"
.IX Subsection "mockConstructor"
Sometimes it is not possible to inject the dependencies from the outside. This method gives you the posibility to override the constructor of a package where your Sut depends on.
The defaut constructor is \f(CW\*(C`new\*(C'\fR if you need another constructor name, use the third parameter.
.PP
Attention: The mocked constructor is valid as long as the Mockify object is defined. If You leave the scope or set the Mockify object to undef the injected constructor will be released.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
.Vb 7
\&  package Path::To::SUT;
\&  use Path::To::Package;
\&  sub callToAction {
\&      shift;
\&      return Path::To::Package\->new()\->doAction();
\&  }
\&  1;
.Ve
.PP
In the Test it can be mocked like:
.PP
.Vb 5
\&  package Test_SUT;
\&  { # start scope
\&      my $MockifySut = Test::Mockify::Sut\->new( \*(AqPath::To::SUT\*(Aq, [] );
\&      $MockifySut\->mockConstructor(\*(AqPath::To::Package\*(Aq, $self\->_createPathToPackage()); 
\&      my $Test_SUT = $MockifySut\->getMockObject();
\&
\&      is($Test_SUT\->callToAction(), \*(Aqhello\*(Aq);
\&  } # end scope
\&
\&  sub _createPathToPackage{
\&      my $self = shift;
\&      my $Mockify = Test::Mockify::Sut\->new( \*(AqPath::To::Package\*(Aq, [] );
\&      $Mockify\->mock(\*(AqdoAction\*(Aq)\->when()\->thenReturn(\*(Aqhello\*(Aq);
\&      return $Mockify\->getMockObject();
\&  }
.Ve
.PP
It can be mixed with normal \f(CW\*(C`spy\*(C'\fR and \f(CW\*(C`mock\*(C'\fR
.SS "getVerificationObject"
.IX Subsection "getVerificationObject"
Provides the actual mock object, which you can use for verification.
This is code sugar for the method \f(CW\*(C`getMockObject\*(C'\fR.
.PP
.Vb 3
\&  my $Mockify = Test::Mockify::Sut\->new( \*(AqMy::Module\*(Aq, [] );
\&  my $VerificationObject = $Mockify\->getVerificationObject();
\&  ok(WasCalled($VerificationObject, \*(AqFunctionName\*(Aq));
.Ve
