.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RTF::Parser 3"
.TH RTF::Parser 3 "2004-03-30" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RTF::Parser \- An event\-driven RTF Parser
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An event-driven \s-1RTF\s0 Parser
.SH "PUBLIC SERVICE ANNOUNCEMENT"
.IX Header "PUBLIC SERVICE ANNOUNCEMENT"
This is the third and final (I hope) beta release of RTF::Parser before I
release a 'production' version (hopefully around Feb 1st 04). I took over
RTF::Parser from Phillipe Verdret, in a state where it had no documentation.
I've been working since then on refactoring parts of it, writing tests and
documentation, but this is still a work in progress. Please bear with me,
ignore the gaping ommission of tests and documentation for RTF::Control,
and send me bug reports and suggestions.
.SH "IMPORTANT HINTS"
.IX Header "IMPORTANT HINTS"
\&\s-1RTF\s0 parsing is non-trivial. The inner workings of these modules are somewhat
scary. You should go and read the 'Introduction' document included with this
distribution before going any further \- it explains how this distribution fits
together, and is \fBvital\fR reading.
.PP
If you just want to convert \s-1RTF\s0 to \s-1HTML\s0 or text, from inside your own script,
jump straight to the docs for RTF::HTML::Converter or RTF::TEXT::Converter
respectively.
.SH "SUBCLASSING RTF::PARSER"
.IX Header "SUBCLASSING RTF::PARSER"
When you subclass RTF::Parser, you'll want to do two things. You'll firstly
want to overwrite the methods below described as the \s-1API\s0. This describes what
we do when we have tokens that aren't control words (except 'symbols' \- see below).
.PP
Then you'll want to create a hash that maps control words to code references
that you want executed. They'll get passed a copy of the RTF::Parser object,
the name of the control word (say, 'b'), any arguments passed with the control
word, and then 'start'.
.SS "An example..."
.IX Subsection "An example..."
The following code removes bold tags from \s-1RTF\s0 documents, and then spits back
out \s-1RTF\s0.
.PP
.Vb 1
\&  {
\&  
\&    # Create our subclass
\&      
\&      package UnboldRTF;
\&
\&    # We\*(Aqll be doing lots of printing without newlines, so don\*(Aqt buffer output
\&
\&      $|++;
\&
\&    # Subclassing magic...
\&    
\&      use RTF::Parser;
\&      @UnboldRTF::ISA = ( \*(AqRTF::Parser\*(Aq );
\&                        
\&    # Redefine the API nicely
\&        
\&      sub parse_start { print STDERR "Starting...\en"; }
\&      sub group_start { print \*(Aq{\*(Aq }
\&      sub group_end   { print \*(Aq}\*(Aq }
\&      sub text        { print "\en" . $_[1] }
\&      sub char        { print "\e\e\e\*(Aq$_[1]" }
\&      sub symbol      { print "\e\e$_[1]" }
\&      sub parse_end   { print STDERR "All done...\en"; }
\&
\&  }
\&
\&  my %do_on_control = (
\&
\&        # What to do when we see any control we don\*(Aqt have
\&        #   a specific action for... In this case, we print it.
\&
\&    \*(Aq_\|_DEFAULT_\|_\*(Aq => sub {
\&
\&      my ( $self, $type, $arg ) = @_;
\&      $arg = "\en" unless defined $arg;
\&      print "\e\e$type$arg";
\&
\&     },
\&     
\&   # When we come across a bold tag, we just ignore it.
\&     
\&     \*(Aqb\*(Aq => sub {},
\&
\&  );
\&
\&  # Grab STDIN...
\&
\&    my $data = join \*(Aq\*(Aq, (<>);
\&
\&  # Create an instance of the class we created above
\&
\&    my $parser = UnboldRTF\->new();
\&
\&  # Prime the object with our control handlers...
\& 
\&    $parser\->control_definition( \e%do_on_control );
\&  
\&  # Don\*(Aqt skip undefined destinations...
\&  
\&    $parser\->dont_skip_destinations(1);
\&
\&  # Start the parsing!
\&
\&    $parser\->parse_string( $data );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Creates a new RTF::Parser object. Doesn't accept any arguments.
.SS "parse_stream( \e*FH )"
.IX Subsection "parse_stream( *FH )"
This function used to accept a second parameter \- a function specifying how
the filehandle should be read. This is deprecated, because I could find no
examples of people using it, nor could I see why people might want to use it.
.PP
Pass this function a reference to a filehandle (or, now, a filename! yay) to
begin reading and processing.
.ie n .SS "parse_string( $string )"
.el .SS "parse_string( \f(CW$string\fP )"
.IX Subsection "parse_string( $string )"
Pass this function a string to begin reading and processing.
.SS "control_definition"
.IX Subsection "control_definition"
The code that's executed when we trigger a control event is kept
in a hash. We're holding this somewhere in our object. Earlier 
versions would make the assumption we're being subclassed by
RTF::Control, which isn't something I want to assume. If you are
using RTF::Control, you don't need to worry about this, because
we're grabbing \f(CW%RTF::Control::do_on_control\fR, and using that.
.PP
Otherwise, you pass this method a reference to a hash where the keys
are control words, and the values are coderefs that you want executed.
This sets all the callbacks... The arguments passed to your coderefs
are: \f(CW$self\fR, control word itself (like, say, 'par'), any parameter the
control word had, and then 'start'.
.PP
If you don't pass it a reference, you get back the reference of the
current control hash we're holding.
.SS "rtf_control_emulation"
.IX Subsection "rtf_control_emulation"
If you pass it a boolean argument, it'll set whether or not it thinks RTF::Control
has been loaded. If you don't pass it an argument, it'll return what it thinks...
.SS "dont_skip_destinations"
.IX Subsection "dont_skip_destinations"
The \s-1RTF\s0 spec says that we skip any destinations that we don't have an explicit
handler for. You could well not want this. Accepts a boolean argument, true
to process destinations, 0 to skip the ones we don't understand.
.SH "API"
.IX Header "API"
These are some methods that you're going to want to over-ride if you
subclass this modules. In general though, people seem to want to subclass
RTF::Control, which subclasses this module.
.SS "parse_start"
.IX Subsection "parse_start"
Called before we start parsing...
.SS "parse_end"
.IX Subsection "parse_end"
Called when we're finished parsing
.SS "group_start"
.IX Subsection "group_start"
Called when we encounter an opening {
.SS "group_end"
.IX Subsection "group_end"
Called when we encounter a closing }
.SS "text"
.IX Subsection "text"
Called when we encounter plain-text. Is given the text as its
first argument
.SS "char"
.IX Subsection "char"
Called when we encounter a hex-escaped character. The hex characters
are passed as the first argument.
.SS "symbol"
.IX Subsection "symbol"
Called when we come across a control character. This is interesting, because,
I'd have treated these as control words, so, I'm using Philippe's list as control
words that'll trigger this for you. These are \f(CW\*(C`\-_~:|{}*\*(Aq\e\*(C'\fR. This needs to be
tested.
.SS "bitmap"
.IX Subsection "bitmap"
Called when we come across a command that's talking about a linked bitmap
file. You're given the file name.
.SS "binary"
.IX Subsection "binary"
Called when we have binary data. You get passed it.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Sergeant \f(CW\*(C`rtf.parser@clueball.com\*(C'\fR, originally by Philippe Verdret
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004 \fBPete Sergeant\fR.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.SH "CREDITS"
.IX Header "CREDITS"
This work was carried out under a grant generously provided by The Perl Foundation \-
give them money!
