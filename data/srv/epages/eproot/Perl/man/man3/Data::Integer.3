.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Integer 3"
.TH Data::Integer 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Integer \- details of the native integer data type
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Data::Integer qw(natint_bits);
\&
\&        $n = natint_bits;
\&
\&        # and other constants; see text
\&
\&        use Data::Integer qw(nint sint uint nint_is_sint nint_is_uint);
\&
\&        $ni = nint($ni);
\&        $si = sint($si);
\&        $ui = uint($ui);
\&        if(nint_is_sint($ni)) { ...
\&        if(nint_is_uint($ni)) { ...
\&
\&        use Data::Integer qw(
\&                nint_sgn sint_sgn uint_sgn
\&                nint_abs sint_abs uint_abs
\&                nint_cmp sint_cmp uint_cmp
\&                nint_min sint_min uint_min
\&                nint_max sint_max uint_max
\&                nint_neg sint_neg uint_neg
\&                nint_add sint_add uint_add
\&                nint_sub sint_sub uint_sub
\&        );
\&
\&        $sn = nint_sgn($ni);
\&        $sn = sint_sgn($si);
\&        $sn = uint_sgn($ui);
\&        $ni = nint_abs($ni);
\&        $si = sint_abs($si);
\&        $ui = uint_abs($ui);
\&        @sorted_nints = sort { nint_cmp($a, $b) } @nints;
\&        @sorted_sints = sort { sint_cmp($a, $b) } @sints;
\&        @sorted_uints = sort { uint_cmp($a, $b) } @uints;
\&        $ni = nint_min($na, $nb);
\&        $si = sint_min($sa, $sb);
\&        $ui = uint_min($ua, $ub);
\&        $ni = nint_max($na, $nb);
\&        $si = sint_max($sa, $sb);
\&        $ui = uint_max($ua, $ub);
\&        $ni = nint_neg($ni);
\&        $si = sint_neg($si);
\&        $ui = uint_neg($ui);
\&        $ni = nint_add($na, $nb);
\&        $si = sint_add($sa, $sb);
\&        $ui = uint_add($ua, $ub);
\&        $ni = nint_sub($na, $nb);
\&        $si = sint_sub($sa, $sb);
\&        $ui = uint_sub($ua, $ub);
\&
\&        use Data::Integer qw(
\&                sint_shl uint_shl
\&                sint_shr uint_shr
\&                sint_rol uint_rol
\&                sint_ror uint_ror
\&        );
\&
\&        $si = sint_shl($si, $dist);
\&        $ui = uint_shl($ui, $dist);
\&        $si = sint_shr($si, $dist);
\&        $ui = uint_shr($ui, $dist);
\&        $si = sint_rol($si, $dist);
\&        $ui = uint_rol($ui, $dist);
\&        $si = sint_ror($si, $dist);
\&        $ui = uint_ror($ui, $dist);
\&
\&        use Data::Integer qw(
\&                nint_bits_as_sint nint_bits_as_uint
\&                sint_bits_as_uint uint_bits_as_sint
\&        );
\&
\&        $si = nint_bits_as_sint($ni);
\&        $ui = nint_bits_as_uint($ni);
\&        $ui = sint_bits_as_uint($si);
\&        $si = uint_bits_as_sint($ui);
\&
\&        use Data::Integer qw(
\&                sint_not uint_not
\&                sint_and uint_and
\&                sint_nand uint_nand
\&                sint_andn uint_andn
\&                sint_or uint_or
\&                sint_nor uint_nor
\&                sint_orn uint_orn
\&                sint_xor uint_xor
\&                sint_nxor uint_nxor
\&                sint_mux uint_mux
\&        );
\&
\&        $si = sint_not($si);
\&        $ui = uint_not($ui);
\&        $si = sint_and($sa, $sb);
\&        $ui = uint_and($ua, $ub);
\&        $si = sint_nand($sa, $sb);
\&        $ui = uint_nand($ua, $ub);
\&        $si = sint_andn($sa, $sb);
\&        $ui = uint_andn($ua, $ub);
\&        $si = sint_or($sa, $sb);
\&        $ui = uint_or($ua, $ub);
\&        $si = sint_nor($sa, $sb);
\&        $ui = uint_nor($ua, $ub);
\&        $si = sint_orn($sa, $sb);
\&        $ui = uint_orn($ua, $ub);
\&        $si = sint_xor($sa, $sb);
\&        $ui = uint_xor($ua, $ub);
\&        $si = sint_nxor($sa, $sb);
\&        $ui = uint_nxor($ua, $ub);
\&        $si = sint_mux($sa, $sb, $sc);
\&        $ui = uint_mux($ua, $ub, $uc);
\&
\&        use Data::Integer qw(
\&                sint_madd uint_madd
\&                sint_msub uint_msub
\&                sint_cadd uint_cadd
\&                sint_csub uint_csub
\&                sint_sadd uint_sadd
\&                sint_ssub uint_ssub
\&        );
\&
\&        $si = sint_madd($sa, $sb);
\&        $ui = uint_madd($ua, $ub);
\&        $si = sint_msub($sa, $sb);
\&        $ui = uint_msub($ua, $ub);
\&        ($carry, $si) = sint_cadd($sa, $sb, $carry);
\&        ($carry, $ui) = uint_cadd($ua, $ub, $carry);
\&        ($carry, $si) = sint_csub($sa, $sb, $carry);
\&        ($carry, $ui) = uint_csub($ua, $ub, $carry);
\&        $si = sint_sadd($sa, $sb);
\&        $ui = uint_sadd($ua, $ub);
\&        $si = sint_ssub($sa, $sb);
\&        $ui = uint_ssub($ua, $ub);
\&
\&        use Data::Integer qw(natint_hex hex_natint);
\&
\&        print natint_hex($value);
\&        $value = hex_natint($string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is about the native integer numerical data type.  A native
integer is one of the types of datum that can appear in the numeric part
of a Perl scalar.  This module supplies constants describing the native
integer type.
.PP
There are actually two native integer representations: signed and
unsigned.  Both are handled by this module.
.SH "NATIVE INTEGERS"
.IX Header "NATIVE INTEGERS"
Each native integer format represents a value using binary place
value, with some fixed number of bits.  The number of bits is the
same for both signed and unsigned representations.  In each case
the least-significant bit has the value 1, the next 2, the next 4,
and so on.  In the unsigned representation, this pattern continues up
to and including the most-significant bit, which for a 32\-bit machine
therefore has the value 2^31 (2147483648).  The unsigned format cannot
represent any negative numbers.
.PP
In the signed format, the most-significant bit is exceptional, having
the negation of the value that it does in the unsigned format.  Thus on
a 32\-bit machine this has the value \-2^31 (\-2147483648).  Values with
this bit set are negative, and those with it clear are non-negative;
this bit is also known as the \*(L"sign bit\*(R".
.PP
It is usual in machine arithmetic to use one of these formats at a
time, for example to add two signed numbers yielding a signed result.
However, Perl has a trick: a scalar with a native integer value contains
an additional flag bit which indicates whether the signed or unsigned
format is being used.  It is therefore possible to mix signed and unsigned
numbers in arithmetic, at some extra expense.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
Each of the extreme-value constants has two names, a short one and a
long one.  The short names are more convenient to use, but the long
names are clearer in a context where other similar constants exist.
.PP
Due to the risks of Perl changing the behaviour of a native integer value
that has been involved in floating point arithmetic (see \*(L"\s-1BUGS\s0\*(R"),
the extreme-value constants are actually non-constant functions that
always return a fresh copy of the appropriate value.  The returned value
is always a pure native integer value, unsullied by floating point or
string operations.
.IP "natint_bits" 4
.IX Item "natint_bits"
The width, in bits, of the native integer data types.
.IP "min_nint" 4
.IX Item "min_nint"
.PD 0
.IP "min_natint" 4
.IX Item "min_natint"
.PD
The minimum representable value in either representation.  This is
\&\-2^(natint_bits \- 1).
.IP "max_nint" 4
.IX Item "max_nint"
.PD 0
.IP "max_natint" 4
.IX Item "max_natint"
.PD
The maximum representable value in either representation.  This is
2^natint_bits \- 1.
.IP "min_sint" 4
.IX Item "min_sint"
.PD 0
.IP "min_signed_natint" 4
.IX Item "min_signed_natint"
.PD
The minimum representable value in the signed representation.  This is
\&\-2^(natint_bits \- 1).
.IP "max_sint" 4
.IX Item "max_sint"
.PD 0
.IP "max_signed_natint" 4
.IX Item "max_signed_natint"
.PD
The maximum representable value in the signed representation.  This is
2^(natint_bits \- 1) \- 1.
.IP "min_uint" 4
.IX Item "min_uint"
.PD 0
.IP "min_unsigned_natint" 4
.IX Item "min_unsigned_natint"
.PD
The minimum representable value in the unsigned representation.
This is zero.
.IP "max_uint" 4
.IX Item "max_uint"
.PD 0
.IP "max_unsigned_natint" 4
.IX Item "max_unsigned_natint"
.PD
The maximum representable value in the unsigned representation.  This is
2^natint_bits \- 1.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Each \*(L"nint_\*(R", \*(L"sint_\*(R", or \*(L"uint_\*(R" function operates on one of the three
integer formats.  \*(L"nint_\*(R" functions operate on Perl's union of signed
and unsigned; \*(L"sint_\*(R" functions operate on signed integers; and \*(L"uint_\*(R"
functions operate on unsigned integers.  Except where indicated otherwise,
the function returns a value of its primary type.
.PP
Parameters \fIA\fR, \fIB\fR, and \fIC\fR, where present, must be numbers of
the appropriate type: specifically, with a numerical value that can be
represented in that type.  If there are multiple flavours of zero, due
to floating point funkiness, all zeroes are treated the same.  Parameters
with other names have other requirements, explained with each function.
.PP
The functions attempt to detect unsuitable arguments, and \f(CW\*(C`die\*(C'\fR if
an invalid argument is detected, but they can't notice some kinds of
incorrect argument.  Generally, it is the caller's responsibility to
provide a sane numerical argument, and supplying an invalid argument will
cause mayhem.  Only the numeric value of plain scalar arguments is used;
the string value is completely ignored, so dualvars are not a problem.
.SS "Canonicalisation and classification"
.IX Subsection "Canonicalisation and classification"
These are basic glue functions.
.IP "nint(A)" 4
.IX Item "nint(A)"
.PD 0
.IP "sint(A)" 4
.IX Item "sint(A)"
.IP "uint(A)" 4
.IX Item "uint(A)"
.PD
These functions each take an argument in a specific integer format and
return its numerical value.  This is the argument canonicalisation that is
performed by all of the functions in this module, presented in isolation.
.IP "nint_is_sint(A)" 4
.IX Item "nint_is_sint(A)"
Takes a native integer of either type.  Returns a truth value indicating
whether this value can be exactly represented as a signed native integer.
.IP "nint_is_uint(A)" 4
.IX Item "nint_is_uint(A)"
Takes a native integer of either type.  Returns a truth value indicating
whether this value can be exactly represented as an unsigned native
integer.
.SS "Arithmetic"
.IX Subsection "Arithmetic"
These functions operate on numerical values rather than just bit patterns.
They will all \f(CW\*(C`die\*(C'\fR if the true numerical result doesn't fit into the
result format, rather than give a wrong answer.
.IP "nint_sgn(A)" 4
.IX Item "nint_sgn(A)"
.PD 0
.IP "sint_sgn(A)" 4
.IX Item "sint_sgn(A)"
.IP "uint_sgn(A)" 4
.IX Item "uint_sgn(A)"
.PD
Returns +1 if the argument is positive, 0 if the argument is zero,
or \-1 if the argument is negative.
.IP "nint_abs(A)" 4
.IX Item "nint_abs(A)"
.PD 0
.IP "sint_abs(A)" 4
.IX Item "sint_abs(A)"
.IP "uint_abs(A)" 4
.IX Item "uint_abs(A)"
.PD
Absolute value (magnitude, discarding sign).
.IP "nint_cmp(A, B)" 4
.IX Item "nint_cmp(A, B)"
.PD 0
.IP "sint_cmp(A, B)" 4
.IX Item "sint_cmp(A, B)"
.IP "uint_cmp(A, B)" 4
.IX Item "uint_cmp(A, B)"
.PD
Arithmetic comparison.  Returns \-1, 0, or +1, indicating whether A is
less than, equal to, or greater than B.
.IP "nint_min(A, B)" 4
.IX Item "nint_min(A, B)"
.PD 0
.IP "sint_min(A, B)" 4
.IX Item "sint_min(A, B)"
.IP "uint_min(A, B)" 4
.IX Item "uint_min(A, B)"
.PD
Arithmetic minimum.  Returns the arithmetically lesser of the two
arguments.
.IP "nint_max(A, B)" 4
.IX Item "nint_max(A, B)"
.PD 0
.IP "sint_max(A, B)" 4
.IX Item "sint_max(A, B)"
.IP "uint_max(A, B)" 4
.IX Item "uint_max(A, B)"
.PD
Arithmetic maximum.  Returns the arithmetically greater of the two
arguments.
.IP "nint_neg(A)" 4
.IX Item "nint_neg(A)"
.PD 0
.IP "sint_neg(A)" 4
.IX Item "sint_neg(A)"
.IP "uint_neg(A)" 4
.IX Item "uint_neg(A)"
.PD
Negation: returns \-A.
.IP "nint_add(A, B)" 4
.IX Item "nint_add(A, B)"
.PD 0
.IP "sint_add(A, B)" 4
.IX Item "sint_add(A, B)"
.IP "uint_add(A, B)" 4
.IX Item "uint_add(A, B)"
.PD
Addition: returns A + B.
.IP "nint_sub(A, B)" 4
.IX Item "nint_sub(A, B)"
.PD 0
.IP "sint_sub(A, B)" 4
.IX Item "sint_sub(A, B)"
.IP "uint_sub(A, B)" 4
.IX Item "uint_sub(A, B)"
.PD
Subtraction: returns A \- B.
.SS "Bit shifting"
.IX Subsection "Bit shifting"
These functions all operate on the bit patterns representing integers,
mostly ignoring the numerical values represented.  In most cases the
results for particular numerical arguments are influenced by the word
size, because that determines where a bit being left-shifted will drop
off the end of the word and where a bit will be shifted in during a
rightward shift.
.PP
With the exception of rightward shifts (see below), each pair of
functions performs exactly the same operations on the bit sequences.
There inevitably can't be any functions here that operate on Perl's union
of signed and unsigned; you must choose, by which function you call,
which type the result is to be tagged as.
.IP "sint_shl(A, \s-1DIST\s0)" 4
.IX Item "sint_shl(A, DIST)"
.PD 0
.IP "uint_shl(A, \s-1DIST\s0)" 4
.IX Item "uint_shl(A, DIST)"
.PD
Bitwise left shift (towards more-significant bits).  \fI\s-1DIST\s0\fR is the
distance to shift, in bits, and must be an integer in the range [0,
natint_bits).  Zeroes are shifted in from the right.
.IP "sint_shr(A, \s-1DIST\s0)" 4
.IX Item "sint_shr(A, DIST)"
.PD 0
.IP "uint_shr(A, \s-1DIST\s0)" 4
.IX Item "uint_shr(A, DIST)"
.PD
Bitwise right shift (towards less-significant bits).  \fI\s-1DIST\s0\fR is the
distance to shift, in bits, and must be an integer in the range [0,
natint_bits).
.Sp
When performing an unsigned right shift, zeroes are shifted in from the
left.  A signed right shift is different: the sign bit gets duplicated,
so right-shifting a negative number always gives a negative result.
.IP "sint_rol(A, \s-1DIST\s0)" 4
.IX Item "sint_rol(A, DIST)"
.PD 0
.IP "uint_rol(A, \s-1DIST\s0)" 4
.IX Item "uint_rol(A, DIST)"
.PD
Bitwise left rotation (towards more-significant bits, with the
most-significant bit wrapping round to the least-significant bit).
\&\fI\s-1DIST\s0\fR is the distance to rotate, in bits, and must be an integer in
the range [0, natint_bits).
.IP "sint_ror(A, \s-1DIST\s0)" 4
.IX Item "sint_ror(A, DIST)"
.PD 0
.IP "uint_ror(A, \s-1DIST\s0)" 4
.IX Item "uint_ror(A, DIST)"
.PD
Bitwise right rotation (towards less-significant bits, with the
least-significant bit wrapping round to the most-significant bit).
\&\fI\s-1DIST\s0\fR is the distance to rotate, in bits, and must be an integer in
the range [0, natint_bits).
.SS "Format conversion"
.IX Subsection "Format conversion"
These functions convert between the various native integer formats
by reinterpreting the bit patterns used to represent the integers.
The bit pattern remains unchanged; its meaning changes, and so the
numerical value changes.  Perl scalars preserve the numerical value,
rather than just the bit pattern, so from the Perl point of view these
are functions that change numbers into other numbers.
.IP "nint_bits_as_sint(A)" 4
.IX Item "nint_bits_as_sint(A)"
Converts a native integer of either type to a signed integer, by
reinterpreting the bits.  The most-significant bit (whether a sign bit
or not) becomes a sign bit.
.IP "nint_bits_as_uint(A)" 4
.IX Item "nint_bits_as_uint(A)"
Converts a native integer of either type to an unsigned integer, by
reinterpreting the bits.  The most-significant bit (whether a sign bit
or not) becomes an ordinary most-significant bit.
.IP "sint_bits_as_uint(A)" 4
.IX Item "sint_bits_as_uint(A)"
Converts a signed integer to an unsigned integer, by reinterpreting
the bits.  The sign bit becomes an ordinary most-significant bit.
.IP "uint_bits_as_sint(A)" 4
.IX Item "uint_bits_as_sint(A)"
Converts an unsigned integer to a signed integer, by reinterpreting
the bits.  The most-significant bit becomes a sign bit.
.SS "Bitwise operations"
.IX Subsection "Bitwise operations"
These functions all operate on the bit patterns representing integers,
completely ignoring the numerical values represented.  They are mostly
not influenced by the word size, in the sense that they will produce
the same numerical result for the same numerical arguments regardless
of word size.  However, a few are affected by the word size: those on
unsigned operands that return a non-zero result if given zero arguments.
.PP
Each pair of functions performs exactly the same operations on the bit
sequences.  There inevitably can't be any functions here that operate on
Perl's union of signed and unsigned; you must choose, by which function
you call, which type the result is to be tagged as.
.IP "sint_not(A)" 4
.IX Item "sint_not(A)"
.PD 0
.IP "uint_not(A)" 4
.IX Item "uint_not(A)"
.PD
Bitwise complement (\s-1NOT\s0).
.IP "sint_and(A, B)" 4
.IX Item "sint_and(A, B)"
.PD 0
.IP "uint_and(A, B)" 4
.IX Item "uint_and(A, B)"
.PD
Bitwise conjunction (\s-1AND\s0).
.IP "sint_nand(A, B)" 4
.IX Item "sint_nand(A, B)"
.PD 0
.IP "uint_nand(A, B)" 4
.IX Item "uint_nand(A, B)"
.PD
Bitwise inverted conjunction (\s-1NAND\s0).
.IP "sint_andn(A, B)" 4
.IX Item "sint_andn(A, B)"
.PD 0
.IP "uint_andn(A, B)" 4
.IX Item "uint_andn(A, B)"
.PD
Bitwise conjunction with inverted argument (A \s-1AND\s0 (\s-1NOT\s0 B)).
.IP "sint_or(A, B)" 4
.IX Item "sint_or(A, B)"
.PD 0
.IP "uint_or(A, B)" 4
.IX Item "uint_or(A, B)"
.PD
Bitwise disjunction (\s-1OR\s0).
.IP "sint_nor(A, B)" 4
.IX Item "sint_nor(A, B)"
.PD 0
.IP "uint_nor(A, B)" 4
.IX Item "uint_nor(A, B)"
.PD
Bitwise inverted disjunction (\s-1NOR\s0).
.IP "sint_orn(A, B)" 4
.IX Item "sint_orn(A, B)"
.PD 0
.IP "uint_orn(A, B)" 4
.IX Item "uint_orn(A, B)"
.PD
Bitwise disjunction with inverted argument (A \s-1OR\s0 (\s-1NOT\s0 B)).
.IP "sint_xor(A, B)" 4
.IX Item "sint_xor(A, B)"
.PD 0
.IP "uint_xor(A, B)" 4
.IX Item "uint_xor(A, B)"
.PD
Bitwise symmetric difference (\s-1XOR\s0).
.IP "sint_nxor(A, B)" 4
.IX Item "sint_nxor(A, B)"
.PD 0
.IP "uint_nxor(A, B)" 4
.IX Item "uint_nxor(A, B)"
.PD
Bitwise symmetric similarity (\s-1NXOR\s0).
.IP "sint_mux(A, B, C)" 4
.IX Item "sint_mux(A, B, C)"
.PD 0
.IP "uint_mux(A, B, C)" 4
.IX Item "uint_mux(A, B, C)"
.PD
Bitwise multiplex.  The output has a bit from B wherever A has a 1 bit,
and a bit from C wherever A has a 0 bit.  That is, the result is (A \s-1AND\s0 B)
\&\s-1OR\s0 ((\s-1NOT\s0 A) \s-1AND\s0 C).
.SS "Machine arithmetic"
.IX Subsection "Machine arithmetic"
These functions perform arithmetic operations that are inherently
influenced by the word size.  They always produce a well-defined output
if given valid inputs.  There inevitably can't be any functions here
that operate on Perl's union of signed and unsigned; you must choose,
by which function you call, which type the result is to be tagged as.
.IP "sint_madd(A, B)" 4
.IX Item "sint_madd(A, B)"
.PD 0
.IP "uint_madd(A, B)" 4
.IX Item "uint_madd(A, B)"
.PD
Modular addition.  The result for unsigned addition is (A + B)
mod 2^natint_bits.  The signed version behaves similarly, but with a
different result range.
.IP "sint_msub(A, B)" 4
.IX Item "sint_msub(A, B)"
.PD 0
.IP "uint_msub(A, B)" 4
.IX Item "uint_msub(A, B)"
.PD
Modular subtraction.  The result for unsigned subtraction is (A \- B)
mod 2^natint_bits.  The signed version behaves similarly, but with a
different result range.
.IP "sint_cadd(A, B, \s-1CARRY_IN\s0)" 4
.IX Item "sint_cadd(A, B, CARRY_IN)"
.PD 0
.IP "uint_cadd(A, B, \s-1CARRY_IN\s0)" 4
.IX Item "uint_cadd(A, B, CARRY_IN)"
.PD
Addition with carry.  Two word arguments (A and B) and an input carry
bit (\s-1CARRY_IN\s0, which must have the value 0 or 1) are all added together.
Returns a list of two items: an output carry and an output word (of the
same signedness as the inputs).  Precisely, the output list (\s-1CARRY_OUT\s0,
R) is such that CARRY_OUT*2^natint_bits + R = A + B + \s-1CARRY_IN\s0.
.IP "sint_csub(A, B, \s-1CARRY_IN\s0)" 4
.IX Item "sint_csub(A, B, CARRY_IN)"
.PD 0
.IP "uint_csub(A, B, \s-1CARRY_IN\s0)" 4
.IX Item "uint_csub(A, B, CARRY_IN)"
.PD
Subtraction with carry (borrow).  The second word argument (B) and
an input carry bit (\s-1CARRY_IN\s0, which must have the value 0 or 1) are
subtracted from the first word argument (A).  Returns a list of two
items: an output carry and an output word (of the same signedness as
the inputs).  Precisely, the output list (\s-1CARRY_OUT\s0, R) is such that R \-
CARRY_OUT*2^natint_bits = A \- B \- \s-1CARRY_IN\s0.
.IP "sint_sadd(A, B)" 4
.IX Item "sint_sadd(A, B)"
.PD 0
.IP "uint_sadd(A, B)" 4
.IX Item "uint_sadd(A, B)"
.PD
Saturating addition.  The result is A + B if that will fit into the result
format, otherwise the minimum or maximum value of the result format is
returned depending on the direction in which the addition overflowed.
.IP "sint_ssub(A, B)" 4
.IX Item "sint_ssub(A, B)"
.PD 0
.IP "uint_ssub(A, B)" 4
.IX Item "uint_ssub(A, B)"
.PD
Saturating subtraction.  The result is A \- B if that will fit into the
result format, otherwise the minimum or maximum value of the result
format is returned depending on the direction in which the subtraction
overflowed.
.SS "String conversion"
.IX Subsection "String conversion"
.IP "natint_hex(\s-1VALUE\s0)" 4
.IX Item "natint_hex(VALUE)"
\&\s-1VALUE\s0 must be a native integer value.  The function encodes \s-1VALUE\s0 in
hexadecimal, returning that representation as a string.  Specifically,
the output is of the form "\fIs\fR\fB0x\fR\fIdddd\fR\*(L", where \*(R"\fIs\fR\*(L" is the sign
and \*(R"\fIdddd\fR" is a sequence of hexadecimal digits.
.IP "hex_natint(\s-1STRING\s0)" 4
.IX Item "hex_natint(STRING)"
Generates and returns a native integer value from a string encoding it in
hexadecimal.  Specifically, the input format is "[\fIs\fR][\fB0x\fR]\fIdddd\fR\*(L",
where \*(R"\fIs\fR\*(L" is the sign and \*(R"\fIdddd\fR" is a sequence of one or more
hexadecimal digits.  The input is interpreted case insensitively.
If the value given in the string cannot be exactly represented in the
native integer type, the function \f(CW\*(C`die\*(C'\fRs.
.Sp
The core Perl function \f(CW\*(C`hex\*(C'\fR (see \*(L"hex\*(R" in perlfunc) does a similar job
to this function, but differs in several ways.  Principally, \f(CW\*(C`hex\*(C'\fR
doesn't handle negative values, and it gives the wrong answer for values
that don't fit into the native integer type.  In Perl 5.6 it also gives
the wrong answer for values that don't fit into the native floating
point type.  It also doesn't enforce strict syntax on the input string.
.SH "BUGS"
.IX Header "BUGS"
In Perl 5.6, when a native integer scalar is used in any arithmetic other
than specifically integer arithmetic, it gets partially transformed into
a floating point scalar.  Even if its numerical value can be represented
exactly in floating point, so that floating point arithmetic uses the
correct numerical value, some operations are affected by the floatness.
In particular, the stringification of the scalar doesn't necessarily
represent its exact value if it is tagged as floating point.
.PP
Because of this transforming behaviour, if you need to stringify a native
integer it is best to ensure that it doesn't get used in any non-integer
arithmetic first.  If an integer scalar must be used in standard Perl
arithmetic, it may be copied first and the copy operated upon to avoid
causing side effects on the original.  If an integer scalar might have
already been transformed, it can be cleaned by passing it through the
canonicalisation function \f(CW\*(C`nint\*(C'\fR.  The functions in this module all
avoid modifying their arguments, and always return pristine integers.
.PP
Perl 5.8+ still internally modifies integer scalars in the same
circumstances, but seems to have corrected all the misbehaviour that
resulted from it.
.PP
Also in Perl 5.6, default Perl arithmetic doesn't necessarily work
correctly on native integers.  (This is part of the motivation for
the myriad arithmetic functions in this module.)  Default arithmetic
here is strictly floating point, so if there are native integers that
cannot be exactly represented in floating point then the arithmetic will
approximate the values before operating on them.  Perl 5.8+ attempts to
use native integer operations where possible in its default arithmetic,
but as of Perl 5.8.8 it doesn't always succeed.  For reliable integer
arithmetic, integer operations must still be requested explicitly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Float,
Scalar::Number,
\&\fIperlnumber\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2007, 2010 Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
