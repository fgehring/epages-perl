.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Jabber::Protocol 3"
.TH Net::Jabber::Protocol 3 "2004-08-17" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Jabber::Protocol \- Jabber Protocol Library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  Net::Jabber::Protocol is a module that provides a developer easy
\&  access to the Jabber Instant Messaging protocol.  It provides high
\&  level functions to the Net::Jabber Client, Component, and Server
\&  objects.  These functions are automatically indluded in those modules
\&  through AUTOLOAD and delegates.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 5
\&  Protocol.pm seeks to provide enough high level APIs and automation of
\&  the low level APIs that writing a Jabber Client/Transport in Perl is
\&  trivial.  For those that wish to work with the low level you can do
\&  that too, but those functions are covered in the documentation for
\&  each module.
\&
\&  Net::Jabber::Protocol provides functions to login, send and receive
\&  messages, set personal information, create a new user account, manage
\&  the roster, and disconnect.  You can use all or none of the functions,
\&  there is no requirement.
\&
\&  For more information on how the details for how Net::Jabber is written
\&  please see the help for Net::Jabber itself.
\&
\&  For more information on writing a Client see Net::Jabber::Client.
\&
\&  For more information on writing a Transport see Net::Jabber::Transport.
.Ve
.SS "Modes"
.IX Subsection "Modes"
.Vb 2
\&  Several of the functions take a mode argument that let you specify how
\&  the function should behave:
\&
\&    block \- send the packet with an ID, and then block until an answer
\&            comes back.  You can optionally specify a timeout so that
\&            you do not block forever.
\&           
\&    nonblock \- send the packet with an ID, but then return that id and
\&               control to the master program.  Net::Jabber is still
\&               tracking this packet, so you must use the CheckID function
\&               to tell when it comes in.  (This might not be very
\&               useful...)
\&
\&    passthru \- send the packet with an ID, but do NOT register it with
\&               Net::Jabber, then return the ID.  This is useful when
\&               combined with the XPath function because you can register
\&               a one shot function tied to the id you get back.
.Ve
.SS "Basic Functions"
.IX Subsection "Basic Functions"
.Vb 3
\&    use Net::Jabber qw( Client );
\&    $Con = new Net::Jabber::Client();                # From
\&    $status = $Con\->Connect(hostname=>"jabber.org"); # Net::Jabber::Client
\&
\&      or
\&
\&    use Net::Jabber qw( Component );
\&    $Con = new Net::Jabber::Component();             #
\&    $status = $Con\->Connect(hostname=>"jabber.org",  # From
\&                            secret=>"bob");          # Net::Jabber::Component
\&
\&
\&    #
\&    # For callback setup, see Net::XMPP::Protocol
\&    #
\&
\&    $Con\->Info(name=>"Jarl",
\&               version=>"v0.6000");
.Ve
.SS "\s-1ID\s0 Functions"
.IX Subsection "ID Functions"
.Vb 10
\&    $id         = $Con\->SendWithID($sendObj);
\&    $id         = $Con\->SendWithID("<tag>XML</tag>");
\&    $receiveObj = $Con\->SendAndReceiveWithID($sendObj);
\&    $receiveObj = $Con\->SendAndReceiveWithID($sendObj,
\&                                             10);
\&    $receiveObj = $Con\->SendAndReceiveWithID("<tag>XML</tag>");
\&    $receiveObj = $Con\->SendAndReceiveWithID("<tag>XML</tag>",
\&                                             5);
\&    $yesno      = $Con\->ReceivedID($id);
\&    $receiveObj = $Con\->GetID($id);
\&    $receiveObj = $Con\->WaitForID($id);
\&    $receiveObj = $Con\->WaitForID($id,
\&                                  20);
.Ve
.SS "\s-1IQ\s0  Functions"
.IX Subsection "IQ  Functions"
.SS "Agents Functions"
.IX Subsection "Agents Functions"
.Vb 2
\&    %agents = $Con\->AgentsGet();
\&    %agents = $Con\->AgentsGet(to=>"transport.jabber.org");
.Ve
.SS "Browse Functions"
.IX Subsection "Browse Functions"
.Vb 3
\&    %hash = $Con\->BrowseRequest(jid=>"jabber.org");
\&    %hash = $Con\->BrowseRequest(jid=>"jabber.org",
\&                                timeout=>10);
\&
\&    $id = $Con\->BrowseRequest(jid=>"jabber.org",
\&                              mode=>"nonblock");
\&
\&    $id = $Con\->BrowseRequest(jid=>"jabber.org",
\&                              mode=>"passthru");
.Ve
.SS "Browse \s-1DB\s0 Functions"
.IX Subsection "Browse DB Functions"
.Vb 2
\&    $Con\->BrowseDBDelete("jabber.org");
\&    $Con\->BrowseDBDelete(Net::Jabber::JID);
\&
\&    $presence  = $Con\->BrowseDBQuery(jid=>"bob\e@jabber.org");
\&    $presence  = $Con\->BrowseDBQuery(jid=>Net::Jabber::JID);
\&    $presence  = $Con\->BrowseDBQuery(jid=>"users.jabber.org",
\&                                     timeout=>10);
\&    $presence  = $Con\->BrowseDBQuery(jid=>"conference.jabber.org",
\&                                     refresh=>1);
.Ve
.SS "Bystreams Functions"
.IX Subsection "Bystreams Functions"
.Vb 3
\&    %hash = $Con\->ByteStreamsProxyRequest(jid=>"proxy.server"); 
\&    %hash = $Con\->ByteStreamsProxyRequest(jid=>"proxy.server",
\&                                          timeout=>10); 
\&
\&    $id = $Con\->ByteStreamsProxyRequest(jid=>"proxy.server",
\&                                        mode=>"nonblock");
\&
\&    $id = $Con\->ByteStreamsProxyRequest(jid=>"proxy.server",
\&                                        mode=>"passthru");
\&
\&    
\&    %hash = $Con\->ByteStreamsProxyParse($query);
\&
\&    
\&    $status = $Con\->ByteStreamsProxyActivate(sid=>"stream_id",
\&                                             jid=>"proxy.server"); 
\&    $status = $Con\->ByteStreamsProxyActivate(sid=>"stream_id",
\&                                             jid=>"proxy.server",
\&                                            timeout=>10); 
\&
\&    $id = $Con\->ByteStreamsProxyActivate(sid=>"stream_id",
\&                                         jid=>"proxy.server",
\&                                        mode=>"nonblock");
\&
\&    $id = $Con\->ByteStreamsProxyActivate(sid=>"stream_id",
\&                                         jid=>"proxy.server",
\&                                        mode=>"passthru"); 
\&
\&
\&    $jid = $Con\->ByteStreamsOffer(sid=>"stream_id",
\&                                  streamhosts=>[{jid=>"jid",
\&                                                 host=>"host",
\&                                                 port=>"port",
\&                                                 zeroconf=>"zero",
\&                                                },
\&                                                ...
\&                                               ],
\&                                  jid=>"bob\e@jabber.org"); 
\&    $jid = $Con\->ByteStreamsOffer(sid=>"stream_id",
\&                                  streamhosts=>[{},{},...],
\&                                  jid=>"bob\e@jabber.org",
\&                                  timeout=>10); 
\&
\&    $id = $Con\->ByteStreamsOffer(sid=>"stream_id",
\&                                 streamhosts=>[{},{},...],
\&                                 jid=>"bob\e@jabber.org",
\&                                 mode=>"nonblock");
\&
\&    $id = $Con\->ByteStreamsOffer(sid=>"stream_id",
\&                                 streamhosts=>[{},{},...],
\&                                 jid=>"bob\e@jabber.org",
\&                                 mode=>"passthru");
.Ve
.SS "Disco Functions"
.IX Subsection "Disco Functions"
.Vb 6
\&    %hash = $Con\->DiscoInfoRequest(jid=>"jabber.org");
\&    %hash = $Con\->DiscoInfoRequest(jid=>"jabber.org",
\&                                   node=>"node...");
\&    %hash = $Con\->DiscoInfoRequest(jid=>"jabber.org",
\&                                   node=>"node...",
\&                                   timeout=>10);
\&
\&    $id = $Con\->DiscoInfoRequest(jid=>"jabber.org",
\&                                 mode=>"nonblock");
\&    $id = $Con\->DiscoInfoRequest(jid=>"jabber.org",
\&                                 node=>"node...",
\&                                 mode=>"nonblock");
\&
\&    $id = $Con\->DiscoInfoRequest(jid=>"jabber.org",
\&                                 mode=>"passthru");
\&    $id = $Con\->DiscoInfoRequest(jid=>"jabber.org",
\&                                 node=>"node...",
\&                                 mode=>"passthru");
\&
\&    
\&    %hash = $Con\->DiscoInfoParse($query);
\&
\&
\&    %hash = $Con\->DiscoItemsRequest(jid=>"jabber.org");
\&    %hash = $Con\->DiscoItemsRequest(jid=>"jabber.org",
\&                                    timeout=>10);
\&
\&    $id = $Con\->DiscoItemsRequest(jid=>"jabber.org",
\&                                  mode=>"nonblock");
\&
\&    $id = $Con\->DiscoItemsRequest(jid=>"jabber.org",
\&                                  mode=>"passthru");
\&
\&    
\&    %hash = $Con\->DiscoItemsParse($query);
.Ve
.SS "Feature Negotiation Functions"
.IX Subsection "Feature Negotiation Functions"
.Vb 8
\&    %hash = $Con\->FeatureNegRequest(jid=>"jabber.org",
\&                                    features=>{ feat1=>["opt1","opt2",...],
\&                                                feat2=>["optA","optB",...]
\&                                              }
\&                                   );
\&    %hash = $Con\->FeatureNegRequest(jid=>"jabber.org",
\&                                    features=>{ ... },
\&                                    timeout=>10);
\&
\&    $id = $Con\->FeatureNegRequest(jid=>"jabber.org",
\&                                  features=>{ ... },
\&                                  mode=>"nonblock");
\&
\&    $id = $Con\->FeatureNegRequest(jid=>"jabber.org",
\&                                  features=>{ ... },
\&                                  mode=>"passthru");
\&
\&    my $query = $self\->FeatureNegQuery(\e{ ... });
\&    $iq\->AddQuery($query);
\&
\&    %hash = $Con\->FeatureNegParse($query);
.Ve
.SS "File Transfer Functions"
.IX Subsection "File Transfer Functions"
.Vb 10
\&    $method = $Con\->FileTransferOffer(jid=>"bob\e@jabber.org",
\&                                      sid=>"stream_id",
\&                                      filename=>"/path/to/file",
\&                                      methods=>["http://jabber.org/protocol/si/profile/bytestreams",
\&                                                "jabber:iq:oob",
\&                                                ...
\&                                               ]
\&                                     );
\&    $method = $Con\->FileTransferOffer(jid=>"bob\e@jabber.org",
\&                                      sid=>"stream_id",
\&                                      filename=>"/path/to/file",
\&                                      methods=>\e@methods,
\&                                      timeout=>"10");
\&
\&    $id = $Con\->FileTransferOffer(jid=>"bob\e@jabber.org",
\&                                  sid=>"stream_id",
\&                                  filename=>"/path/to/file",
\&                                  methods=>\e@methods,
\&                                  mode=>"nonblock");
\&
\&    $id = $Con\->FileTransferOffer(jid=>"bob\e@jabber.org",
\&                                  sid=>"stream_id",
\&                                  filename=>"/path/to/file",
\&                                  methods=>\e@methods,
\&                                  mode=>"passthru");
.Ve
.SS "Last Functions"
.IX Subsection "Last Functions"
.Vb 2
\&    $Con\->LastQuery();
\&    $Con\->LastQuery(to=>"bob@jabber.org");
\&
\&    %result = $Con\->LastQuery(mode=>"block");
\&    %result = $Con\->LastQuery(to=>"bob@jabber.org",
\&                              mode=>"block");
\&
\&    %result = $Con\->LastQuery(to=>"bob@jabber.org",
\&                              mode=>"block",
\&                              timeout=>10);
\&    %result = $Con\->LastQuery(mode=>"block",
\&                              timeout=>10);
\&
\&    $Con\->LastSend(to=>"bob@jabber.org");
\&
\&    $seconds = $Con\->LastActivity();
.Ve
.SS "Multi-User Chat Functions"
.IX Subsection "Multi-User Chat Functions"
.Vb 3
\&    $Con\->MUCJoin(room=>"jabber",
\&                  server=>"conference.jabber.org",
\&                  nick=>"nick");
\&
\&    $Con\->MUCJoin(room=>"jabber",
\&                  server=>"conference.jabber.org",
\&                  nick=>"nick",
\&                  password=>"secret");
.Ve
.SS "Register Functions"
.IX Subsection "Register Functions"
.Vb 5
\&    @result = $Con\->RegisterSendData("users.jabber.org",
\&                                     first=>"Bob",
\&                                     last=>"Smith",
\&                                     nick=>"bob",
\&                                     email=>"foo@bar.net");
.Ve
.SS "\s-1RPC\s0 Functions"
.IX Subsection "RPC Functions"
.Vb 8
\&    $query = $Con\->RPCEncode(type=>"methodCall",
\&                             methodName=>"methodName",
\&                             params=>[param,param,...]);
\&    $query = $Con\->RPCEncode(type=>"methodResponse",
\&                             params=>[param,param,...]);
\&    $query = $Con\->RPCEncode(type=>"methodResponse",
\&                             faultCode=>4,
\&                             faultString=>"Too many params");
\&
\&    @response = $Con\->RPCParse($iq);
\&
\&    @response = $Con\->RPCCall(to=>"dataHouse.jabber.org",
\&                              methodname=>"numUsers",
\&                              params=>[ param,param,... ]
\&                             );
\&
\&    $Con\->RPCResponse(to=>"you\e@jabber.org",
\&                      params=>[ param,param,... ]);
\&
\&    $Con\->RPCResponse(to=>"you\e@jabber.org",
\&                      faultCode=>"4",
\&                      faultString=>"Too many parameters"
\&                     );
\&
\&    $Con\->RPCSetCallBacks(myMethodA=>\e&methoda,
\&                          myMethodB=>\e&do_somthing,
\&                          etc...
\&                         );
.Ve
.SS "Search Functions"
.IX Subsection "Search Functions"
.Vb 4
\&    %fields = $Con\->SearchRequest();
\&    %fields = $Con\->SearchRequest(to=>"users.jabber.org");
\&    %fields = $Con\->SearchRequest(to=>"users.jabber.org",
\&                                  timeout=>10);
\&
\&    $Con\->SearchSend(to=>"somewhere",
\&                     name=>"",
\&                     first=>"Bob",
\&                     last=>"",
\&                     nick=>"bob",
\&                     email=>"",
\&                     key=>"some key");
\&
\&    $Con\->SearchSendData("users.jabber.org",
\&                         first=>"Bob",
\&                         last=>"",
\&                         nick=>"bob",
\&                         email=>"");
.Ve
.SS "Time Functions"
.IX Subsection "Time Functions"
.Vb 2
\&    $Con\->TimeQuery();
\&    $Con\->TimeQuery(to=>"bob@jabber.org");
\&
\&    %result = $Con\->TimeQuery(mode=>"block");
\&    %result = $Con\->TimeQuery(to=>"bob@jabber.org",
\&                              mode=>"block");
\&
\&    $Con\->TimeSend(to=>"bob@jabber.org");
.Ve
.SS "Version Functions"
.IX Subsection "Version Functions"
.Vb 2
\&    $Con\->VersionQuery();
\&    $Con\->VersionQuery(to=>"bob@jabber.org");
\&
\&    %result = $Con\->VersionQuery(mode=>"block");
\&    %result = $Con\->VersionQuery(to=>"bob@jabber.org",
\&                                 mode=>"block");
\&
\&    $Con\->VersionSend(to=>"bob@jabber.org",
\&                      name=>"Net::Jabber",
\&                      ver=>"1.0a",
\&                      os=>"Perl");
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "Basic Functions"
.IX Subsection "Basic Functions"
.Vb 3
\&    Info(name=>string,    \- Set some information so that Net::Jabber
\&         version=>string)   can auto\-reply to some packets for you to
\&                            reduce the work you have to do.
\&
\&                            NOTE: This requires that you use the
\&                            SetIQCallBacks methodology and not the
\&                            SetCallBacks for <iq/> packets.
.Ve
.SS "\s-1IQ\s0 Functions"
.IX Subsection "IQ Functions"
.SS "Agents Functions"
.IX Subsection "Agents Functions"
.Vb 5
\&    ********************************
\&    *                              *
\&    * Deprecated in favor of Disco *
\&    *                              *
\&    ********************************
\&
\&    AgentsGet(to=>string, \- takes all of the information and
\&    AgentsGet()             builds a Net::Jabber::IQ::Agents packet.
\&                            It then sends that packet either to the
\&                            server, or to the specified transport,
\&                            with an ID and waits for that ID to return.
\&                            Then it looks in the resulting packet and
\&                            builds a hash that contains the values
\&                            of the agent list.  The hash is layed out
\&                            like this:  (NOTE: the jid is the key to
\&                            distinguish the various agents)
\&
\&                              $hash{<JID>}\->{order} = 4
\&                                          \->{name} = "ICQ Transport"
\&                                          \->{transport} = "ICQ #"
\&                                          \->{description} = "ICQ..blah.."
\&                                          \->{service} = "icq"
\&                                          \->{register} = 1
\&                                          \->{search} = 1
\&                                        etc...
\&
\&                            The order field determines the order that
\&                            it came from the server in... in case you
\&                            care.  For more info on the valid fields
\&                            see the Net::Jabber::Query jabber:iq:agent
\&                            namespace.
.Ve
.SS "Browse Functions"
.IX Subsection "Browse Functions"
.Vb 5
\&    ********************************
\&    *                              *
\&    * Deprecated in favor of Disco *
\&    *                              *
\&    ********************************
\&
\&    BrowseRequest(jid=>string, \- sends a jabber:iq:browse request to
\&                  mode=>string,  the jid passed as an argument.
\&                  timeout=>int)  Returns a hash with the resulting
\&                                 tree if mode is set to "block":
\&
\&                $browse{\*(Aqcategory\*(Aq} = "conference"
\&                $browse{\*(Aqchildren\*(Aq}\->[0]
\&                $browse{\*(Aqchildren\*(Aq}\->[1]
\&                $browse{\*(Aqchildren\*(Aq}\->[11]
\&                $browse{\*(Aqjid\*(Aq} = "conference.jabber.org"
\&                $browse{\*(Aqname\*(Aq} = "Jabber.org Conferencing Center"
\&                $browse{\*(Aqns\*(Aq}\->[0]
\&                $browse{\*(Aqns\*(Aq}\->[1]
\&                $browse{\*(Aqtype\*(Aq} = "public"
\&
\&                                 The ns array is an array of the
\&                                 namespaces that this jid supports.
\&                                 The children array points to hashs
\&                                 of this form, and represent the fact
\&                                 that they can be browsed to.
\&
\&                                 See MODES above for using the mode
\&                                 and timeout.
.Ve
.SS "Browse \s-1DB\s0 Functions"
.IX Subsection "Browse DB Functions"
.Vb 2
\&    BrowseDBDelete(string|Net::Jabber::JID) \- delete thes JID browse
\&                                              data from the DB.
\&
\&    BrowseDBQuery(jid=>string | NJ::JID, \- returns the browse data
\&                  timeout=>integer,        for the requested JID.  If
\&                  refresh=>0|1)            the DB does not contain
\&                                           the data for the JID, then
\&                                           it attempts to fetch the
\&                                           data via BrowseRequest().
\&                                           The timeout is passed to
\&                                           the BrowseRequest() call,
\&                                           and refresh tells the DB
\&                                           to request the data, even
\&                                           if it already has some.
.Ve
.SS "Bytestreams Functions"
.IX Subsection "Bytestreams Functions"
.Vb 5
\&    ByteStreamsProxyRequest(jid=>string, \- sends a bytestreams request
\&                            mode=>string,  to the jid passed as an
\&                            timeout=>int)  argument.  Returns an array
\&                                           ref with the resulting tree
\&                                           if mode is set to "block".
\&
\&                                           See ByteStreamsProxyParse
\&                                           for the format of the
\&                                           resulting tree.
\&
\&                                           See MODES above for using
\&                                           the mode and timeout.
\&
\&    ByteStreamsProxyParse(Net::Jabber::Query) \- parses the query and
\&                                                returns an array ref
\&                                                to the resulting tree:
\&
\&                $host[0]\->{jid} = "bytestreams1.proxy.server";
\&                $host[0]\->{host} = "proxy1.server";
\&                $host[0]\->{port} = "5006";
\&                $host[1]\->{jid} = "bytestreams2.proxy.server";
\&                $host[1]\->{host} = "proxy2.server";
\&                $host[1]\->{port} = "5007";
\&                ...
\&
\&    ByteStreamsProxyActivate(jid=>string, \- sends a bytestreams activate
\&                             sid=>string,   to the jid passed as an
\&                             mode=>string,  argument.  Returns 1 if the
\&                             timeout=>int)  proxy activated (undef if
\&                                            it did not) if mode is set
\&                                            to "block".
\&
\&                                            sid is the stream id that
\&                                            is being used to talk about
\&                                            this stream.
\&
\&                                            See MODES above for using
\&                                            the mode and timeout.
\&
\&    ByteStreamsOffer(jid=>string,         \- sends a bytestreams offer
\&                     sid=>string,           to the jid passed as an
\&                     streamhosts=>arrayref  argument.  Returns the jid
\&                     mode=>string,          of the streamhost that the
\&                     timeout=>int)          user selected if mode is set
\&                                            to "block".
\&
\&                                            streamhosts is the same
\&                                            format as the array ref
\&                                            returned from
\&                                            ByteStreamsProxyParse.
\&
\&                                            See MODES above for using
\&                                            the mode and timeout.
.Ve
.SS "Disco Functions"
.IX Subsection "Disco Functions"
.Vb 5
\&    DiscoInfoRequest(jid=>string, \- sends a disco#info request to
\&                     node=>string,  the jid passed as an argument,
\&                     mode=>string,  and the node if specified.
\&                     timeout=>int)  Returns a hash with the resulting
\&                                    tree if mode is set to "block".
\&
\&                                    See DiscoInfoParse for the format
\&                                    of the resulting tree.
\&                                    
\&                                    See MODES above for using the mode
\&                                    and timeout.
\&
\&    DiscoInfoParse(Net::Jabber::Query) \- parses the query and
\&                                         returns a hash ref
\&                                         to the resulting tree:
\&
\&             $info{identity}\->[0]\->{category} = "groupchat";
\&             $info{identity}\->[0]\->{name} = "Public Chatrooms";
\&             $info{identity}\->[0]\->{type} = "public";
\&
\&             $info{identity}\->[1]\->{category} = "groupchat";
\&             $info{identity}\->[1]\->{name} = "Private Chatrooms";
\&             $info{identity}\->[1]\->{type} = "private";
\&
\&             $info{feature}\->{http://jabber.org/protocol/disco#info} = 1;
\&             $info{feature}\->{http://jabber.org/protocol/muc#admin} = 1;
\&                                    
\&    DiscoItemsRequest(jid=>string, \- sends a disco#items request to
\&                      mode=>string,  the jid passed as an argument.
\&                      timeout=>int)  Returns a hash with the resulting
\&                                     tree if mode is set to "block".
\&
\&                                     See DiscoItemsParse for the format
\&                                     of the resulting tree.
\&                                    
\&                                     See MODES above for using the mode
\&                                     and timeout.
\&
\&    DiscoItemsParse(Net::Jabber::Query) \- parses the query and
\&                                          returns a hash ref
\&                                          to the resulting tree:
\&
\&             $items{jid}\->{node} = name;
\&
\&             $items{"proxy.server"}\->{""} = "Bytestream Proxy Server";
\&             $items{"conf.server"}\->{"public"} = "Public Chatrooms";
\&             $items{"conf.server"}\->{"private"} = "Private Chatrooms";
.Ve
.SS "Feature Negotiation Functions"
.IX Subsection "Feature Negotiation Functions"
.Vb 5
\&    FeatureNegRequest(jid=>string,       \- sends a feature negotiation to
\&                      features=>hash ref,  the jid passed as an argument,
\&                      mode=>string,        using the features specified.
\&                      timeout=>int)        Returns a hash with the resulting
\&                                           tree if mode is set to "block".
\&
\&                                           See DiscoInfoQuery for the format
\&                                           of the features hash ref.
\&                                    
\&                                           See DiscoInfoParse for the format
\&                                           of the resulting tree.
\&                                    
\&                                           See MODES above for using the mode
\&                                           and timeout.
\&
\&    FeatureNegParse(Net::Jabber::Query) \- parses the query and
\&                                          returns a hash ref
\&                                          to the resulting tree:
\&
\&             $features\->{feat1} = ["opt1","opt2",...];
\&             $features\->{feat2} = ["optA","optB",...];
\&             ....
\&
\&                                          If this is a result:
\&
\&             $features\->{feat1} = "opt2";
\&             $features\->{feat2} = "optA";
\&             ....
\&
\&    FeatureNeqQuery(hash ref) \- takes a hash ref and turns it into a
\&                                feature negotiation query that you can
\&                                AddQuery into your packaet.  The format
\&                                of the hash ref is as follows:
\&
\&             $features\->{feat1} = ["opt1","opt2",...];
\&             $features\->{feat2} = ["optA","optB",...];
\&             ....
.Ve
.SS "File Transfer Functions"
.IX Subsection "File Transfer Functions"
.Vb 6
\&    FileTransferOffer(jid=>string,         \- sends a file transfer stream
\&                      sid=>string,           initiation to the jid passed
\&                      filename=>string,      as an argument.  Returns the
\&                      mode=>string,          method (if the users accepts),
\&                      timeout=>int)          undef (if the user declines),
\&                                             if the mode is set to "block".
\&
\&                                             See MODES above for using
\&                                             the mode and timeout.
.Ve
.SS "Last Functions"
.IX Subsection "Last Functions"
.Vb 5
\&    LastQuery(to=>string,     \- asks the jid specified for its last
\&              mode=>string,     activity.  If the to is blank, then it
\&              timeout=>int)     queries the server.  Returns a hash with
\&    LastQuery()                 the various items set if mode is set to
\&                                "block":
\&
\&                                  $last{seconds} \- Seconds since activity
\&                                  $last{message} \- Message for activity
\&
\&                                See MODES above for using the mode
\&                                and timeout.
\&
\&    LastSend(to=>string, \- sends the specified last to the specified jid.
\&             hash)         the hash is the seconds and message as shown
\&                           in the Net::Jabber::Query man page.
\&
\&    LastActivity() \- returns the number of seconds since the last activity
\&                     by the user.
.Ve
.SS "Multi-User Chat Functions"
.IX Subsection "Multi-User Chat Functions"
.Vb 4
\&    MUCJoin(room=>string,    \- Sends the appropriate MUC protocol to join
\&            server=>string,    the specified room with the specified nick.
\&            nick=>string,
\&            password=>string)
.Ve
.SS "Register Functions"
.IX Subsection "Register Functions"
.Vb 7
\&    RegisterSendData(string|JID, \- takes the contents of the hash and
\&                     hash)         builds a jabebr:x:data return packet
\&                                   which it sends in a Net::Jabber::Query
\&                                   jabber:iq:register namespace packet.
\&                                   The first argument is the JID to send
\&                                   the packet to.  This function returns
\&                                   an array that looks like this:
\&
\&                                     [ type , message ]
\&
\&                                   If type is "ok" then registration was
\&                                   successful, otherwise message contains
\&                                   a little more detail about the error.
.Ve
.SS "\s-1RPC\s0 Functions"
.IX Subsection "RPC Functions"
.Vb 4
\&    RPCParse(IQ object) \- returns an array.  The first argument tells
\&                          the status "ok" or "fault".  The second
\&                          argument is an array if "ok", or a hash if
\&                          "fault".
\&
\&    RPCCall(to=>jid|string,     \- takes the methodName and params,
\&            methodName=>string,   builds the RPC calls and sends it
\&            params=>array,        to the specified address.  Returns
\&            mode=>string,         the above data from RPCParse.
\&            timeout=>int)         
\&                                  See MODES above for using the mode
\&                                  and timeout.
\&
\&    RPCResponse(to=>jid|string,      \- generates a response back to
\&                params=>array,         the caller.  If any part of
\&                faultCode=>int,        fault is specified, then it
\&                faultString=>string)   wins.
\&
\&
\&    Note: To ensure that you get the correct type for a param sent
\&          back, you can specify the type by prepending the type to
\&          the value:
\&
\&            "i4:5" or "int:5"
\&            "boolean:0"
\&            "string:56"
\&            "double:5.0"
\&            "datetime:20020415T11:11:11"
\&            "base64:...."
\&
\&    RPCSetCallBacks(method=>function, \- sets the callback functions
\&                    method=>function,   for the specified methods.
\&                    etc...)             The method comes from the
\&                                        <methodName/> and is case
\&                                        sensitive.  The single
\&                                        arguemnt is a ref to an
\&                                        array that contains the
\&                                        <params/>.  The function you
\&                                        write should return one of two
\&                                        things:
\&
\&                                          ["ok", [...] ]
\&
\&                                        The [...] is a list of the
\&                                        <params/> you want to return.
\&
\&                                          ["fault", {faultCode=>1,
\&                                                     faultString=>...} ]
\&
\&                                        If you set the function to undef,
\&                                        then the method is removed from
\&                                        the list.
.Ve
.SS "Search Functions"
.IX Subsection "Search Functions"
.Vb 6
\&    SearchRequest(to=>string,  \- send an <iq/> request to the specified
\&                  mode=>string,  server/transport, if not specified it
\&                  timeout=>int)  sends to the current active server.
\&    SearchRequest()              The function returns a hash that
\&                                 contains the required fields.   Here
\&                                 is an example of the hash:
\&
\&                                 $hash{fields}    \- The raw fields from
\&                                                    the iq:register.  To
\&                                                    be used if there is
\&                                                    no x:data in the
\&                                                    packet.
\&                                 $hash{instructions} \- How to fill out
\&                                                       the form.
\&                                 $hash{form}   \- The new dynamic forms.
\&
\&                                 In $hash{form}, the fields that are
\&                                 present are the required fields the
\&                                 server needs.
\&                                
\&                                 See MODES above for using the mode
\&                                 and timeout.
\&
\&    SearchSend(to=>string|JID, \- takes the contents of the hash and
\&               hash)             passes it to the SetSearch function
\&                                 in the Net::Jabber::Query
\&                                 jabber:iq:search namespace.  And then
\&                                 sends the packet.
\&
\&    SearchSendData(string|JID, \- takes the contents of the hash and
\&                   hash)         builds a jabebr:x:data return packet
\&                                 which it sends in a Net::Jabber::Query
\&                                 jabber:iq:search namespace packet.
\&                                 The first argument is the JID to send
\&                                 the packet to.
.Ve
.SS "Time Functions"
.IX Subsection "Time Functions"
.Vb 4
\&    TimeQuery(to=>string,     \- asks the jid specified for its localtime.
\&              mode=>string,     If the to is blank, then it queries the
\&              timeout=>int)     server.  Returns a hash with the various
\&    TimeQuery()                 items set if mode is set to "block":
\&
\&                                  $time{utc}     \- Time in UTC
\&                                  $time{tz}      \- Timezone
\&                                  $time{display} \- Display string
\&
\&                                See MODES above for using the mode
\&                                and timeout.
\&
\&    TimeSend(to=>string) \- sends the current UTC time to the specified
\&                           jid.
.Ve
.SS "Version Functions"
.IX Subsection "Version Functions"
.Vb 6
\&    VersionQuery(to=>string,     \- asks the jid specified for its
\&                 mode=>string,     client version information.  If the
\&                 timeout=>int)     to is blank, then it queries the
\&    VersionQuery()                 server.  Returns ahash with the
\&                                   various items set if mode is set to
\&                                   "block":
\&
\&                                     $version{name} \- Name
\&                                     $version{ver}  \- Version
\&                                     $version{os}   \- Operating System/
\&                                                        Platform
\&
\&                                  See MODES above for using the mode
\&                                  and timeout.
\&
\&    VersionSend(to=>string,   \- sends the specified version information
\&                name=>string,   to the jid specified in the to.
\&                ver=>string,
\&                os=>string)
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Ryan Eatmon
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
