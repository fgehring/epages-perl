.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Filter::Merger 3"
.TH XML::Filter::Merger 3 "2009-06-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Filter::Merger \- Assemble multiple SAX streams in to one document
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    ## See XML::SAX::Manifold and XML::SAX::ByRecord for easy ways
\&    ## to use this processor.
\&
\&    my $w = XML::SAX::Writer\->new(           Output => \e*STDOUT );
\&    my $h = XML::Filter::Merger\->new(        Handler => $w );
\&    my $p = XML::SAX::ParserFactory\->parser( Handler => $h );
\&
\&    ## To insert second and later docs in to the first doc:
\&    $h\->start_manifold_document( {} );
\&    $p\->parse_file( $_ ) for @ARGV;
\&    $h\->end_manifold_document( {} );
\&
\&    ## To insert multiple docs inline (especially useful if
\&    ## a subclass does the inline parse):
\&    $h\->start_document( {} );
\&    $h\->start_element( { ... } );
\&    ....
\&    $h\->start_element( { Name => "foo", ... } );
\&    $p\->parse_uri( $uri );   ## Body of $uri inserted in <foo>...</foo>
\&    $h\->end_element( { Name => "foo", ... } );
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Combines several documents in to one \*(L"manifold\*(R" document.  This can be
done in two ways, both of which start by parsing a master document in to
which (the guts of) secondary documents will be inserted.
.SS "Inlining Secondary Documents"
.IX Subsection "Inlining Secondary Documents"
The most SAX-like way is to simply pause the parsing of the master
document between the two events where you want to insert a secondard
document and parse the complete secondard document right then and there
so it's events are inserted in the pipeline at the right spot.
XML::Filter::Merger only passes the content of the secondary document's
root element:
.PP
.Vb 6
\&    my $h = XML::Filter::Merger\->new( Handler => $w );
\&    $h\->start_document( {} );
\&    $h\->start_element( { Name => "foo1" } );
\&        $p\->parse_string( "<foo2><baz /></foo2>" );
\&    $h\->end_element( { Name => "foo1" } );
\&    $h\->end_document( {} );
.Ve
.PP
results in \f(CW$w\fR seeing a document like \f(CW\*(C`<foo1><baz/></foo1>\*(C'\fR.
.PP
This technique is especially useful when subclassing XML::Filter::Merger
to implement XInclude-like behavior.  Here's a useless example that
inserts some content after each \f(CW\*(C`characters()\*(C'\fR event:
.PP
.Vb 1
\&    package Subclass;
\&
\&    use vars qw( @ISA );
\&
\&    @ISA = qw( XML::Filter::Merger );
\&
\&    sub characters {
\&        my $self = shift;
\&
\&        return $self\->SUPER::characters( @_ )  ## **
\&            unless $self\->in_master_document;  ## **
\&
\&        my $r = $self\->SUPER::characters( @_ );
\&
\&        $self\->set_include_all_roots( 1 );
\&
\&        XML::SAX::PurePerl\->new( Handler => $self )\->parse_string( "<hey/>" );
\&        return $r;
\&    }
\&
\&    ## **: It is often important to use the recursion guard shown here
\&    ## to protect the decision making logic that should only be run on
\&    ## the events in the master document from being run on events in the
\&    ## subdocument.  Of course, if you want to apply the logic
\&    ## recursively, just leave the guard code out (and, yes, in this
\&    ## example, th guard code is phrased in a slightly redundant fashion,
\&    ## but we want to make the idiom clear).
.Ve
.PP
Feeding this filter \f(CW\*(C`<foo> </foo>\*(C'\fR results in \f(CW\*(C`<foo>
<hey/></foo>\*(C'\fR.  We've called \f(CWset_include_all_roots( 1 )\fR to get the
secondary document's root element included.
.SS "Inserting Manifold Documents"
.IX Subsection "Inserting Manifold Documents"
A more involved way suitable to handling consecutive documents it to use
the two non-SAX events\*(--\f(CW\*(C`start_manifold_document\*(C'\fR and
\&\f(CW\*(C`end_manifold_document\*(C'\fR\-\-that are called before the first document to
be combined and after the last one, respectively.
.PP
The first document to be started after the
\&\f(CW\*(C`start_manifold_document\*(C'\fR is the master document and is emitted as-is
except that it will contain the contents of all of the other documents
just before the root \f(CW\*(C`end_element()\*(C'\fR tag.  For example:
.PP
.Vb 4
\&    $h\->start_manifold_document( {} );
\&    $p\->parse_string( "<foo1><bar /></foo1>" );
\&    $p\->parse_string( "<foo2><baz /></foo2>" );
\&    $h\->end_manifold_document( {} );
.Ve
.PP
results in \f(CW\*(C`<foo><bar /><baz /></foo>\*(C'\fR.
.SS "The details"
.IX Subsection "The details"
In case the above was a bit vague, here are the rules this filter lives
by.
.PP
For the master document:
.IP "\(bu" 4
Events before the root \f(CW\*(C`end_element\*(C'\fR are forwarded as received.
Because of the rules for secondary documents, any secondary documents
sent to the filter in the midst of a master document will be
inserted inline as their events are received.
.IP "\(bu" 4
All remaining events, from the root \f(CW\*(C`end_element\*(C'\fR are
buffered until the \fIend_manifold_document()\fR received, and are then
forwarded on.
.PP
For secondary documents:
.IP "\(bu" 4
All events before the root \f(CW\*(C`start_element\*(C'\fR are discarded.  There is
no way to recover these (though we can add an option for most non-DTD
events, I believe).
.IP "\(bu" 4
The root \f(CW\*(C`start_element\*(C'\fR is discarded by default, or forwarded if
\&\f(CW\*(C`set_include_all_roots( $v )\*(C'\fR has been used to set a true value.
.IP "\(bu" 4
All events up to, but not including, the root \f(CW\*(C`end_element\*(C'\fR are
forwarded as received.
.IP "\(bu" 4
The root \f(CW\*(C`end_element\*(C'\fR is discarded or forwarded if the matching
\&\f(CW\*(C`start_element\*(C'\fR was.
.IP "\(bu" 4
All remaining events until and including the \f(CW\*(C`end_document\*(C'\fR are
forwarded and processing.
.IP "\(bu" 4
Secondary documents may contain other secondary documents.
.IP "\(bu" 4
Secondary documents need not be well formed.  The must, however, be well
balanced.
.PP
This requires very little buffering and is \*(L"most natural\*(R" with the
limitations:
.IP "\(bu" 4
All of each secondary document's events must all be received
between two consecutive events of it's master document.  This is because
most master document events are not buffered and this filter cannot
tell from which upstream source a document came.
.IP "\(bu" 4
If the master document should happen to have some egregiously large
amount of whitespace, commentary, or illegal events after the root
element, buffer memory could be huge.  This should be exceedingly rare,
even non-existent in the real world.
.IP "\(bu" 4
If any documents are not well balanced, the result won't be.
.IP "\(bu" 4

.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 1
\&    my $d = XML::Filter::Merger\->new( \e%options );
.Ve
.IP "reset" 4
.IX Item "reset"
Clears the filter after an accident.  Useful when reusing the filter.
\&\fInew()\fR and \fIstart_manifold_document()\fR both call this.
.IP "start_manifold_document" 4
.IX Item "start_manifold_document"
This must be called before the master document's \f(CW\*(C`start_document()\*(C'\fR
if you want XML::Filter::Merger to insert documents that will be sent
after the master document.
.Sp
It does not need to be called if you are going to insert secondary
documents by sending their events in the midst of processing the master
document.
.Sp
It is passed an empty ({}) data structure.
.SH "Additional Methods"
.IX Header "Additional Methods"
These are provided to make it easy for subclasses to find out roughly
where they are in the document structure.  Generally, these should be
called after calling SUPER::start_...() and before calling
SUPER::end_...() to be accurate.
.IP "in_master_document" 4
.IX Item "in_master_document"
Returns \s-1TRUE\s0 if the current event is in the first top level document.
.IP "document_depth" 4
.IX Item "document_depth"
Gets how many nested documents surround the current document.  0 means that you
are in a top level document.  In manifold mode, This may or may not be a
secondary document: secondary documents may also follow the primary
document, in which case they have a document depth of 0.
.IP "element_depth" 4
.IX Item "element_depth"
Gets how many nested elements surround the current element in the
current input document.  Does not count elements from documents
surrounding this document.
.IP "top_level_document_number" 4
.IX Item "top_level_document_number"
Returns the number of the top level document in a manifold document.
This is 0 for the first top level document, which is always the master
document.
.IP "end_manifold_document" 4
.IX Item "end_manifold_document"
This must be called after the last document's end_document is called.  It
is passed an empty ({}) data structure which is passed on to the
next processor's \fIend_document()\fR call.  This call also causes the
\&\fIend_element()\fR for the root element to be passed on.
.IP "set_include_all_roots" 4
.IX Item "set_include_all_roots"
.Vb 1
\&    $h\->set_include_all_roots( 1 );
.Ve
.Sp
Setting this option causes the merger to include all root element nodes,
not just the first document's.  This means that later documents are
treated as subdocuments of the output document, rather than as envelopes
carrying subdocuments.
.Sp
Given two documents received are:
.Sp
.Vb 1
\& Doc1:   <root1><foo></root1>
\&
\& Doc1:   <root2><bar></root2>
\&
\& Doc3:   <root3><baz></root3>
.Ve
.Sp
then with this option cleared (the default), the result looks like:
.Sp
.Vb 1
\&    <root1><foo><bar><baz></root1>
.Ve
.Sp
\&.  This is useful when processing document oriented \s-1XML\s0 and each
upstream filter channel gets a complete copy of the document.  This is
the case with the machine XML::SAX::Manifold and the splitting filter
XML::Filter::Distributor.
.Sp
With this option set, the result looks like:
.Sp
.Vb 1
\&    <root1><foo><root2><bar></root2><root3><baz></root3></root1>
.Ve
.Sp
This is useful when processing record oriented \s-1XML\s0, where the first
document only contains the preamble and postamble for the records and
not all of the records.  This is the case with the machine
XML::SAX::ByRecord and the splitting filter
XML::Filter::DocSplitter.
.Sp
The two splitter filters mentioned set this feature appropriately.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
The events before and after a secondary document's root element events
are discarded.  It is conceivable that characters, PIs and commentary
outside the root element might need to be kept.  This may be added as an
option.
.PP
The DocumentLocators are not properly managed: they should be saved and
restored around each each secondary document.
.PP
Does not yet buffer all events after the first document's root end_element
event.
.PP
If these bite you, contact me.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    Barrie Slaymaker <barries@slaysys.com>
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&    Copyright 2002, Barrie Slaymaker, All Rights Reserved.
.Ve
.PP
You may use this module under the terms of the Artistic, \s-1GNU\s0 Public, or
\&\s-1BSD\s0 licenses, you choice.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 419:" 4
.IX Item "Around line 419:"
You forgot a '=back' before '=head1'
