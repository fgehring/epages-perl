.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Inline::Section 3"
.TH Test::Inline::Section 3 "2010-11-22" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Inline::Section \- Implements a section of tests
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements a single section of tests. That is, a section of \s-1POD\s0
beginning with \f(CW\*(C`=begin test\*(C'\fR or \f(CW\*(C`=begin testing\*(C'\fR.
.SS "Types of Sections"
.IX Subsection "Types of Sections"
There are two types of code sections. The first, beginning with 
\&\f(CW\*(C`=begin testing ...\*(C'\fR, contains a set of tests and other code to be executed
at any time (within a set of specifyable constraints). The second, labelled
\&\f(CW\*(C`=begin testing SETUP\*(C'\fR, contains code to be executed at the beginning of the
test script, before any of the other sections are executed. This allows
any needed variables or environment to be set up before the tests are run.
You can have more than one setup section, and they will be written to the
test file in order of appearance.
.SS "Test Section Header Syntax"
.IX Subsection "Test Section Header Syntax"
Some examples of the different types of test headers are as follows.
.PP
.Vb 2
\&  # Normal anonymous test
\&  =begin testing
\&  
\&  ok( $foo == $bar, \*(AqThis is a test\*(Aq );
\&  
\&  =end testing
\&  
\&  # A named test. Also provides the number of tests to run.
\&  # Any test section can specify the number of tests.
\&  =begin testing my_method 1
\&  
\&  ok( $foo\->my_method, \*(Aq\->my_method returns true\*(Aq );
\&  
\&  =end testing
\&  
\&  # A named test with pre\-requisites.
\&  # Note that ONLY named tests can have pre\-requisites
\&  =begin testing this after my_method foo bar other_method Other::Class
\&  
\&  ok( $foo\->this, \*(Aq\->this returns true\*(Aq );
\&  
\&  =end testing
.Ve
.PP
The first example shows a normal anonymous test. All anonymous test sections
are considered low priority, and we be run, in order of appearance, \s-1AFTER\s0 all
named tests have been run.
.PP
Any and all arguments used after \*(L"testing\*(R" must be in the form of simple
space seperated words. The first word is considered the \*(L"name\*(R" of the test.
The intended use for these is generally to create one named test section for 
each function or method, but you can name them as you please. Test names 
\&\fBmust\fR be unique, and \fBare\fR case sensitive.
.PP
After the name, you can provide the word \*(L"after\*(R" and provide a list of other
named tests that must be completed first in order to run this test. This is
provided so that when errors are encounted, they are probably the result of
this method or set of tests, and not in some other method that this one 
relies on. It makes debugging a lot easier. The word after is only a 
keyword when after the test name, so you can use a test name of after as well.
The following are both legal
.PP
.Vb 2
\&  =begin testing after after that
\&  =begin testing this after after
.Ve
.PP
The easiest and recommended way of labeling the tests is simple to name all
tests after their methods, and put as a pre-requisite any other methods that
the method you are testing calls. Test::Inline will take care of writing the
tests to the test script in the correct order. Please note you can \s-1NOT\s0 define
circular relationships in the prerequisites, or an error will occur.
.PP
If a number is provided as the last value, it will be taken to mean the
number of actual tests that will occur during the test section. While
preparing to write the test files, the processor will try to use these
to try to determine the number of files to write. If \s-1ALL\s0 test sections to
be written to a particular file have a test count, then the script will
use the total of these as a basic for providing Test::More with a plan.
.PP
If \s-1ANY\s0 test sections to be written to a file do not have a test count, the
test file with use \f(CW\*(C`no_plan\*(C'\fR.
.PP
Finally, Test::Inline will try to be forgiving in it's parsing of the tests.
any missing prerequisites will be ignored. Also, as long as it does not
break a prerequisite, all named tests will be attempted to be run in their
order of appearance.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $Section = Test::Inline::Section\->new( $pod );
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor takes a string of \s-1POD\s0, which must be a single section
of relevant pod ( preferably produced by Test::Inline::ExtractHandler ),
and creates a new section object for it.
.PP
Returns a new \f(CW\*(C`Test::Inline::Section\*(C'\fR object if passed \s-1POD\s0 in the form
\&\f(CW\*(C`=begin testing ...\*(C'\fR. Returns \f(CW\*(C`undef\*(C'\fR on error.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  my $SectionList = Test::Inline::Section( @elements );
.Ve
.PP
Since version 1.50 Test::Inline has been extracting package statements
so that as the sections are extracted, we can determine which sections
belong to which packages, and seperate them accordingly.
.PP
The \f(CW\*(C`parse\*(C'\fR method takes \fBall\fR of the elements from a file, and returns
all of the Sections. By doing it here, we can track the package context
and set it in the Sections.
.SS "setup"
.IX Subsection "setup"
.Vb 1
\&  my $run_first = $Section\->setup;
.Ve
.PP
The \f(CW\*(C`setup\*(C'\fR accessor indicates that this section is a \*(L"setup\*(R" section,
to be run at the beginning of the generated test script.
.PP
Returns true if this is a setup section, false otherwise.
.SS "example"
.IX Subsection "example"
.Vb 1
\&  my $just_compile = $Section\->example;
.Ve
.PP
The \f(CW\*(C`example\*(C'\fR accessor indicates that this section is an \*(L"example\*(R"
section, to be compile-tested instead of run.
.PP
Returns true if this is an example section, false otherwise.
.SS "context"
.IX Subsection "context"
The \f(CW\*(C`context\*(C'\fR method returns the package context of the unit test section,
or false if the unit test section appeared out of context.
.SS "name"
.IX Subsection "name"
The \f(CW\*(C`name\*(C'\fR method returns the name of the test section,
or false if the test if anonymous.
.SS "tests"
.IX Subsection "tests"
The \f(CW\*(C`tests\*(C'\fR method returns the number of Test::Builder\-compatible
tests that will run within the test section. Returns \f(CW\*(C`undef\*(C'\fR if the
number of tests is unknown.
.SS "begin"
.IX Subsection "begin"
For use mainly in debugging, the \f(CW\*(C`begin\*(C'\fR method returns the literal string
of the begin line/paragraph.
.SS "anonymous"
.IX Subsection "anonymous"
.Vb 1
\&  my $is_anonymous = $Section\->anonymous;
.Ve
.PP
The \f(CW\*(C`anonymous\*(C'\fR method returns true if the test section is an unnamed
anonymous section, or false if it is a named section or a setup section.
.SS "after"
.IX Subsection "after"
.Vb 1
\&  my @names = $Section\->after;
.Ve
.PP
The \f(CW\*(C`after\*(C'\fR method returns the list of other named tests that this
test section says it should be run after.
.PP
Returns a list of test name, or the null list \f(CW\*(C`()\*(C'\fR if the test does
not have to run after any other named tests.
.SS "classes"
.IX Subsection "classes"
.Vb 1
\&  my @classes = $Section\->classes;
.Ve
.PP
The \f(CW\*(C`classes\*(C'\fR method returns the list of test classes that the test depends
on, and should be run before the tests. These values are used to determine the
set of class-level dependencies for the entire test file.
.PP
Returns a list of class names, or the null list \f(CW\*(C`()\*(C'\fR if the test does
not have any class-level dependencies.
.SS "content"
.IX Subsection "content"
.Vb 1
\&  my $code = $Section\->content;
.Ve
.PP
The \f(CW\*(C`content\*(C'\fR method returns the actual testing code contents of the 
section, with the leading \f(CW\*(C`=begin\*(C'\fR and trailing \f(CW\*(C`=end\*(C'\fR removed.
.PP
Returns a string containing the code, or the null string \f(CW""\fR if the
section was empty.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the main \s-1SUPPORT\s0 section.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004 \- 2010 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
