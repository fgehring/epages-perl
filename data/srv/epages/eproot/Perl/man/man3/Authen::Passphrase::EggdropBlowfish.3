.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::Passphrase::EggdropBlowfish 3"
.TH Authen::Passphrase::EggdropBlowfish 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::Passphrase::EggdropBlowfish \- passphrases using Eggdrop's
blowfish.mod
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Authen::Passphrase::EggdropBlowfish;
\&
\&        $ppr = Authen::Passphrase::EggdropBlowfish\->new(
\&                hash_base64 => "9tpsG/61YqX/");
\&
\&        $ppr = Authen::Passphrase::EggdropBlowfish\->new(
\&                passphrase => "passphrase");
\&
\&        $hash = $ppr\->hash;
\&        $hash_base64 = $ppr\->hash_base64;
\&
\&        if($ppr\->match($passphrase)) { ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class encapsulates a passphrase hashed using the
Blowfish-based algorithm used in Eggdrop's blowfish.mod.  This is a
subclass of Authen::Passphrase, and this document assumes that the
reader is familiar with the documentation for that class.
.PP
This hash scheme uses no salt, and does not accept a zero-length
passphrase.  It uses the passphrase as a Blowfish key to encrypt a
standard plaintext block.  The hash is the ciphertext block.  The standard
Blowfish key schedule only accepts keys from 8 to 56 bytes long; this
algorithm relaxes that requirement and accepts any non-zero length.
Up to 72 bytes of passphrase/key are significant; any more are ignored.
.PP
In Eggdrop the hash is represented as a "\fB+\fR\*(L" followed by twelve base
64 digits.  The first six digits encode the second half of the hash,
and the last six encode the first half.  Within each half the bytes
are encoded in reverse order.  The base 64 digits are \*(R"\fB.\fR\*(L", \*(R"\fB/\fR\*(L",
\&\*(R"\fB0\fR\*(L" to \*(R"\fB9\fR\*(L", \*(R"\fBa\fR\*(L" to \*(R"\fBz\fR\*(L", \*(R"\fBA\fR\*(L" to \*(R"\fBZ\fR" (in that order).
.PP
\&\fIWarning:\fR The hash is small by modern standards, and the lack of salt
is a weakness in this scheme.  For a scheme that makes better use of
Blowfish see Authen::Passphrase::BlowfishCrypt.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Authen::Passphrase::EggdropBlowfish\->new(\s-1ATTR\s0 => \s-1VALUE\s0, ...)" 4
.IX Item "Authen::Passphrase::EggdropBlowfish->new(ATTR => VALUE, ...)"
Generates a new passphrase recogniser object using the Eggdrop
blowfish.mod algorithm.  The following attributes may be given:
.RS 4
.IP "\fBhash\fR" 4
.IX Item "hash"
The hash, as a string of eight bytes.
.IP "\fBhash_base64\fR" 4
.IX Item "hash_base64"
The hash, as a string of twelve base 64 digits.
.IP "\fBpassphrase\fR" 4
.IX Item "passphrase"
A passphrase that will be accepted.
.RE
.RS 4
.Sp
Either the hash or the passphrase must be given.
.RE
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ppr\->hash" 4
.el .IP "\f(CW$ppr\fR\->hash" 4
.IX Item "$ppr->hash"
Returns the hash value, as a string of eight bytes.
.ie n .IP "$ppr\->hash_base64" 4
.el .IP "\f(CW$ppr\fR\->hash_base64" 4
.IX Item "$ppr->hash_base64"
Returns the hash value, as a string of twelve base 64 digits.
.ie n .IP "$ppr\->match(\s-1PASSPHRASE\s0)" 4
.el .IP "\f(CW$ppr\fR\->match(\s-1PASSPHRASE\s0)" 4
.IX Item "$ppr->match(PASSPHRASE)"
This method is part of the standard Authen::Passphrase interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::Passphrase,
Crypt::Eksblowfish::Uklblowfish
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
