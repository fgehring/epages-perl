.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IPv4Addr 3"
.TH IPv4Addr 3 "2000-08-02" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::IPv4Addr \- Perl extension for manipulating IPv4 addresses.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Net::IPv4Addr qw( :all );
\&
\&  my ($ip,$cidr) = ipv4_parse( "127.0.0.1/24" );
\&  my ($ip,$cidr) = ipv4_parse( "192.168.100.10 / 255.255.255.0" );
\&
\&  my ($net,$msk) = ipv4_network( "192.168.100.30" );
\&
\&  my $broadcast  = ipv4_broadcast( "192.168.100.30/26" );
\&
\&  if ( ipv4_in_network( "192.168.100.0", $her_ip ) ) {
\&    print "Welcome !";
\&  }
\&
\&  etc.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::IPv4Addr provides functions for parsing IPv4 addresses both
in traditional address/netmask format and in the new \s-1CIDR\s0 format.
There are also methods for calculating the network and broadcast 
address and also to see check if a given address is in a specific
network.
.SH "ADDRESSES"
.IX Header "ADDRESSES"
All of Net::IPv4Addr functions accepts addresses in many
format. The parsing is very liberal.
.PP
All these addresses would be accepted:
.PP
.Vb 6
\&    127.0.0.1
\&    192.168.001.010/24
\&    192.168.10.10/255.255.255.0
\&    192.168.30.10 / 21
\&    10.0.0.0 / 255.0.0.0
\&    255.255.0.0
.Ve
.PP
Those wouldn't though:
.PP
.Vb 2
\&    272.135.234.0
\&    192.168/16
.Ve
.PP
Most functions accepts the address and netmask or masklength in the
same scalar value or as separate values. That is either
.PP
.Vb 2
\&    my($ip,$masklength) = ipv4_parse($cidr_str);
\&    my($ip,$masklength) = ipv4_parse($ip_str,$msk_str);
.Ve
.SH "USING"
.IX Header "USING"
No functions are exported by default. Either use the \f(CW\*(C`:all\*(C'\fR tag 
to import them all or explicitly import those you need.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "ipv4_parse" 4
.IX Item "ipv4_parse"
.Vb 3
\&    my ($ip,$msklen) = ipv4_parse($cidr_str);
\&    my $cidr = ipv4_parse($ip_str,$msk_str);
\&    my ($ip) = ipv4_parse($ip_str,$msk_str);
.Ve
.Sp
Parse an IPv4 address and in scalar context the address in \s-1CIDR\s0
format and in an array context the address and the mask length.
.Sp
If the parameters doesn't contains a netmask or a mask length, 
in scalar context only the IPv4 address is returned and in an 
array context the mask length is undefined.
.Sp
If the function cannot parse its input, it croaks. Trap it using
\&\f(CW\*(C`eval\*(C'\fR if don't like that.
.IP "ipv4_network" 4
.IX Item "ipv4_network"
.Vb 3
\&    my $cidr = ipv4_network($ip_str);
\&    my $cidr = ipv4_network($cidr_str);
\&    my ($net,$msk) = ipv4_network( $net_str, $msk_str);
.Ve
.Sp
In scalar context, this function returns the network in \s-1CIDR\s0 format in
which the address is. In array context, it returns the network address and
its mask length as a two elements array. If the input is an host without
a netmask of mask length, the default netmask is assumed.
.Sp
Again, the function croak if the input is invalid.
.IP "ipv4_broadcast" 4
.IX Item "ipv4_broadcast"
.Vb 2
\&    my ($broadcast) = ipv4_broadcast($ip_str);
\&    my $broadcast   = ipv4_broadcast($ip_str,$msk_str);
.Ve
.Sp
This function returns the broadcast address. If the input doesn't
contains a netmask or mask length, the default netmask is assumed.
.Sp
This function croaks if the input is invalid.
.IP "ipv4_network" 4
.IX Item "ipv4_network"
.Vb 3
\&    my $cidr = ipv4_network($net_str);
\&    my $cidr = ipv4_network($cidr_sstr);
\&    my ($net,$msk) = ipv4_network( $ip_str, $mask_str);
.Ve
.Sp
In scalar context, this function returns the network in \s-1CIDR\s0 format in
which the address is. In array context, it returns the network address and
its mask length as a two elements array. If the input is an host without
a netmask or mask length, the default netmask is assumed.
.Sp
Again, the function croak if the input is invalid.
.IP "ipv4_in_network" 4
.IX Item "ipv4_in_network"
.Vb 3
\&    print "Yes" if ipv4_in_network( $cidr_str1, $cidr_str2);
\&    print "Yes" if ipv4_in_network( $ip_str1, $mask_str1, $cidr_str2 );
\&    print "Yes" if ipv4_in_network( $ip1, $mask1, $ip2, $msk2 );
.Ve
.Sp
This function checks if the second network is contained in
the first one and it implements the following semantics :
.Sp
.Vb 2
\&   If net1 or net2 is a magic address (0.0.0.0 or 255.255.255.255)
\&   than this function returns true.
\&
\&   If net1 is an host, net2 will be in the same net only if
\&   it is the same host.
\&
\&   If net2 is an host, it will be contained in net1 only if
\&   it is part of net1.
\&
\&   If net2 is only part of net1 if it is entirely contained in
\&   net1.
.Ve
.Sp
Trap bad input with \f(CW\*(C`eval\*(C'\fR or else.
.IP "ipv4_checkip" 4
.IX Item "ipv4_checkip"
.Vb 3
\&    if ($ip = ipv4_checkip($str) ) {
\&        # Do something
\&    }
.Ve
.Sp
Return the IPv4 address in the string or undef if the input 
doesn't contains a valid IPv4 address.
.IP "ipv4_cidr2msk" 4
.IX Item "ipv4_cidr2msk"
.Vb 1
\&    my $netmask = ipv4_cidr2msk( $cidr );
.Ve
.Sp
Returns the netmask corresponding to the mask length given in input. 
As usual, croaks if it doesn't like your input (in this case a number
between 0 and 32).
.IP "ipv4_msk2cidr" 4
.IX Item "ipv4_msk2cidr"
.Vb 1
\&    my $masklen = ipv4_msk2cidr( $msk );
.Ve
.Sp
Returns the mask length of the netmask in input. As usual, croaks if it
doesn't like your input.
.SH "AUTHOR"
.IX Header "AUTHOR"
Francis J. Lacoste <francis.lacoste@iNsu.COM>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1999, 2000 iNsu Innovations Inc.
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms as perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1) \fIipv4calc\fR\|(1).
