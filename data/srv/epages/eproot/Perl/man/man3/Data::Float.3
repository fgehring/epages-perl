.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Float 3"
.TH Data::Float 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Float \- details of the floating point data type
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Data::Float qw(have_signed_zero);
\&
\&        if(have_signed_zero) { ...
\&
\&        # and many other constants; see text
\&
\&        use Data::Float qw(
\&                float_class float_is_normal float_is_subnormal
\&                float_is_nzfinite float_is_zero float_is_finite
\&                float_is_infinite float_is_nan
\&        );
\&
\&        $class = float_class($value);
\&
\&        if(float_is_normal($value)) { ...
\&        if(float_is_subnormal($value)) { ...
\&        if(float_is_nzfinite($value)) { ...
\&        if(float_is_zero($value)) { ...
\&        if(float_is_finite($value)) { ...
\&        if(float_is_infinite($value)) { ...
\&        if(float_is_nan($value)) { ...
\&
\&        use Data::Float qw(float_sign signbit float_parts);
\&
\&        $sign = float_sign($value);
\&        $sign_bit = signbit($value);
\&        ($sign, $exponent, $significand) = float_parts($value);
\&
\&        use Data::Float qw(float_hex hex_float);
\&
\&        print float_hex($value);
\&        $value = hex_float($string);
\&
\&        use Data::Float qw(float_id_cmp totalorder);
\&
\&        @sorted_floats = sort { float_id_cmp($a, $b) } @floats;
\&        if(totalorder($a, $b)) { ...
\&
\&        use Data::Float qw(
\&                pow2 mult_pow2 copysign
\&                nextup nextdown nextafter
\&        );
\&
\&        $x = pow2($exp);
\&        $x = mult_pow2($value, $exp);
\&        $x = copysign($magnitude, $sign_from);
\&        $x = nextup($x);
\&        $x = nextdown($x);
\&        $x = nextafter($x, $direction);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is about the native floating point numerical data type.
A floating point number is one of the types of datum that can appear
in the numeric part of a Perl scalar.  This module supplies constants
describing the native floating point type, classification functions,
and functions to manipulate floating point values at a low level.
.SH "FLOATING POINT"
.IX Header "FLOATING POINT"
.SS "Classification"
.IX Subsection "Classification"
Floating point values are divided into five subtypes:
.IP "normalised" 4
.IX Item "normalised"
The value is made up of a sign bit (making the value positive or
negative), a significand, and exponent.  The significand is a number
in the range [1, 2), expressed as a binary fraction of a certain fixed
length.  (Significands requiring a longer binary fraction, or lacking a
terminating binary representation, cannot be obtained.)  The exponent
is an integer in a certain fixed range.  The magnitude of the value
represented is the product of the significand and two to the power of
the exponent.
.IP "subnormal" 4
.IX Item "subnormal"
The value is made up of a sign bit, significand, and exponent, as
for normalised values.  However, the exponent is fixed at the minimum
possible for a normalised value, and the significand is in the range
(0, 1).  The length of the significand is the same as for normalised
values.  This is essentially a fixed-point format, used to provide
gradual underflow.  Not all floating point formats support this subtype.
Where it is not supported, underflow is sudden, and the difference between
two minimum-exponent normalised values cannot be exactly represented.
.IP "zero" 4
.IX Item "zero"
Depending on the floating point type, there may be either one or two
zero values: zeroes may carry a sign bit.  Where zeroes are signed,
it is primarily in order to indicate the direction from which a value
underflowed (was rounded) to zero.  Positive and negative zero compare
as numerically equal, and they give identical results in most arithmetic
operations.  They are on opposite sides of some branch cuts in complex
arithmetic.
.IP "infinite" 4
.IX Item "infinite"
Some floating point formats include special infinite values.  These are
generated by overflow, and by some arithmetic cases that mathematically
generate infinities.  There are two infinite values: positive infinity
and negative infinity.
.Sp
Perl does not always generate infinite values when normal floating point
behaviour calls for it.  For example, the division \f(CW\*(C`1.0/0.0\*(C'\fR causes an
exception rather than returning an infinity.
.IP "not-a-number (NaN)" 4
.IX Item "not-a-number (NaN)"
This type of value exists in some floating point formats to indicate
error conditions.  Mathematically undefined operations may generate NaNs,
and NaNs propagate through all arithmetic operations.  A NaN has the
distinctive property of comparing numerically unequal to all floating
point values, including itself.
.Sp
Perl does not always generate NaNs when normal floating point behaviour
calls for it.  For example, the division \f(CW\*(C`0.0/0.0\*(C'\fR causes an exception
rather than returning a NaN.
.Sp
Perl has only (at most) one NaN value, even if the underlying system
supports different NaNs.  (\s-1IEEE\s0 754 arithmetic has NaNs which carry a
quiet/signal bit, a sign bit (yes, a sign on a not-number), and many
bits of implementation-defined data.)
.SS "Mixing floating point and integer values"
.IX Subsection "Mixing floating point and integer values"
Perl does not draw a strong type distinction between native integer
(see Data::Integer) and native floating point values.  Both types
of value can be stored in the numeric part of a plain (string) scalar.
No distinction is made between the integer representation and the floating
point representation where they encode identical values.  Thus, for
floating point arithmetic, native integer values that can be represented
exactly in floating point may be freely used as floating point values.
.PP
Native integer arithmetic has exactly one zero value, which has no sign.
If the floating point type does not have signed zeroes then the floating
point and integer zeroes are exactly equivalent.  If the floating point
type does have signed zeroes then the integer zero can still be used in
floating point arithmetic, and it behaves as an unsigned floating point
zero.  On such systems there are therefore three types of zero available.
There is a bug in Perl which sometimes causes floating point zeroes to
change into integer zeroes; see \*(L"\s-1BUGS\s0\*(R" for details.
.PP
Where a native integer value is used that is too large to exactly
represent in floating point, it will be rounded as necessary to a
floating point value.  This rounding will occur whenever an operation
has to be performed in floating point because the result could not be
exactly represented as an integer.  This may be confusing to functions
that expect a floating point argument.
.PP
Similarly, some operations on floating point numbers will actually be
performed in integer arithmetic, and may result in values that cannot
be exactly represented in floating point.  This happens whenever the
arguments have integer values that fit into the native integer type and
the mathematical result can be exactly represented as a native integer.
This may be confusing in cases where floating point semantics are
expected.
.PP
See \fIperlnumber\fR\|(1) for discussion of Perl's numeric semantics.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
.SS "Features"
.IX Subsection "Features"
.IP "have_signed_zero" 4
.IX Item "have_signed_zero"
Truth value indicating whether floating point zeroes carry a sign.  If yes,
then there are two floating point zero values: +0.0 and \-0.0.  (Perl
scalars can nevertheless also hold an integer zero, which is unsigned.)
If no, then there is only one zero value, which is unsigned.
.IP "have_subnormal" 4
.IX Item "have_subnormal"
Truth value indicating whether there are subnormal floating point values.
.IP "have_infinite" 4
.IX Item "have_infinite"
Truth value indicating whether there are infinite floating point values.
.IP "have_nan" 4
.IX Item "have_nan"
Truth value indicating whether there are NaN floating point values.
.Sp
It is difficult to reliably generate a NaN in Perl, so in some unlikely
circumstances it is possible that there might be NaNs that this module
failed to detect.  In that case this constant would be false but a NaN
might still turn up somewhere.  What this constant reliably indicates
is the availability of the \f(CW\*(C`nan\*(C'\fR constant below.
.SS "Extrema"
.IX Subsection "Extrema"
.IP "significand_bits" 4
.IX Item "significand_bits"
The number of fractional bits in the significand of finite floating
point values.  The significand also has an implicit integer bit, not
counted in this constant; the integer bit is always 1 for normalised
values and always 0 for subnormal values.
.IP "significand_step" 4
.IX Item "significand_step"
The difference between adjacent representable values in the range [1, 2]
(where the exponent is zero).  This is equal to 2^\-significand_bits.
.IP "max_finite_exp" 4
.IX Item "max_finite_exp"
The maximum exponent permitted for finite floating point values.
.IP "max_finite_pow2" 4
.IX Item "max_finite_pow2"
The maximum representable power of two.  This is 2^max_finite_exp.
.IP "max_finite" 4
.IX Item "max_finite"
The maximum representable finite value.  This is 2^(max_finite_exp+1)
\&\- 2^(max_finite_exp\-significand_bits).
.IP "max_number" 4
.IX Item "max_number"
The maximum representable number.  This is positive infinity if there
are infinite values, or max_finite if there are not.
.IP "max_integer" 4
.IX Item "max_integer"
The maximum integral value for which all integers from zero to that
value inclusive are representable.  Equivalently: the minimum positive
integral value N for which the value N+1 is not representable.  This is
2^(significand_bits+1).  The name is somewhat misleading.
.IP "min_normal_exp" 4
.IX Item "min_normal_exp"
The minimum exponent permitted for normalised floating point values.
.IP "min_normal" 4
.IX Item "min_normal"
The minimum positive value representable as a normalised floating
point value.  This is 2^min_normal_exp.
.IP "min_finite_exp" 4
.IX Item "min_finite_exp"
The base two logarithm of the minimum representable positive finite value.
If there are subnormals then this is min_normal_exp \- significand_bits.
If there are no subnormals then this is min_normal_exp.
.IP "min_finite" 4
.IX Item "min_finite"
The minimum representable positive finite value.  This is
2^min_finite_exp.
.SS "Special Values"
.IX Subsection "Special Values"
.IP "pos_zero" 4
.IX Item "pos_zero"
The positive zero value.  (Exists only if zeroes are signed, as indicated
by the \f(CW\*(C`have_signed_zero\*(C'\fR constant.)
.Sp
If Perl is at risk of transforming floating point zeroes into integer
zeroes (see \*(L"\s-1BUGS\s0\*(R"), then this is actually a non-constant function
that always returns a fresh floating point zero.  Thus the return value
is always a true floating point zero, regardless of what happened to
zeroes previously returned.
.IP "neg_zero" 4
.IX Item "neg_zero"
The negative zero value.  (Exists only if zeroes are signed, as indicated
by the \f(CW\*(C`have_signed_zero\*(C'\fR constant.)
.Sp
If Perl is at risk of transforming floating point zeroes into integer
zeroes (see \*(L"\s-1BUGS\s0\*(R"), then this is actually a non-constant function
that always returns a fresh floating point zero.  Thus the return value
is always a true floating point zero, regardless of what happened to
zeroes previously returned.
.IP "pos_infinity" 4
.IX Item "pos_infinity"
The positive infinite value.  (Exists only if there are infinite values,
as indicated by the \f(CW\*(C`have_infinite\*(C'\fR constant.)
.IP "neg_infinity" 4
.IX Item "neg_infinity"
The negative infinite value.  (Exists only if there are infinite values,
as indicated by the \f(CW\*(C`have_infinite\*(C'\fR constant.)
.IP "nan" 4
.IX Item "nan"
Not-a-number.  (Exists only if NaN values were detected, as indicated
by the \f(CW\*(C`have_nan\*(C'\fR constant.)
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
Each \*(L"float_\*(R" function takes a floating point argument to operate on.  The
argument must be a native floating point value, or a native integer with
a value that can be represented in floating point.  Giving a non-numeric
argument will cause mayhem.  See \*(L"is_number\*(R" in Params::Classify for a way
to check for numericness.  Only the numeric value of the scalar is used;
the string value is completely ignored, so dualvars are not a problem.
.SS "Classification"
.IX Subsection "Classification"
Each \*(L"float_is_\*(R" function returns a simple truth value result.
.IP "float_class(\s-1VALUE\s0)" 4
.IX Item "float_class(VALUE)"
Determines which of the five classes described above \s-1VALUE\s0 falls
into. Returns \*(L"\s-1NORMAL\s0\*(R", \*(L"\s-1SUBNORMAL\s0\*(R", \*(L"\s-1ZERO\s0\*(R", \*(L"\s-1INFINITE\s0\*(R", or \*(L"\s-1NAN\s0\*(R"
accordingly.
.IP "float_is_normal(\s-1VALUE\s0)" 4
.IX Item "float_is_normal(VALUE)"
Returns true iff \s-1VALUE\s0 is a normalised floating point value.
.IP "float_is_subnormal(\s-1VALUE\s0)" 4
.IX Item "float_is_subnormal(VALUE)"
Returns true iff \s-1VALUE\s0 is a subnormal floating point value.
.IP "float_is_nzfinite(\s-1VALUE\s0)" 4
.IX Item "float_is_nzfinite(VALUE)"
Returns true iff \s-1VALUE\s0 is a non-zero finite value (either normal or
subnormal; not zero, infinite, or NaN).
.IP "float_is_zero(\s-1VALUE\s0)" 4
.IX Item "float_is_zero(VALUE)"
Returns true iff \s-1VALUE\s0 is a zero.  If zeroes are signed then the sign
is irrelevant.
.IP "float_is_finite(\s-1VALUE\s0)" 4
.IX Item "float_is_finite(VALUE)"
Returns true iff \s-1VALUE\s0 is a finite value (either normal, subnormal,
or zero; not infinite or NaN).
.IP "float_is_infinite(\s-1VALUE\s0)" 4
.IX Item "float_is_infinite(VALUE)"
Returns true iff \s-1VALUE\s0 is an infinity (either positive infinity or
negative infinity).
.IP "float_is_nan(\s-1VALUE\s0)" 4
.IX Item "float_is_nan(VALUE)"
Returns true iff \s-1VALUE\s0 is a NaN.
.SS "Examination"
.IX Subsection "Examination"
.IP "float_sign(\s-1VALUE\s0)" 4
.IX Item "float_sign(VALUE)"
Returns "\fB+\fR\*(L" or \*(R"\fB\-\fR\*(L" to indicate the sign of \s-1VALUE\s0.  An unsigned
zero returns the sign \*(R"\fB+\fR".  \f(CW\*(C`die\*(C'\fRs if \s-1VALUE\s0 is a NaN.
.IP "signbit(\s-1VALUE\s0)" 4
.IX Item "signbit(VALUE)"
\&\s-1VALUE\s0 must be a floating point value.  Returns the sign bit of \s-1VALUE:\s0
0 if \s-1VALUE\s0 is positive or a positive or unsigned zero, or 1 if \s-1VALUE\s0 is
negative or a negative zero.  Returns an unpredictable value if \s-1VALUE\s0
is a NaN.
.Sp
This is an \s-1IEEE\s0 754 standard function.  According to the standard NaNs
have a well-behaved sign bit, but Perl can't see that bit.
.IP "float_parts(\s-1VALUE\s0)" 4
.IX Item "float_parts(VALUE)"
Divides up a non-zero finite floating point value into sign, exponent,
and significand, returning these as a three-element list in that order.
The significand is returned as a floating point value, in the range
[1, 2) for normalised values, and in the range (0, 1) for subnormals.
\&\f(CW\*(C`die\*(C'\fRs if \s-1VALUE\s0 is not finite and non-zero.
.SS "String conversion"
.IX Subsection "String conversion"
.IP "float_hex(VALUE[, \s-1OPTIONS\s0])" 4
.IX Item "float_hex(VALUE[, OPTIONS])"
Encodes the exact value of \s-1VALUE\s0 as a hexadecimal fraction, returning
the fraction as a string.  Specifically, for finite values the output is
of the form "\fIs\fR\fB0x\fR\fIm\fR\fB.\fR\fImmmmm\fR\fBp\fR\fIeee\fR\*(L", where \*(R"\fIs\fR\*(L" is the
sign, \*(R"\fIm\fR\fB.\fR\fImmmm\fR\*(L" is the significand in hexadecimal, and \*(R"\fIeee\fR"
is the exponent in decimal with a sign.
.Sp
The details of the output format are very configurable.  If \s-1OPTIONS\s0
is supplied, it must be a reference to a hash, in which these keys may
be present:
.RS 4
.IP "\fBexp_digits\fR" 4
.IX Item "exp_digits"
The number of digits of exponent to show, unless this is modified by
\&\fBexp_digits_range_mod\fR or more are required to show the exponent exactly.
(The exponent is always shown in full.)  Default 0, so the minimum
possible number of digits is used.
.IP "\fBexp_digits_range_mod\fR" 4
.IX Item "exp_digits_range_mod"
Modifies the number of exponent digits to show, based on the number of
digits required to show the full range of exponents for normalised and
subnormal values.  If "\fB\s-1IGNORE\s0\fR\*(L" then nothing is done.  If \*(R"\fB\s-1ATLEAST\s0\fR\*(L"
then at least this many digits are shown.  Default \*(R"\fB\s-1IGNORE\s0\fR".
.IP "\fBexp_neg_sign\fR" 4
.IX Item "exp_neg_sign"
The string that is prepended to a negative exponent.  Default "\fB\-\fR".
.IP "\fBexp_pos_sign\fR" 4
.IX Item "exp_pos_sign"
The string that is prepended to a non-negative exponent.  Default "\fB+\fR".
Make it the empty string to suppress the positive sign.
.IP "\fBfrac_digits\fR" 4
.IX Item "frac_digits"
The number of fractional digits to show, unless this is modified by
\&\fBfrac_digits_bits_mod\fR or \fBfrac_digits_value_mod\fR.  Default 0, but by
default this gets modified.
.IP "\fBfrac_digits_bits_mod\fR" 4
.IX Item "frac_digits_bits_mod"
Modifies the number of fractional digits to show, based on the length of
the significand.  There is a certain number of digits that is the minimum
required to explicitly state every bit that is stored, and the number
of digits to show might get set to that number depending on this option.
If "\fB\s-1IGNORE\s0\fR\*(L" then nothing is done.  If \*(R"\fB\s-1ATLEAST\s0\fR\*(L" then at least this
many digits are shown.  If \*(R"\fB\s-1ATMOST\s0\fR\*(L" then at most this many digits
are shown.  If \*(R"\fB\s-1EXACTLY\s0\fR\*(L" then exactly this many digits are shown.
Default \*(R"\fB\s-1ATLEAST\s0\fR".
.IP "\fBfrac_digits_value_mod\fR" 4
.IX Item "frac_digits_value_mod"
Modifies the number of fractional digits to show, based on the number
of digits required to show the actual value exactly.  Works the same
way as \fBfrac_digits_bits_mod\fR.  Default "\fB\s-1ATLEAST\s0\fR".
.IP "\fBhex_prefix_string\fR" 4
.IX Item "hex_prefix_string"
The string that is prefixed to hexadecimal digits.  Default "\fB0x\fR".
Make it the empty string to suppress the prefix.
.IP "\fBinfinite_string\fR" 4
.IX Item "infinite_string"
The string that is returned for an infinite magnitude.  Default "\fBinf\fR".
.IP "\fBnan_string\fR" 4
.IX Item "nan_string"
The string that is returned for a NaN value.  Default "\fBnan\fR".
.IP "\fBneg_sign\fR" 4
.IX Item "neg_sign"
The string that is prepended to a negative value (including negative
zero).  Default "\fB\-\fR".
.IP "\fBpos_sign\fR" 4
.IX Item "pos_sign"
The string that is prepended to a positive value (including positive or
unsigned zero).  Default "\fB+\fR".  Make it the empty string to suppress
the positive sign.
.IP "\fBsubnormal_strategy\fR" 4
.IX Item "subnormal_strategy"
The manner in which subnormal values are displayed.  If "\fB\s-1SUBNORMAL\s0\fR\*(L",
they are shown with the minimum exponent for normalised values and
a significand in the range (0, 1).  This matches how they are stored
internally.  If \*(R"\fB\s-1NORMAL\s0\fR\*(L", they are shown with a significand in the
range [1, 2) and a lower exponent, as if they were normalised.  This gives
a consistent appearance for magnitudes regardless of normalisation.
Default \*(R"\fB\s-1SUBNORMAL\s0\fR".
.IP "\fBzero_strategy\fR" 4
.IX Item "zero_strategy"
The manner in which zero values are displayed.  If "\fBSTRING=\fR\fIstr\fR",
the string \fIstr\fR is used, preceded by a sign.  If "\fB\s-1SUBNORMAL\s0\fR\*(L",
it is shown with significand zero and the minimum normalised exponent.
If \*(R"\fBEXPONENT=\fR\fIexp\fR", it is shown with significand zero and exponent
\&\fIexp\fR.  Default "\fBSTRING=0.0\fR".  An unsigned zero is treated as having
a positive sign.
.RE
.RS 4
.RE
.IP "hex_float(\s-1STRING\s0)" 4
.IX Item "hex_float(STRING)"
Generates and returns a floating point value from a string
encoding it in hexadecimal.  The standard input form is
"[\fIs\fR][\fB0x\fR]\fIm\fR[\fB.\fR\fImmmmm\fR][\fBp\fR\fIeee\fR]\*(L", where \*(R"\fIs\fR\*(L" is the sign,
\&\*(R"\fIm\fR[\fB.\fR\fImmmm\fR]\*(L" is a (fractional) hexadecimal number, and \*(R"\fIeee\fR"
an optionally-signed exponent in decimal.  If present, the exponent
identifies a power of two (not sixteen) by which the given fraction will
be multiplied.
.Sp
If the value given in the string cannot be exactly represented in the
floating point type because it has too many fraction bits, the nearest
representable value is returned, with ties broken in favour of the value
with a zero low-order bit.  If the value given is too large to exactly
represent then an infinity is returned, or the largest finite value if
there are no infinities.
.Sp
Additional input formats are accepted for special values.
"[\fIs\fR]\fBinf\fR[\fBinity\fR]" returns an infinity, or \f(CW\*(C`die\*(C'\fRs if there are
no infinities.  "[\fIs\fR][\fBs\fR]\fBnan\fR" returns a NaN, or \f(CW\*(C`die\*(C'\fRs if there
are no NaNs available.
.Sp
All input formats are understood case insensitively.  The function
correctly interprets all possible outputs from \f(CW\*(C`float_hex\*(C'\fR with default
settings.
.SS "Comparison"
.IX Subsection "Comparison"
.IP "float_id_cmp(A, B)" 4
.IX Item "float_id_cmp(A, B)"
This is a comparison function supplying a total ordering of floating
point values.  A and B must both be floating point values.  Returns \-1,
0, or +1, indicating whether A is to be sorted before, the same as,
or after B.
.Sp
The ordering is of the identities of floating point values, not their
numerical values.  If zeroes are signed, then the two types are considered
to be distinct.  NaNs compare equal to each other, but different from
all numeric values.  The exact ordering provided is mostly numerical
order: NaNs come first, followed by negative infinity, then negative
finite values, then negative zero, then positive (or unsigned) zero,
then positive finite values, then positive infinity.
.Sp
In addition to sorting, this function can be useful to check for a zero
of a particular sign.
.IP "totalorder(A, B)" 4
.IX Item "totalorder(A, B)"
This is a comparison function supplying a total ordering of floating point
values.  A and B must both be floating point values.  Returns a truth value
indicating whether A is to be sorted before-or-the-same-as B.  That is,
it is a <= predicate on the total ordering.  The ordering is the same as
that provided by \f(CW\*(C`float_id_cmp\*(C'\fR: NaNs come first, followed by negative
infinity, then negative finite values, then negative zero, then positive
(or unsigned) zero, then positive finite values, then positive infinity.
.Sp
This is an \s-1IEEE\s0 754r standard function.  According to the standard it
is meant to distinguish different kinds of NaNs, based on their sign
bit, quietness, and payload, but this function (like the rest of Perl)
perceives only one NaN.
.SS "Manipulation"
.IX Subsection "Manipulation"
.IP "pow2(\s-1EXP\s0)" 4
.IX Item "pow2(EXP)"
\&\s-1EXP\s0 must be an integer.  Returns the value two the the power \s-1EXP\s0.
\&\f(CW\*(C`die\*(C'\fRs if that value cannot be represented exactly as a floating
point value.  The return value may be either normalised or subnormal.
.IP "mult_pow2(\s-1VALUE\s0, \s-1EXP\s0)" 4
.IX Item "mult_pow2(VALUE, EXP)"
\&\s-1EXP\s0 must be an integer, and \s-1VALUE\s0 a floating point value.  Multiplies
\&\s-1VALUE\s0 by two to the power \s-1EXP\s0.  This gives exact results, except in
cases of underflow and overflow.  The range of \s-1EXP\s0 is not constrained.
All normal floating point multiplication behaviour applies.
.IP "copysign(\s-1VALUE\s0, \s-1SIGN_FROM\s0)" 4
.IX Item "copysign(VALUE, SIGN_FROM)"
\&\s-1VALUE\s0 and \s-1SIGN_FROM\s0 must both be floating point values.  Returns a
floating point value with the magnitude of \s-1VALUE\s0 and the sign of
\&\s-1SIGN_FROM\s0.  If \s-1SIGN_FROM\s0 is an unsigned zero then it is treated as
positive.  If \s-1VALUE\s0 is an unsigned zero then it is returned unchanged.
If \s-1VALUE\s0 is a NaN then it is returned unchanged.  If \s-1SIGN_FROM\s0 is a NaN
then the sign copied to \s-1VALUE\s0 is unpredictable.
.Sp
This is an \s-1IEEE\s0 754 standard function.  According to the standard NaNs
have a well-behaved sign bit, which can be read and modified by this
function, but Perl only perceives one NaN and can't see its sign bit,
so behaviour on NaNs is not standard-conforming.
.IP "nextup(\s-1VALUE\s0)" 4
.IX Item "nextup(VALUE)"
\&\s-1VALUE\s0 must be a floating point value.  Returns the next representable
floating point value adjacent to \s-1VALUE\s0 with a numerical value that is
strictly greater than \s-1VALUE\s0, or returns \s-1VALUE\s0 unchanged if there is
no such value.  Infinite values are regarded as being adjacent to the
largest representable finite values.  Zero counts as one value, even if
it is signed, and it is adjacent to the smallest representable positive
and negative finite values.  If a zero is returned, because \s-1VALUE\s0 is
the smallest representable negative value, and zeroes are signed, it is
a negative zero that is returned.  Returns NaN if \s-1VALUE\s0 is a NaN.
.Sp
This is an \s-1IEEE\s0 754r standard function.
.IP "nextdown(\s-1VALUE\s0)" 4
.IX Item "nextdown(VALUE)"
\&\s-1VALUE\s0 must be a floating point value.  Returns the next representable
floating point value adjacent to \s-1VALUE\s0 with a numerical value that
is strictly less than \s-1VALUE\s0, or returns \s-1VALUE\s0 unchanged if there is
no such value.  Infinite values are regarded as being adjacent to the
largest representable finite values.  Zero counts as one value, even if
it is signed, and it is adjacent to the smallest representable positive
and negative finite values.  If a zero is returned, because \s-1VALUE\s0 is
the smallest representable positive value, and zeroes are signed, it is
a positive zero that is returned.  Returns NaN if \s-1VALUE\s0 is a NaN.
.Sp
This is an \s-1IEEE\s0 754r standard function.
.IP "nextafter(\s-1VALUE\s0, \s-1DIRECTION\s0)" 4
.IX Item "nextafter(VALUE, DIRECTION)"
\&\s-1VALUE\s0 and \s-1DIRECTION\s0 must both be floating point values.  Returns the
next representable floating point value adjacent to \s-1VALUE\s0 in the
direction of \s-1DIRECTION\s0, or returns \s-1DIRECTION\s0 if it is numerically
equal to \s-1VALUE\s0.  Infinite values are regarded as being adjacent to
the largest representable finite values.  Zero counts as one value,
even if it is signed, and it is adjacent to the positive and negative
smallest representable finite values.  If a zero is returned and zeroes
are signed then it has the same sign as \s-1VALUE\s0.  Returns NaN if either
argument is a NaN.
.Sp
This is an \s-1IEEE\s0 754 standard function.
.SH "BUGS"
.IX Header "BUGS"
As of Perl 5.8.7 floating point zeroes will be partially transformed into
integer zeroes if used in almost any arithmetic, including numerical
comparisons.  Such a transformed zero appears as a floating point zero
(with its original sign) for some purposes, but behaves as an integer
zero for other purposes.  Where this happens to a positive zero the
result is indistinguishable from a true integer zero.  Where it happens
to a negative zero the result is a fourth type of zero, the existence of
which is a bug in Perl.  This fourth type of zero will give confusing
results, and in particular will elicit inconsistent behaviour from the
functions in this module.
.PP
Because of this transforming behaviour, it is best to avoid relying on
the sign of zeroes.  If you require signed-zero semantics then take
special care to maintain signedness.  Avoid using a zero directly
in arithmetic and handle it as a special case.  Any flavour of zero
can be accurately copied from one scalar to another without affecting
the original.  The functions in this module all avoid modifying their
arguments, and where they are meant to return signed zeroes they always
return a pristine one.
.PP
As of Perl 5.8.7 stringification of a floating point zero does not
preserve its signedness.  The number-to-string-to-number round trip
turns a positive floating point zero into an integer zero, but accurately
maintains negative and integer zeroes.  If a negative zero gets partially
transformed into an integer zero, as described above, the stringification
that it gets is based on its state at the first occasion on which the
scalar was stringified.
.PP
NaN handling is generally not well defined in Perl.  Arithmetic with
a mathematically undefined result may either \f(CW\*(C`die\*(C'\fR or generate a NaN.
Avoid relying on any particular behaviour for such operations, even if
your hardware's behaviour is known.
.PP
As of Perl 5.8.7 the \fB%\fR operator truncates its arguments to integers, if
the divisor is within the range of the native integer type.  It therefore
operates correctly on non-integer values only when the divisor is
very large.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Integer,
Scalar::Number,
\&\fIperlnumber\fR\|(1)
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2008, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
