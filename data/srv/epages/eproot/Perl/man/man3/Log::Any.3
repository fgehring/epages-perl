.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Any 3"
.TH Log::Any 3 "2011-03-23" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Any \-\- Bringing loggers and listeners together
.SH "VERSION"
.IX Header "VERSION"
version 0.12
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In a \s-1CPAN\s0 or other module:
.PP
.Vb 2
\&    package Foo;
\&    use Log::Any qw($log);
\&
\&    $log\->error("an error occurred");
\&    $log\->debugf("arguments are: %s", \e@_)
\&        if $log\->is_debug();
\&
\&    my $log2 = Log::Any\->get_logger(category => \*(AqMy::Class\*(Aq);
.Ve
.PP
In your application:
.PP
.Vb 1
\&    use Log::Any::Adapter;
\&    
\&    # Send all logs to Log::Log4perl
\&    Log::Any::Adapter\->set(\*(AqLog4perl\*(Aq);
\&
\&    # Send all logs to Log::Dispatch
\&    my $log = Log::Dispatch\->new(outputs => [[ ... ]]);
\&    Log::Any::Adapter\->set( \*(AqDispatch\*(Aq, dispatcher => $log );
\&
\&    # See Log::Any::Adapter documentation for more options
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Log::Any\*(C'\fR allows \s-1CPAN\s0 modules to safely and efficiently log messages, while
letting the application choose (or decline to choose) a logging mechanism such
as \f(CW\*(C`Log::Dispatch\*(C'\fR or \f(CW\*(C`Log::Log4perl\*(C'\fR.
.PP
\&\f(CW\*(C`Log::Any\*(C'\fR has a very tiny footprint and no dependencies beyond Perl 5.6,
which makes it appropriate for even small \s-1CPAN\s0 modules to use. It defaults to
\&'null' logging activity, so a module can safely log without worrying about
whether the application has chosen (or will ever choose) a logging mechanism.
.PP
The application, in turn, may choose one or more logging mechanisms via
Log::Any::Adapter.
.SH "LOG LEVELS"
.IX Header "LOG LEVELS"
\&\f(CW\*(C`Log::Any\*(C'\fR supports the following log levels and aliases, which is meant to be
inclusive of the major logging packages:
.PP
.Vb 9
\&     trace
\&     debug
\&     info (inform)
\&     notice
\&     warning (warn)
\&     error (err)
\&     critical (crit, fatal)
\&     alert
\&     emergency
.Ve
.PP
Levels are translated as appropriate to the underlying logging mechanism. For
example, log4perl only has six levels, so we translate 'notice' to 'info' and
the top three levels to 'fatal'.
.SH "CATEGORIES"
.IX Header "CATEGORIES"
Every logger has a category, generally the name of the class that asked for the
logger. Some logging mechanisms, like log4perl, can direct logs to different
places depending on category.
.SH "PRODUCING LOGS (FOR MODULES)"
.IX Header "PRODUCING LOGS (FOR MODULES)"
.SS "Getting a logger"
.IX Subsection "Getting a logger"
The most convenient way to get a logger in your module is:
.PP
.Vb 1
\&    use Log::Any qw($log);
.Ve
.PP
This creates a package variable \fI\f(CI$log\fI\fR and assigns it to the logger for the
current package. It is equivalent to
.PP
.Vb 1
\&    our $log = Log::Any\->get_logger(category => _\|_PACKAGE_\|_);
.Ve
.PP
In general, to get a logger for a specified category:
.PP
.Vb 1
\&    my $log = Log::Any\->get_logger(category => $category)
.Ve
.PP
If no category is specified, the caller package is used.
.SS "Logging"
.IX Subsection "Logging"
To log a message, use any of the log levels or aliases. e.g.
.PP
.Vb 3
\&    $log\->error("this is an error");
\&    $log\->warn("this is a warning");
\&    $log\->warning("this is also a warning");
.Ve
.PP
You should \fBnot\fR include a newline in your message; that is the responsibility
of the logging mechanism, which may or may not want the newline.
.PP
There are also printf-style versions of each of these methods:
.PP
.Vb 2
\&    $log\->errorf("an error occurred: %s", $@);
\&    $log\->debugf("called with %d params: %s", $param_count, \e@params);
.Ve
.PP
The printf-style methods have a few advantages, besides being arguably more
readable:
.IP "\(bu" 4
Any complex references (like \f(CW\*(C`\e@params\*(C'\fR above) are automatically converted to
single-line strings with \f(CW\*(C`Data::Dumper\*(C'\fR.
.IP "\(bu" 4
Any undefined values are automatically converted to the string \*(L"<undef>\*(R".
.IP "\(bu" 4
A logging mechanism could potentially use the unchanging format string (or a
digest thereof) to group related log messages together.
.SS "Log level detection"
.IX Subsection "Log level detection"
To detect whether a log level is on, use \*(L"is_\*(R" followed by any of the log
levels or aliases. e.g.
.PP
.Vb 3
\&    if ($log\->is_info()) { ... }
\&    $log\->debug("arguments are: " . Dumper(\e@_))
\&        if $log\->is_debug();
.Ve
.PP
This is important for efficiency, as you can avoid the work of putting together
the logging message (in the above case, stringifying \f(CW@_\fR) if the log level is
not active.
.PP
Some logging mechanisms don't support detection of log levels. In these cases
the detection methods will always return 1.
.PP
In contrast, the default logging mechanism \- Null \- will return 0 for all
detection methods.
.SS "Testing"
.IX Subsection "Testing"
Log::Any::Test provides a mechanism to test code that uses
\&\f(CW\*(C`Log::Any\*(C'\fR.
.SH "CONSUMING LOGS (FOR APPLICATIONS)"
.IX Header "CONSUMING LOGS (FOR APPLICATIONS)"
To direct logs somewhere \- a file, the screen, etc. \- you must use
Log::Any::Adapter. This is intentionally kept in a
separate distributions to keep \f(CW\*(C`Log::Any\*(C'\fR as simple and unchanging as
possible.
.SH "MOTIVATION"
.IX Header "MOTIVATION"
Many modules have something interesting to say. Unfortunately there is no
standard way for them to say it \- some output to \s-1STDERR\s0, others to \f(CW\*(C`warn\*(C'\fR,
others to custom file logs. And there is no standard way to get a module to
start talking \- sometimes you must call a uniquely named method, other times
set a package variable.
.PP
This being Perl, there are many logging mechanisms available on \s-1CPAN\s0.  Each has
their pros and cons. Unfortunately, the existence of so many mechanisms makes
it difficult for a \s-1CPAN\s0 author to commit his/her users to one of them. This may
be why many \s-1CPAN\s0 modules invent their own logging or choose not to log at all.
.PP
To untangle this situation, we must separate the two parts of a logging \s-1API\s0.
The first, \fIlog production\fR, includes methods to output logs (like
\&\f(CW\*(C`$log\->debug\*(C'\fR) and methods to inspect whether a log level is activated
(like \f(CW\*(C`$log\->is_debug\*(C'\fR). This is generally all that \s-1CPAN\s0 modules care
about. The second, \fIlog consumption\fR, includes a way to configure where
logging goes (a file, the screen, etc.) and the code to send it there. This
choice generally belongs to the application.
.PP
\&\f(CW\*(C`Log::Any\*(C'\fR provides a standard log production \s-1API\s0 for modules.
\&\f(CW\*(C`Log::Any::Adapter\*(C'\fR allows applications to choose the mechanism for log
consumption.
.PP
See http://www.openswartz.com/2007/09/06/standard\-logging\-api/ for the original
post proposing this module.
.SH "Q & A"
.IX Header "Q & A"
.IP "Isn't Log::Any just yet another logging mechanism?" 4
.IX Item "Isn't Log::Any just yet another logging mechanism?"
No. \f(CW\*(C`Log::Any\*(C'\fR does not, and never will, include code that knows how to log to
a particular place (file, screen, etc.) It can only forward logging requests to
another logging mechanism.
.IP "Why don't you just pick the best logging mechanism, and use and promote it?" 4
.IX Item "Why don't you just pick the best logging mechanism, and use and promote it?"
Each of the logging mechanisms have their pros and cons, particularly in terms
of how they are configured. For example, log4perl offers a great deal of power
and flexibility but uses a global and potentially heavy configuration, whereas
\&\f(CW\*(C`Log::Dispatch\*(C'\fR is extremely configuration-light but doesn't handle
categories. There is also the unnamed future logger that may have advantages
over either of these two, and all the custom in-house loggers people have
created and cannot (for whatever reason) stop using.
.IP "Is it safe for my critical module to depend on Log::Any?" 4
.IX Item "Is it safe for my critical module to depend on Log::Any?"
Our intent is to keep \f(CW\*(C`Log::Any\*(C'\fR minimal, and change it only when absolutely
necessary. Most of the \*(L"innovation\*(R", if any, is expected to occur in
\&\f(CW\*(C`Log::Any::Adapter\*(C'\fR, which your module should not have to depend on (unless it
wants to direct logs somewhere specific). \f(CW\*(C`Log::Any\*(C'\fR has no module
dependencies other than Test::Simple for testing.
.IP "Why doesn't Log::Any use \fIinsert modern Perl technique\fR?" 4
.IX Item "Why doesn't Log::Any use insert modern Perl technique?"
To encourage \s-1CPAN\s0 module authors to adopt and use \f(CW\*(C`Log::Any\*(C'\fR, we aim to have
as few dependencies and chances of breakage as possible. Thus, no \f(CW\*(C`Moose\*(C'\fR or
other niceties.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Any::Adapter, the many Log:: modules on \s-1CPAN\s0
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Jonathan Swartz.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
