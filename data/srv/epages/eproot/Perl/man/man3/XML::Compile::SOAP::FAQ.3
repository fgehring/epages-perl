.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::SOAP::FAQ 3"
.TH XML::Compile::SOAP::FAQ 3 "2017-01-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::SOAP::FAQ \- frequently asked questions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
On this page, a wild collection of questions are answered related to
the XML::Compile::SOAP modules.  Or better said: let's hope there will
be more in the future. If you have contributions either in question or
as answer, then please contribute via the xml mailinglist.
.PP
Also read XML::Compile::FAQ.
.SS "Modifing the messages"
.IX Subsection "Modifing the messages"
\fIadd \s-1XML\s0 header fields\fR
.IX Subsection "add XML header fields"
.PP
Although WSDLs offer a nice way to define header-fields explicitly, quite
a number of applications require fields which are not described. Also
some W3C standards play this game.  See XML::Compile::SOAP::WSA
for a complex example. A simple example follows here.
.PP
.Vb 2
\&  use warnings;
\&  use strict;
\&
\&  package XML::Compile::SOAP::MYEXT;
\&  use base \*(AqXML::Compile::SOAP::Extension\*(Aq;
\&
\&  use Log::Report;
\&  use XML::Compile::SOAP::Util      qw/WSDL11/;
\&  use XML::Compile::Util            qw/pack_type/;
\&
\&  my $my_ns = \*(Aqhttp://..../\*(Aq;
\&  my $my_schema_fie = \*(Aqaaa.xsd\*(Aq;
\&
\&  sub wsdl11Init($@)
\&  {   my ($self, $wsdl, $args) = @_;
\&      $wsdl\->addPrefixes(myprefix => $my_ns);
\&      $wsdl\->importDefinitions($my_schema_file);
\&      $self;
\&  }
\&
\&  sub soap11Operation$$)
\&  {   my ($self, $op, $args) = @_;
\&      # towards the server
\&      $op\->addHeader(INPUT
\&        => "myprefix_$fieldname" => "{$my_ns}$fieldtype");
\&
\&      # in server answers
\&      $op\->addHeader(OUTPUT => ...);
\&  }
.Ve
.PP
With \f(CW\*(C`soap11ClientWrapper()\*(C'\fR and \f(CW\*(C`soap11HandlerWrapper()\*(C'\fR
you can influence the client respectively server processing, for
instance to fill-in default values.
.PP
\fIadding \s-1HTTP\s0 headers\fR
.IX Subsection "adding HTTP headers"
.PP
Some applications require to add headers to the \s-1HTTP\s0 headers sent or
check headers which are received. \s-1SOAP\s0 is not about \s-1HTTP\s0, so you have
to dive deeper in the underlaying constructs; you have to construct the
code references in more steps, not using the auto-generation mechanisms
of some objects, by default hidden to you.
.PP
Examples of needs: authentication/cookies in the header, content
(crypt) checksums, non-standard content-type headers.
.PP
The ::WSDL11 module detects that the soap-http protocol is needed.
(There is also a pure http protocol defined in the \s-1SOAP\s0 spec, which
is never used).  When the operation gets compiled (with compileClient),
the ::SOAPHTTP module is used to create the soap-http specific message
transport logic. Then, that module uses \s-1LWP\s0 to do the actual \s-1HTTP\s0
exchange. To be able to access the in\- and outgoing messages, you have
to reach to that LWP::UserAgent.
.PP
Michael Ludwig contributed the following example (slightly adapted)
Of course, select your own preferences carefully.
.PP
.Vb 1
\&  my $ua = LWP::UserAgent\->new(timeout => 10);
\&
\&  # First the HTTP logic
\&  # defaults when https is used
\&  $ua\->ssl_opts(verify_hostname => 0, keep_alive => 1);
\&
\&  # Auto\-use cookies
\&  $ua\->cookie_jar( {file => $my_jar_file
\&    , autosave => 1, ignore_discard => 1 });
\&
\&  # Now, we need the SOAP logic
\&  my $trans = XML::Compile::Transport::SOAPHTTP
\&    \->new(user_agent => $ua, address => $srv_url);
\&
\&  # Finally the message, with explicit transporter
\&  my $call = $wsdl\->compileClient($opname, transport => $trans);
\&
\&  # Or more operations at the same time
\&  # $wsdl\->compileCalls(transport => $trans);
\&
\&  # $answer is the decoded XML content.
\&  my($answer, $trace) = $call\->( \e%parms );
\&
\&  # If you need headers from the response HTTP headers.
\&  my $http_response = $trace\->response;
\&  print $http_response\->header(\*(AqX\-Secret\*(Aq);
.Ve
.PP
You may know the \f(CW$srv_url\fR to get the address of the server, but
you can also ask the operation itself. Here a different implementation:
.PP
.Vb 4
\&  my $op    = $wsdl\->operation($opname);
\&  my $srv   = ($op\->addresses)[0];
\&  my $trans = XML::Compile::Transport::SOAPHTTP\->new(address => $srv
\&    , timeout => 15, ssl_opts => { verify_hostname => 0 });
\&
\&  # Now configure the userAgent
\&  my $ua    = $trans\->userAgent;
\&  ...
\&
\&  my $call  = $op\->compileClient(transport => $trans);
\&  ...
.Ve
.PP
The LWP::UserAgent has many useful hooks (<i>Handlers</i>), for
instance \f(CW\*(C`request_send\*(C'\fR and \f(CW\*(C`response_done\*(C'\fR.
.PP
Even shorter, The next works as well. In the whole XML::Compile::SOAP
suite, parameters passed on higher levels are passed to all lower
levels. Yeh, unclean programming but useful.
.PP
.Vb 3
\&  my $ua    = $trans\->userAgent;
\&  my $call  = $wsdl\->compileClient(transport => $trans
\&    , user_agent => $ua);
.Ve
.PP
When you only need to add simple authentication to the headers, you
may use the magic of \s-1LWP:\s0 provide your server address into
.PP
.Vb 1
\&  http://user:password@example.com/service
.Ve
.PP
\fIadd Basic Auth \s-1HTTP\s0 header\fR
.IX Subsection "add Basic Auth HTTP header"
.PP
An simple example for the previous section, is the often needed basic
authentication.  You need something like this:
.PP
.Vb 3
\&   my $ua = LWP::UserAgent\->new(timeout => 10);
\&   my $call = $wsdl\->compileClient($operation, user_agent => $ua
\&    , transport_hook => \e&basic_auth);
\&
\&   sub basic_auth($$)
\&   {   my ($request, $trace) = @_;
\&       $request\->authorization_basic($user, $password);
\&       $ua\->request($request);     # returns $response
\&   }
.Ve
.PP
That's all.  When you use XML::Compile::Cache to maintain the
calls (advised), it would look like this:
.PP
.Vb 1
\&   $wsdl\->compileCalls(user_agent => $ua, transport_hook => \e&basic_auth);
.Ve
.SS "Collection \s-1XSD\s0 imports"
.IX Subsection "Collection XSD imports"
From a maintenance point of view, it is a very bad idea that some \s-1XML\s0
client implementations load all the required schemas on the moment they
start off. The server may change the schemas at any moment, which may
break the application at any moment. Also, network problems will cause
the application to break easily. Therefore, XML::Compile requires the
schemas to be on local disk (although you can use tricks with wget at
start-up time to voluntarily give-up your stability)
.PP
To collect the imported schema files, you may use this (on the
UNIX/Linux prompt)
.PP
.Vb 3
\&  wget \-c \-nv $(cat * |
\&                sed \-n \*(Aqs/.*schemaLocation="\e([^"]*\e)".*/\e1/p\*(Aq |
\&                sort \-u)
.Ve
.PP
In your program, you typically start with
.PP
.Vb 2
\&  my $wsdl = XML::Compile::WSDL11\->new($wsdl_filename);
\&  $wsdl\->importDefinitions([glob "*.xsd"]);
.Ve
.SS "Using \s-1SSL\s0"
.IX Subsection "Using SSL"
Abeltje contributed an \s-1SSL\s0 usage example, which then got adapted to this:
.PP
.Vb 1
\&   use LWP::UserAgent;
\&
\&   my $wsdl = XML::Compile::WSDL11\->new($wsdlfn);
\&
\&   # LWP 6.00 introduces ssl_opts
\&   @ENV{keys %lwp5_ssl} = values %lwp5_ssl
\&       if LWP::UserAgent\->VERSION < 6;
\&   my $ua = LWP::UserAgent\->new(ssl_opts => \e%lwp6_ssl);
\&
\&   $wsdl\->compileCalls(user_agent => $ua);
.Ve
.PP
Do not forget to explicitly install \f(CW\*(C`LWP::Protocol::https\*(C'\fR !!!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile-SOAP distribution version 3.21,
built on January 11, 2017. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2017 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
