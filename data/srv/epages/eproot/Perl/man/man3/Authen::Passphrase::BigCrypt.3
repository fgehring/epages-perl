.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::Passphrase::BigCrypt 3"
.TH Authen::Passphrase::BigCrypt 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::Passphrase::BigCrypt \- passphrases using bigcrypt algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Authen::Passphrase::BigCrypt;
\&
\&        $ppr = Authen::Passphrase::BigCrypt\->new(
\&                salt_base64 => "qi",
\&                hash_base64 => "yh4XPJGsOZ2MEAyLkfWqeQ");
\&
\&        $ppr = Authen::Passphrase::BigCrypt\->new(
\&                salt_random => 12,
\&                passphrase => "passphrase");
\&
\&        $salt = $ppr\->salt;
\&        $salt_base64 = $ppr\->salt_base64_2;
\&        $hash = $ppr\->hash;
\&        $hash_base64 = $ppr\->hash_base64;
\&
\&        $pprs = $ppr\->sections;
\&
\&        if($ppr\->match($passphrase)) { ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class encapsulates a passphrase hashed using the
\&\*(L"bigcrypt\*(R" hash function found in HP-UX, Digital Unix, \s-1OSF/1\s0, and some
other flavours of Unix.  Do not confuse this with the \*(L"crypt16\*(R" found
on Ultrix and Tru64 (for which see Authen::Passphrase::Crypt16).
This is a subclass of Authen::Passphrase, and this document assumes
that the reader is familiar with the documentation for that class.
.PP
This is a derivation of the original DES-based crypt function found on all
Unices (see Authen::Passphrase::DESCrypt).  The first eight bytes of
the passphrase are used as a \s-1DES\s0 key to encrypt the all-bits-zero block
through 25 rounds of (12\-bit) salted \s-1DES\s0, just like the original crypt.
Then, if the passphrase is longer than eight bytes, the next eight bytes
are used as a \s-1DES\s0 key to encrypt the all-bits-zero block through 25
rounds of salted \s-1DES\s0, using as salt the first 12 bits of the hash of the
first section.  Then, if the passphrase is longer than sixteen bytes,
the next eight bytes are used, with salt consisting of the first 12
bits of the hash of the second section.  This repeats until the entire
passphrase has been used.  The hashes of all the sections are concatenated
to form the final hash.
.PP
A password hash of this scheme is conventionally represented in \s-1ASCII\s0
using the base 64 encoding of the underlying DES-based crypt function.
The first two characters give the salt for the first section, the next
eleven give the hash of the first section, the next eleven give the hash
of the second section, and so on.  A hash thus encoded is used as a crypt
string, on those systems where the bigcrypt algorithm is part of \fIcrypt()\fR,
but the syntax clashes with that of crypt16.  This module does not treat
it as a crypt string syntax.
.PP
Because the sections of the passphrase are hashed separately, it is
possible to manipulate (e.g., crack) a section hash in isolation.
See Authen::Passphrase::DESCrypt for handling of a single section.
.PP
\&\fIWarning:\fR This is a fatally flawed design, often providing \fIless\fR
security than the plain \s-1DES\s0 scheme alone.  Do not use seriously.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Authen::Passphrase::BigCrypt\->new(\s-1ATTR\s0 => \s-1VALUE\s0, ...)" 4
.IX Item "Authen::Passphrase::BigCrypt->new(ATTR => VALUE, ...)"
Generates a new passphrase recogniser object using the bigcrypt hash
algorithm.  The following attributes may be given:
.RS 4
.IP "\fBsalt\fR" 4
.IX Item "salt"
The salt for the first section, as an integer in the range [0, 4096).
.IP "\fBsalt_base64\fR" 4
.IX Item "salt_base64"
The salt for the first section, as a string of two base 64 digits.
.IP "\fBsalt_random\fR" 4
.IX Item "salt_random"
Causes salt for the first section to be generated randomly.  The value
given for this attribute must be 12, indicating generation of 12 bits
of salt.  The source of randomness may be controlled by the facility
described in Data::Entropy.
.IP "\fBhash\fR" 4
.IX Item "hash"
The hash, as a string of bytes.
.IP "\fBhash_base64\fR" 4
.IX Item "hash_base64"
The hash, as a string of base 64 digits.
.IP "\fBpassphrase\fR" 4
.IX Item "passphrase"
A passphrase that will be accepted.
.RE
.RS 4
.Sp
The salt for the first section must be given, and either the hash or
the passphrase.
.RE
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ppr\->salt" 4
.el .IP "\f(CW$ppr\fR\->salt" 4
.IX Item "$ppr->salt"
Returns the salt for the first section, as a Perl integer.
.ie n .IP "$ppr\->salt_base64_2" 4
.el .IP "\f(CW$ppr\fR\->salt_base64_2" 4
.IX Item "$ppr->salt_base64_2"
Returns the salt for the first section, as a string of two base 64 digits.
.ie n .IP "$ppr\->hash" 4
.el .IP "\f(CW$ppr\fR\->hash" 4
.IX Item "$ppr->hash"
Returns the hash value, as a string of bytes.
.ie n .IP "$ppr\->hash_base64" 4
.el .IP "\f(CW$ppr\fR\->hash_base64" 4
.IX Item "$ppr->hash_base64"
Returns the hash value, as a string of base 64 digits.  This is the
concatenation of the base 64 encodings of the section hashes, rather
than a base64 encoding of the combined hash.
.ie n .IP "$ppr\->sections" 4
.el .IP "\f(CW$ppr\fR\->sections" 4
.IX Item "$ppr->sections"
Returns a reference to an array of Authen::Passphrase::DESCrypt
passphrase recognisers for the sections of the passphrase.
.ie n .IP "$ppr\->match(\s-1PASSPHRASE\s0)" 4
.el .IP "\f(CW$ppr\fR\->match(\s-1PASSPHRASE\s0)" 4
.IX Item "$ppr->match(PASSPHRASE)"
This method is part of the standard Authen::Passphrase interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::Passphrase,
Authen::Passphrase::DESCrypt
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
