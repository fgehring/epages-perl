.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile 3"
.TH XML::Compile 3 "2016-09-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile \- Compilation based XML processing
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& XML::Compile is extended by
\&   XML::Compile::Schema
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # See XML::Compile::Schema / ::WSDL / ::SOAP11 etc
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Many (professional) applications process \s-1XML\s0 messages based on a formal
specification, expressed in \s-1XML\s0 Schemas.  XML::Compile translates
between \s-1XML\s0 and Perl with the help of such schemas.  Your Perl program
only handles a tree of nested HASHes and ARRAYs, and does not need to
understand namespaces and other general \s-1XML\s0 and schema nastiness.
.PP
Three serious \s-1WARNINGS:\s0
.IP "\(bu" 4
The focus is on \fBdata-centric \s-1XML\s0\fR, which means that mixed elements
are not handler automatically: you need to work with XML::LibXML nodes
yourself, on these spots.
.IP "\(bu" 4
The \fBdata is not strictly validated\fR, still a large number of
compile-time errors can be reported.  Values are checked quite thoroughly.
Structure as well.
.IP "\(bu" 4
Imports and includes, as used in the schemas, are \s-1NOT\s0 performed
automatically.  Schema's and such are \s-1NOT\s0 collected from internet
dynamically; you have to call \fIXML::Compile::Schema::importDefinitions()\fR
explicitly with filenames of locally stored copies. Includes do only
work if they have a targetNamespace defined, which is the same as that
of the schema it is included into.
.SH "METHODS"
.IX Header "METHODS"
Methods found in this manual page are shared by the end-user modules,
and should not be used directly: objects of type \f(CW\*(C`XML::Compile\*(C'\fR do not
exist!
.SS "Constructors"
.IX Subsection "Constructors"
These constructors are base class methods to be extended,
and therefore should not be accessed directly.
.ie n .IP "XML::Compile\->\fBnew\fR( [$xmldata], %options )" 4
.el .IP "XML::Compile\->\fBnew\fR( [$xmldata], \f(CW%options\fR )" 4
.IX Item "XML::Compile->new( [$xmldata], %options )"
The \f(CW$xmldata\fR is a source of \s-1XML\s0. See \fIdataToXML()\fR for valid ways,
for example as filename, string or \f(CW\*(C`undef\*(C'\fR.
.Sp
If you have compiled all readers and writers you need, you may simply
terminate the compiler object: that will clean-up (most of) the
XML::LibXML objects.
.Sp
.Vb 3
\& \-Option        \-\-Default
\&  parser_options  <many>
\&  schema_dirs     undef
.Ve
.RS 4
.IP "parser_options => HASH|ARRAY" 2
.IX Item "parser_options => HASH|ARRAY"
See XML::LibXML::Parser for a list of available options which can be
used to create an \s-1XML\s0 parser (the new method). The default will set you
in a secure mode.  See \fIinitParser()\fR.
.IP "schema_dirs => DIRECTORY|ARRAY\-OF\-DIRECTORIES" 2
.IX Item "schema_dirs => DIRECTORY|ARRAY-OF-DIRECTORIES"
Where to find schema's.  This can be specified with the
environment variable \f(CW\*(C`SCHEMA_DIRECTORIES\*(C'\fR or with this option.
See \fIaddSchemaDirs()\fR for a detailed explanation.
.RE
.RS 4
.RE
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBaddSchemaDirs\fR(@directories|$filename)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSchemaDirs\fR(@directories|$filename)" 4
.IX Item "$obj->addSchemaDirs(@directories|$filename)"
.PD 0
.IP "XML::Compile\->\fBaddSchemaDirs\fR(@directories|$filename)" 4
.IX Item "XML::Compile->addSchemaDirs(@directories|$filename)"
.PD
Each time this method is called, the specified \f(CW@directories\fR will be added
in front of the list of already known schema directories.  Initially,
the value of the environment variable \f(CW\*(C`SCHEMA_DIRECTORIES\*(C'\fR is added
(therefore tried as last resort). The constructor option \f(CW\*(C`schema_dirs\*(C'\fR
is a little more favorite.
.Sp
Values which are \f(CW\*(C`undef\*(C'\fR are skipped.  ARRAYs are flattened.  Arguments
are split at colons (on \s-1UNIX\s0) or semi-colons (windows) after flattening.
The list of directories is returned, in all but \s-1VOID\s0 context.
.Sp
When a \f(CW\*(C`.pm\*(C'\fR package \f(CW$filename\fR is given, then the directory
to be used is calculated from it (platform independently).  So,
\&\f(CW\*(C`something/XML/Compile.pm\*(C'\fR becomes \f(CW\*(C`something/XML/Compile/xsd/\*(C'\fR.
This way, modules can simply add their definitions via \f(CW\*(C`XML::Compile\->addSchemaDirs(_\|_FILE_\|_)\*(C'\fR in a \s-1BEGIN\s0 block or in main.
ExtUtils::MakeMaker will install everything what is found in the
\&\f(CW\*(C`lib/\*(C'\fR tree, so also your xsd files.  Probably, you also want to use
\&\fIknownNamespace()\fR.
.Sp
example: adding xsd's from your own distribution
.Sp
.Vb 2
\&  # file xxxxx/lib/My/Package.pm
\&  package My::Package;
\&
\&  use XML::Compile;
\&  XML::Compile\->addSchemaDirs(_\|_FILE_\|_);
\&  # now xxxxx/lib/My/Package/xsd/ is also in the search path
\&
\&  use constant MYNS => \*(Aqhttp://my\-namespace\-uri\*(Aq;
\&  XML::Compile\->knownNamespace(&MYNS => \*(Aqmy\-schema\-file.xsd\*(Aq);
\&  $schemas\->importDefinitions(MYNS);
.Ve
.SS "Compilers"
.IX Subsection "Compilers"
.ie n .IP "$obj\->\fBdataToXML\fR($node|REF\-XML|XML\-STRING|$filename|$fh|$known)" 4
.el .IP "\f(CW$obj\fR\->\fBdataToXML\fR($node|REF\-XML|XML\-STRING|$filename|$fh|$known)" 4
.IX Item "$obj->dataToXML($node|REF-XML|XML-STRING|$filename|$fh|$known)"
.PD 0
.IP "XML::Compile\->\fBdataToXML\fR($node|REF\-XML|XML\-STRING|$filename|$fh|$known)" 4
.IX Item "XML::Compile->dataToXML($node|REF-XML|XML-STRING|$filename|$fh|$known)"
.PD
Collect \f(CW$xml\fR data, from a wide variety of sources.  In \s-1SCALAR\s0 context,
an XML::LibXML::Element or XML::LibXML::Document is returned.
In \s-1LIST\s0 context, pairs of additional information follow the scalar result.
.Sp
When a ready XML::LibXML::Node (::Element or ::Document) \f(CW$node\fR is
provided, it is returned immediately and unchanged.  A \s-1SCALAR\s0 reference is
interpreted as reference to \f(CW$xml\fR as plain text ($xml texts can be large,
and you can improve performance by passing it around by reference
instead of copy).  Any value which starts with blanks followed by a
\&'<' is interpreted as \f(CW$xml\fR text.
.Sp
You may also specify a pre-defined \fIknown\fR name-space \s-1URI\s0.  A set of
definition files is included in the distribution, and installed somewhere
when this all gets installed.  Either define an environment variable
named \s-1SCHEMA_LOCATION\s0 or use new(schema_dirs) (option available to
all end-user objects) to inform the library where to find these files.
.Sp
According the XML::LibXML::Parser manual page, passing a \f(CW$fh\fR
is much slower than pasing a \f(CW$filename\fR.  However, it may be needed to
open a file with an explicit character-set.
.Sp
example:
.Sp
.Vb 2
\&  my $xml = $schema\->dataToXML(\*(Aq/etc/config.xml\*(Aq);
\&  my ($xml, %details) = $schema\->dataToXML($something);
\&
\&  my $xml = XML::Compile\->dataToXML(\*(Aq/etc/config.xml\*(Aq);
.Ve
.ie n .IP "$obj\->\fBinitParser\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBinitParser\fR(%options)" 4
.IX Item "$obj->initParser(%options)"
.PD 0
.IP "XML::Compile\->\fBinitParser\fR(%options)" 4
.IX Item "XML::Compile->initParser(%options)"
.PD
Create a new parser, an XML::LibXML::Parser object. By default, the
parsing is set in a safe mode, avoiding exploits. You may explicitly
overrule it, especially if you need to process entities.
.SS "Administration"
.IX Subsection "Administration"
.ie n .IP "$obj\->\fBfindSchemaFile\fR($filename)" 4
.el .IP "\f(CW$obj\fR\->\fBfindSchemaFile\fR($filename)" 4
.IX Item "$obj->findSchemaFile($filename)"
.PD 0
.IP "XML::Compile\->\fBfindSchemaFile\fR($filename)" 4
.IX Item "XML::Compile->findSchemaFile($filename)"
.PD
Runs through all defined schema directories (see \fIaddSchemaDirs()\fR)
in search of the specified \f(CW$filename\fR.  When the \f(CW$filename\fR is absolute,
that will be used, and no search is needed.  An \f(CW\*(C`undef\*(C'\fR is returned when
the file is not found, otherwise a full path to the file is returned to
the caller.
.Sp
Although the file may be found, it still could be unreadible.
.ie n .IP "$obj\->\fBknownNamespace\fR($ns|PAIRS)" 4
.el .IP "\f(CW$obj\fR\->\fBknownNamespace\fR($ns|PAIRS)" 4
.IX Item "$obj->knownNamespace($ns|PAIRS)"
.PD 0
.IP "XML::Compile\->\fBknownNamespace\fR($ns|PAIRS)" 4
.IX Item "XML::Compile->knownNamespace($ns|PAIRS)"
.PD
If used with only one \f(CW$ns\fR, it returns the filename in the
distribution (not the full path) which contains the definition.
.Sp
When \s-1PAIRS\s0 of \f(CW$ns\fR\-FILENAME are given, then those get defined.
This is typically called during the initiation of modules, like
XML::Compile::WSDL11 and XML::Compile::SOAP.  The definitions
are global: not related to specific instances.
.Sp
The \s-1FILENAMES\s0 are relative to the directories as specified with some
\&\fIaddSchemaDirs()\fR call.
.ie n .IP "$obj\->\fBwalkTree\fR($node, \s-1CODE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwalkTree\fR($node, \s-1CODE\s0)" 4
.IX Item "$obj->walkTree($node, CODE)"
Walks the whole tree from \f(CW$node\fR downwards, calling the \s-1CODE\s0 reference
for each \f(CW$node\fR found.  When that routine returns false, the child
nodes will be skipped.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Distribution collection overview"
.IX Subsection "Distribution collection overview"
For end-users, the following packages are of interest (the other
are support packages):
.IP "\(bu" 4
XML::Compile::Schema
.Sp
Interpret schema elements and types: create processors for \s-1XML\s0 messages.
.IP "\(bu" 4
XML::Compile::Cache
.Sp
Helps you administer compiled readers and writers, especially useful it
there are a lot of them.  Extends XML::Compile::Schema.
.IP "\(bu" 4
XML::Compile::SOAP
.Sp
Implements the \s-1SOAP\s0 1.1 protocol. client side.
.IP "\(bu" 4
XML::Compile::SOAP12
.Sp
Implements the \s-1SOAP\s0 1.2 protocol.
.IP "\(bu" 4
XML::Compile::WSDL11
.Sp
Use \s-1SOAP\s0 with a \s-1WSDL\s0 version 1.1 communication specification file.
.IP "\(bu" 4
XML::Compile::SOAP::Daemon
.Sp
Create a \s-1SOAP\s0 daemon, directly from a \s-1WSDL\s0 file.
.IP "\(bu" 4
XML::Compile::Tester
.Sp
Helps you write regression tests.
.IP "\(bu" 4
XML::Rewrite
.Sp
Clean-up \s-1XML\s0 structures: beautify, simplify, extract.
.IP "\(bu" 4
XML::Compile::Dumper
.Sp
Enables you to save pre-compiled \s-1XML\s0 handlers, the results of any
\&\f(CW\*(C`compileClient\*(C'\fR.  However, this results in huge files, so this may
not be worth the effort.
.SS "Comparison"
.IX Subsection "Comparison"
Where other Perl modules (like \s-1SOAP::WSDL\s0) help you using these schemas
(often with a lot of run-time XPath searches), XML::Compile takes a
different approach: instead of run-time processing of the specification,
it will first compile the expected structure into a pure Perl \s-1CODE\s0
reference, and then use that to process the data as often as needed.
.PP
There are many Perl modules with the same intention as this one:
translate between \s-1XML\s0 and nested hashes.  However, there are a few
serious differences:  because the schema is used here (and not by the
other modules), we can validate the data.  \s-1XML\s0 requires validation but
quite a number of modules simply ignore that.
.PP
Next to this, data-types are formatted and processed correctly; for
instance, the specification prescribes that the \f(CW\*(C`Integer\*(C'\fR data-type
must accept values of at least 18 digits... not fitting in Perl's idea
of longs.
.PP
XML::Compile also supports all more complex data-types like \f(CW\*(C`list\*(C'\fR,
\&\f(CW\*(C`union\*(C'\fR, \f(CW\*(C`substitutionGroup\*(C'\fR (unions on complex type level), and even
the nasty \f(CW\*(C`any\*(C'\fR and \f(CW\*(C`anyAttribute\*(C'\fR, which is rarely the case for the
other modules.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile distribution version 1.54,
built on September 19, 2016. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2006\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
