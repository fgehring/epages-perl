.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::Translate 3"
.TH XML::Compile::Translate 3 "2016-09-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::Translate \- create an XML data parser
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& XML::Compile::Translate is extended by
\&   XML::Compile::Translate::Reader
\&   XML::Compile::Translate::Template
\&   XML::Compile::Translate::Writer
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # for internal use only
\& my $code = XML::Compile::Translate\->compile(...);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module converts a schema type definition into a code
reference which can be used to interpret a schema.  The sole public
function in this package is \fIcompile()\fR, and is called by
\&\fIXML::Compile::Schema::compile()\fR, which does a lot of set-ups.
Please do not try to use this package directly!
.PP
The code in this package interprets schemas; it understands, for
instance, how complexType definitions work.  Then, when the
schema syntax is decoded, it will knot the pieces together into
one \s-1CODE\s0 reference which can be used in the main user program.
.SS "Unsupported features"
.IX Subsection "Unsupported features"
This implementation is work in progress, but by far most structures in
W3C schemas are implemented (and tested!).
.PP
Missing are
 schema noNamespaceSchemaLocation
 any ##local
 anyAttribute ##local
.PP
Some things do not work in schemas anyway: \f(CW\*(C`import\*(C'\fR, \f(CW\*(C`include\*(C'\fR.  They
only work if everyone always has a working connection to internet.  You
have to require them manually.  Include also does work, because it does not
use namespaces.  (see \fIXML::Compile::Schema::importDefinitions()\fR)
.PP
Ignored, because not for our purpose is the search optimization
information: \f(CW\*(C`key, unique, keyref, selector, field\*(C'\fR, and de schema
documentation: \f(CW\*(C`notation, annotation\*(C'\fR.  Compile the schema schema itself
to interpret the message if you need them.
.PP
A few nuts are still to crack:
 openContent
 facets on dates and base64Binary
 final is not protected
.PP
Of course, the latter list is all fixed in next release ;\-)
See chapter \*(L"\s-1DETAILS\s0\*(R" for more on how the tune the translator.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBnew\fR($translator, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR($translator, \f(CW%options\fR)" 4
.IX Item "$obj->new($translator, %options)"
The \f(CW%options\fR are described in \fIXML::Compile::Schema::compile()\fR.  Those
descriptions will probably move here, eventually.
.Sp
.Vb 2
\& \-Option\-\-Default
\&  nss     <required>
.Ve
.RS 4
.IP "nss => XML::Compile::Schema::NameSpaces" 2
.IX Item "nss => XML::Compile::Schema::NameSpaces"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBregister\fR($name)" 4
.el .IP "\f(CW$obj\fR\->\fBregister\fR($name)" 4
.IX Item "$obj->register($name)"
.IP "XML::Compile::Translate\->\fBregister\fR($name)" 4
.IX Item "XML::Compile::Translate->register($name)"
.PD
Register a new back-end.
.Sp
example:
.Sp
.Vb 3
\& use XML::Compile::Translate::SomeBackend;
\& XML::Compile::Translate::SomeBackend\->register(\*(AqSomeNAME\*(Aq);
\& my $coderef = $schemas\->compile(\*(AqSomeNAME\*(Aq => ...);
.Ve
.SS "Attributes"
.IX Subsection "Attributes"
.SS "Handlers"
.IX Subsection "Handlers"
.ie n .IP "XML::Compile::Translate\->\fBcompile\fR($element|$attribute|$type, %options)" 4
.el .IP "XML::Compile::Translate\->\fBcompile\fR($element|$attribute|$type, \f(CW%options\fR)" 4
.IX Item "XML::Compile::Translate->compile($element|$attribute|$type, %options)"
Do not call this function yourself, but use
\&\fIXML::Compile::Schema::compile()\fR (or wrappers around that).
.Sp
This function returns a \s-1CODE\s0 reference, which can translate
between Perl datastructures and \s-1XML\s0, based on a schema.  Before
this method is called is the schema already translated into
a table of types.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Translator options"
.IX Subsection "Translator options"
\fIperformance optimization\fR
.IX Subsection "performance optimization"
.PP
The \fIXML::Compile::Schema::compile()\fR method (and wrappers) defines
a set options to improve performance or usability.  These options
are translated into the executed code: compile time, not run-time!
.PP
The following options with their implications:
.IP "sloppy_integers \s-1BOOLEAN\s0" 4
.IX Item "sloppy_integers BOOLEAN"
The \f(CW\*(C`integer\*(C'\fR type, as defined by the schema built-in specification,
accepts really huge values.  Also the derived types, like
\&\f(CW\*(C`nonNegativeInteger\*(C'\fR can contain much larger values than Perl's
internal \f(CW\*(C`long\*(C'\fR.  Therefore, the module will start to use Math::BigInt
for these types if needed.
.Sp
However, in most cases, people design \f(CW\*(C`integer\*(C'\fR where an \f(CW\*(C`int\*(C'\fR suffices.
The use of big-int values comes with heigh performance costs.  Set this
option to \f(CW\*(C`true\*(C'\fR when you are sure that \s-1ALL\s0 \s-1USES\s0 of \f(CW\*(C`integer\*(C'\fR in the
scheme will fit into signed longs (are between \-2147483648 and 2147483647
inclusive)
.Sp
If you do not want limit the number-space, you can safely add
  use Math::BigInt try => '\s-1GMP\s0'
to the top of your main program, and install Math::BigInt::GMP.  Then,
a C library will do the work, much faster than the Perl implementation.
.IP "sloppy_floats \s-1BOOLEAN\s0" 4
.IX Item "sloppy_floats BOOLEAN"
The float types of \s-1XML\s0 are all quite big, and may be NaN, \s-1INF\s0, and \-INF.
Perl's normal floats do not, and therefore Math::BigFloat is used.  This,
however, is slow.
.Sp
When this option is true, your application will crash on any value which
is not understood by Perl's internal float implementation... but run much
faster.
.IP "check_values \s-1BOOLEAN\s0" 4
.IX Item "check_values BOOLEAN"
Check the validity of the values, before parsing them.  This will
report errors for the reader, instead of crashes.  The writer will
not produce invalid data.
.IP "check_occurs \s-1BOOLEAN\s0" 4
.IX Item "check_occurs BOOLEAN"
Checking whether the number of occurrences for an item are between
\&\f(CW\*(C`minOccurs\*(C'\fR and \f(CW\*(C`maxOccurs\*(C'\fR (implied for \f(CW\*(C`all\*(C'\fR, \f(CW\*(C`sequence\*(C'\fR, and
\&\f(CW\*(C`choice\*(C'\fR or explicitly specified) takes time.  Of course, in cases
errors must be handled.  When this option is set to \f(CW\*(C`false\*(C'\fR, 
only distinction between single and array elements is made.
.IP "ignore_facets \s-1BOOLEAN\s0" 4
.IX Item "ignore_facets BOOLEAN"
Facets limit field content in the restriction block of a simpleType.
When this option is \f(CW\*(C`true\*(C'\fR, no checks are performed on the values.
In some cases, this may cause problems: especially with whiteSpace and
digits of floats.  However, you may be able to control this yourself.
In most cases, luck even plays a part in this.  Less checks means a
better performance.
.Sp
Simple type restrictions are not implemented by other \s-1XML\s0 perl
modules.  When the schema is nicely detailed, this will give
extra security.
.IP "validation \s-1BOOLEAN\s0" 4
.IX Item "validation BOOLEAN"
When used, it overrules the above \f(CW\*(C`check_values\*(C'\fR, \f(CW\*(C`check_occurs\*(C'\fR, and
\&\f(CW\*(C`ignore_facets\*(C'\fR options.  A true value enables all checks, a false
value will disable them all.  Of course, the latter is the fastest but
also less secure: your program will need to validate the values in some
other way.
.Sp
XML::LibXML has its own validate method, but I have not yet seen any
performance figures on that.  If you use it, however, it is of course
a good idea to turn XML::Compile's validation off.
.PP
\fIqualified \s-1XML\s0\fR
.IX Subsection "qualified XML"
.PP
The produced \s-1XML\s0 may not use the name-spaces as defined by the schemas,
just to simplify the input and output.  The structural definition of
the schemas is still in-tact, but name-space collission may appear.
.PP
Per schema, it can be specified whether the elements and attributes
defined in-there need to be used qualified (with prefix) or not.
This can cause horrible output when within an unqualified schema
elements are used from another schema which is qualified.
.PP
The suggested solution in articles about the subject is to provide
people with both a schema which is qualified as one which is not.
Perl is known to be blunt in its approach: we simply define a flag
which can force one of both on all schemas together, using
\&\f(CW\*(C`elements_qualified\*(C'\fR and \f(CW\*(C`attributes_qualified\*(C'\fR.  May people and
applications do not understand name-spaces sufficiently, and these
options may make your day!
.PP
\fIName-spaces\fR
.IX Subsection "Name-spaces"
.PP
The translator does respect name-spaces, but not all senders and
receivers of \s-1XML\s0 are name-space capable.  Therefore, you have some
options to interfere.
.IP "prefixes HASH|ARRAY\-of\-PAIRS" 4
.IX Item "prefixes HASH|ARRAY-of-PAIRS"
The translator will create \s-1XML\s0 elements (\s-1WRITER\s0) which use name-spaces,
based on its own name\-space/prefix mapping administration.  This is
needed because the \s-1XML\s0 tree is created bottom-up, where XML::LibXML
namespace management can only handle this top-down.
.Sp
When your pass your own \s-1HASH\s0 as argument, you can explicitly specify the
prefixes you like to be used for which name-space.  Found name-spaces
will be added to the \s-1HASH\s0, as well the use count.  When a new name-space
\&\s-1URI\s0 is discovered, an attempt is made to use the prefix as found in
the schema. Prefix collisions are actively avoided: when two URIs want
the same prefix, a sequence number is added to one of them which makes
it unique.
.Sp
The \s-1HASH\s0 structure looks like this:
.Sp
.Vb 4
\&  my %namespaces =
\&    ( myns => { uri => \*(Aqmyns\*(Aq, prefix => \*(Aqmypref\*(Aq, used => 1}
\&    , ...  => { uri => ... }
\&    );
\&
\&  my $make = $schema\->compile
\&    ( WRITER => ...
\&    , prefixes => \e%namespaces
\&    );
\&
\&  # share the same namespace defs with another component
\&  my $other = $schema\->compile
\&    ( WRITER => ...
\&    , prefixes => \e%namespaces
\&    );
.Ve
.Sp
When used is specified and larger than 0, then the namespace will
appear in the top-level output element (unless \f(CW\*(C`include_namespaces\*(C'\fR
is false).
.Sp
Initializing using an \s-1ARRAY\s0 is a little simpler:
.Sp
.Vb 1
\& prefixes => [ mypref => \*(Aqmyns\*(Aq, ... => ... ];
.Ve
.Sp
However, be warned that this does not work well with a false value
for \f(CW\*(C`include_namespaces\*(C'\fR: detected namespaces are added to an
internal \s-1HASH\s0 now, which is not returned; that information is lost.
You will need to know each used namespace beforehand.
.IP "include_namespaces BOOLEAN|CODE" 4
.IX Item "include_namespaces BOOLEAN|CODE"
When true and \s-1WRITER\s0, the top level returned \s-1XML\s0 element will contain
the prefix definitions.  Only name-spaces which are actually used
will be included (a count is kept by the translator).  It may
very well list name-spaces which are not in the actual output
because the fields which require them are not included for there is
not value for those fields.
.Sp
If you like to combine \s-1XML\s0 output from separate translated parts
(for instance in case of generating \s-1SOAP\s0), you may want to delay
the inclusion of name-spaces until a higher level of the \s-1XML\s0
hierarchy which is produced later.
.Sp
When a \s-1CODE\s0 reference is passed, it will be called for each used
namespace, with the uri and prefix as parameters.  Only when the \s-1CODE\s0
returns true, the namespace declaration will be included.
.Sp
When the compilation produces an attribute, then this option cannot
be used.
.IP "namespace_reset \s-1BOOLEAN\s0" 4
.IX Item "namespace_reset BOOLEAN"
You can pass the same \s-1HASH\s0 to a next call to a reader or writer to get
consistent name-space usage.  However, when \f(CW\*(C`include_namespaces\*(C'\fR is
used, you may get ghost name-space listings.  This option will reset
the counts on all defined name-spaces.
.IP "use_default_namespace \s-1BOOLEAN\s0 (added in release 0.57)" 4
.IX Item "use_default_namespace BOOLEAN (added in release 0.57)"
When a true value, the blank prefix will be used for the first namespace
\&\s-1URI\s0 which requires a auto-generated prefix.  However, in quite some
environments, people mix horrible non-namespace qualified elements with 
nice namespace qualified elements.  In such situations, namespace the
qualified-but-default prefix (i.e., no prefix) is confusing.  Therefore,
the option defaults to false: do not use the invisible prefix.
.Sp
You may explicitly specify a blank prefix with \f(CW\*(C`prefixes\*(C'\fR,
which will be used when applicable.
.IP "block_namespace NAMESPACE|TYPE|HASH|CODE|ARRAY" 4
.IX Item "block_namespace NAMESPACE|TYPE|HASH|CODE|ARRAY"
[1.06] Available on global scale via
XML::Compile::Schema::new(block_namespace) or
\&\fIXML::Compile::Schema::blockNamespace()\fR, and for a single compiled
instance via XML::Compile::Schema::compile(block_namespace).
.Sp
Some schemas include other schemas which you do not need.  For instance,
the other schema is only used in rare cases, or the other schema defines
deprecated types and elements.  Of course, you can simply not load those
schemas... however: the main schema may refer to those types and elements
you do not need.  So, with this option, you can make the compilation to
ignore whole namespaces and specific elements or types.
.Sp
The \s-1NAMESPACE\s0 is a uri, which will disable use of any element or type
defined in that space.  You may also provide a specific full \f(CW$type\fR (toplevel
element or type name).  You may also give an \s-1LIST\s0 or \s-1ARRAY\s0 of these, but
then a \s-1HASH\s0 is much more suitable: with linear lookup time.
.Sp
When you provide a \s-1CODE\s0 reference, it will be called for each type
and element to be judged.  Passed are \f(CW$type\fR, \f(CW$ns\fR, \f(CW$local\fR,
and \f(CW$path\fR.  The \f(CW\*(C`$ns/$local\*(C'\fR is the decomposition of \f(CW$type\fR.
When the \s-1CODE\s0 returns \f(CW\*(C`undef\*(C'\fR, then it is undecisive, letting other
rules decide.  When it returns \f(CW0\fR, then the thing will not be blocked
(whatever the other rules decide).  In other cases, the thing will not
be used.
.Sp
.Vb 2
\&  # block a whole namespace
\&  $schema\->blockNamespace("http://xyz.example.com");
\&
\&  # block only a single element or typedef
\&  $schema\->blockNamespace("{http://xyz.example.com}buggy");
\&
\&  # block $ns1 and $type1, unblock $ns2
\&  $schema\->blockNamespace( {$ns1 => 1, $ns2 => 0, $type1 => 1} );
\&
\&  $schema\->blockNamespace($ns1, $type1);
\&  $schema\->compile(..., block_namespace => [$ns1, $type1]);
\&  $schema\->new(..., block_namespace => [$ns1, $type1]);
\&
\&  # very flexible
\&  sub want_block($$$$) ( my ($type,$ns,$local,$path) = @_; undef}
\&  $schema\->blockNamespace(\e&want_block);
.Ve
.Sp
It is very well possible that the blocking of some namespaces breaks the
validness of messages: when those elements are required but set to be
ignored.  There is no way to detect this, on the moment.
.PP
\fIWildcards handlers\fR
.IX Subsection "Wildcards handlers"
.PP
Wildcards are a serious complication: the \f(CW\*(C`any\*(C'\fR and \f(CW\*(C`anyAttribute\*(C'\fR
entities do not describe exactly what can be found, which seriously
hinders the quality of validation and the preparation of XML::Compile.
Therefore, if you use them then you need to process that parts of
\&\s-1XML\s0 yourself.  See the various backends on how to create or process
these elements.
.PP
Automatic decoding is problematic: you do not know what to expect, so
cannot prepare for these data-structures compile-time.  However,
XML::Compile::Cache offers a way out: you can declare the handlers
for these \*(L"any\*(R" components and therewith be prepared for them.  With
\&\f(CW\*(C`XML::Compile::Cache::new(allow_undeclared)\*(C'\fR, you can permit run-time
compilation of  the found components.
.IP "any_element CODE|'\s-1TAKE_ALL\s0'|'\s-1SKIP_ALL\s0'" 4
.IX Item "any_element CODE|'TAKE_ALL'|'SKIP_ALL'"
[0.89] This will be called when the type definition contains an \f(CW\*(C`any\*(C'\fR
definition, after processing the other element components.  By
default, all \f(CW\*(C`any\*(C'\fR specifications will be ignored.
.IP "any_attribute CODE|'\s-1TAKE_ALL\s0'|'\s-1SKIP_ALL\s0'" 4
.IX Item "any_attribute CODE|'TAKE_ALL'|'SKIP_ALL'"
[0.89] This will be called when the type definitions contains an
\&\f(CW\*(C`anyAttribute\*(C'\fR definition, after processing the other attributes.
By default, all \f(CW\*(C`anyAttribute\*(C'\fR specifications will be ignored.
.IP "any_type \s-1CODE\s0" 4
.IX Item "any_type CODE"
[1.07] Called for processing an \*(L"xsd:anyType\*(R" element.  Currently only
supported for the reader.  By default, it returns a string when the
element does not contains sub-elements, otherwise the \s-1XML\s0 node.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile distribution version 1.54,
built on September 19, 2016. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2006\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
