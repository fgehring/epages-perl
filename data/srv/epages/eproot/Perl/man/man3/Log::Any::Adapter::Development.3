.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Any::Adapter::Development 3"
.TH Log::Any::Adapter::Development 3 "2009-10-27" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Any::Adapter::Development \-\- Manual for developing new Log::Any adapters
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The adapter module:
.PP
.Vb 5
\&   package Log::Any::Adapter::YAL;
\&   use strict;
\&   use warnings;
\&   use Log::Any::Adapter::Util qw(make_method);
\&   use base qw(Log::Any::Adapter::Base);
\&   
\&   # Optionally initialize object
\&   #
\&   sub init {
\&       my ($self) = @_;
\&
\&       $self\->{attr} = ...;
\&   }
\&   
\&   # Create logging methods: debug, info, etc.
\&   #
\&   foreach my $method ( Log::Any\->logging_methods() ) {
\&       make_method($method, sub { ... });
\&   }
\&   
\&   # Create detection methods: is_debug, is_info, etc.
\&   #
\&   foreach my $method ( Log::Any\->detection_methods() ) {
\&       make_method($method, sub { ... });
\&   }
.Ve
.PP
and the application:
.PP
.Vb 1
\&   Log::Any\->set_adapter(\*(AqYAL\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes how to implement a new Log::Any adapter.
.PP
The easiest way to start is to look at the source of existing adapters, such as
Log::Any::Adapter::Log4perl and
Log::Any::Adapter::Dispatch.
.SH "NAMING"
.IX Header "NAMING"
If you are going to publicly release your adapter, call it
\&'Log::Any::Adapter::\fIsomething\fR' so that users can use it with
.PP
.Vb 1
\&    Log::Any\->set_adapter(I<something>);
.Ve
.PP
If it's an internal driver, you can call it whatever you like and use it like
.PP
.Vb 1
\&    Log::Any\->set_adapter(\*(Aq+My::Log::Adapter\*(Aq);
.Ve
.SH "BASE CLASS"
.IX Header "BASE CLASS"
All adapters must directly or indirectly inherit from
Log::Any::Adapter::Base.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructor"
.IX Subsection "Constructor"
The constructor (\f(CW\*(C`new\*(C'\fR) is provided by
Log::Any::Adapter::Base. It will:
.IP "\(bu" 4
place any adapter arguments into a hash, along with the category
.IP "\(bu" 4
bless the hash into your subclass
.IP "\(bu" 4
call \*(L"init\*(R" which may be optionally provided by your subclass
.PP
At this point, overriding the default constructor is not supported. Hopefully
it will not be needed.
.PP
The constructor is called whenever a log object is requested. e.g. If the
application initializes Log::Any like so:
.PP
.Vb 1
\&    Log::Any\->set_adapter(\*(AqLog::YAL\*(Aq, yal_object => $yal, depth => 3);
.Ve
.PP
and then a class requests a logger like so:
.PP
.Vb 2
\&    package Foo;
\&    use Log::Any qw($log);
.Ve
.PP
Then \f(CW$log\fR will be populated with the return value of:
.PP
.Vb 1
\&    Log::Any::Adapter::Yal\->new(yal_object => $yal, depth => 3, category => \*(AqFoo\*(Aq);
.Ve
.PP
This is memoized, so if the same category should be requested again (e.g.
through a separate \f(CW\*(C`get_logger\*(C'\fR call, the same object will be returned.
Therefore, you should try to avoid anything non-deterministic in your \*(L"init\*(R"
function.
.SS "Required methods"
.IX Subsection "Required methods"
The following methods have no default implementation, and \s-1MUST\s0 be defined by
your subclass:
.IP "debug ($msg)" 4
.IX Item "debug ($msg)"
.PD 0
.IP "info ($msg)" 4
.IX Item "info ($msg)"
.IP "notice ($msg)" 4
.IX Item "notice ($msg)"
.IP "warning ($msg)" 4
.IX Item "warning ($msg)"
.IP "error ($msg)" 4
.IX Item "error ($msg)"
.IP "critical ($msg)" 4
.IX Item "critical ($msg)"
.IP "alert ($msg)" 4
.IX Item "alert ($msg)"
.IP "emergency ($msg)" 4
.IX Item "emergency ($msg)"
.PD
These methods log a message at the specified level.
.Sp
To help generate these methods programmatically, you can get a list of the
method names with
.Sp
.Vb 1
\&    Log::Any\->logging_methods
.Ve
.IP "is_debug ()" 4
.IX Item "is_debug ()"
.PD 0
.IP "is_info ()" 4
.IX Item "is_info ()"
.IP "is_notice ()" 4
.IX Item "is_notice ()"
.IP "is_warning ()" 4
.IX Item "is_warning ()"
.IP "is_error ()" 4
.IX Item "is_error ()"
.IP "is_critical ()" 4
.IX Item "is_critical ()"
.IP "is_alert ()" 4
.IX Item "is_alert ()"
.IP "is_emergency ()" 4
.IX Item "is_emergency ()"
.PD
These methods return a boolean indicating whether the specified level is
active.
.Sp
To help generate these methods programmatically, you can get a list of the
method names with
.Sp
.Vb 1
\&    Log::Any\->detection_methods
.Ve
.SS "Optional methods"
.IX Subsection "Optional methods"
The following methods have no default implementation but \s-1MAY\s0 be provided by
your subclass:
.IP "init ()" 4
.IX Item "init ()"
This is called after the adapter object is created and blessed into your class.
It will be a hash containing the parameters that were passed to \fInew()\fR. Perform
any necessary validation or initialization here.
.SS "Support methods"
.IX Subsection "Support methods"
The following methods are useful for defining adapters:
.ie n .IP "delegate_method_to_slot ($slot, $method, $adapter_method)" 4
.el .IP "delegate_method_to_slot ($slot, \f(CW$method\fR, \f(CW$adapter_method\fR)" 4
.IX Item "delegate_method_to_slot ($slot, $method, $adapter_method)"
Handle the specified \f(CW$method\fR by calling \f(CW$adapter_method\fR on the object contained
in \f(CW$self\fR\->{$slot}.
.Sp
See Log::Any::Adapter::Dispatch and
Log::Any::Adapter::Log4perl for examples of
usage.
.IP "Log::Any\->logging_methods" 4
.IX Item "Log::Any->logging_methods"
Returns a list of logging methods: debug, info, etc.
.IP "Log::Any\->detection_methods" 4
.IX Item "Log::Any->detection_methods"
Returns a list of detection methods: is_debug, is_info, etc.
.IP "Log::Any\->logging_and_detection_methods" 4
.IX Item "Log::Any->logging_and_detection_methods"
Returns a combined list of logging and detection methods.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jonathan Swartz
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Log::Any
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (C) 2009 Jonathan Swartz.
.PP
Log::Any is provided \*(L"as is\*(R" and without any express or implied warranties,
including, without limitation, the implied warranties of merchantibility and
fitness for a particular purpose.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
