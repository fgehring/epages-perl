.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "prefork 3"
.TH prefork 3 "2009-07-21" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
prefork \- Optimized module loading for forking or non\-forking processes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In a module that normally delays module loading with require
.PP
.Vb 4
\&  # Module Foo::Bar only uses This::That 25% of the time.
\&  # We want to preload in in forking scenarios (like mod_perl), but
\&  # we want to delay loading in non\-forking scenarios (like CGI)
\&  use prefork \*(AqThis::That\*(Aq;
\&  
\&  sub do_something {
\&      my $arg = shift;
\&  
\&      # Load the module at run\-time as normal
\&      if ( $special_case ) {
\&          require This::That;
\&          This::That::blah(@_);
\&      }
\&  }
\&  
\&  # Register a module to be loaded before forking directly
\&  prefork::prefork(\*(AqModule::Name\*(Aq);
.Ve
.PP
In a script or module that is going to be forking.
.PP
.Vb 1
\&  package Module::Forker;
\&  
\&  # Enable forking mode
\&  use prefork \*(Aq:enable\*(Aq;
\&  
\&  # Or call it directly
\&  prefork::enable();
.Ve
.PP
In a third-party run-time loader
.PP
.Vb 1
\&  package Runtime::Loader;
\&  
\&  use prefork ();
\&  prefork::notify( \e&load_everything );
\&  
\&  ...
\&  
\&  sub load_everything { ... }
\&  
\&  1;
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
The task of optimizing module loading in Perl tends to move in two different
directions, depending on the context.
.PP
In a procedural context, such as scripts and CGI-type situations, you can
improve the load times and memory usage by loading a module at run-time,
only once you are sure you will need it.
.PP
In the other common load profile for perl applications, the application
will start up and then fork off various worker processes. To take full
advantage of memory copy-on-write features, the application should load
as many modules as possible before forking to prevent them consuming memory
in multiple worker processes.
.PP
Unfortunately, the strategies used to optimise for these two load profiles
are diametrically opposed. What improves a situation for one tends to
make life worse for the other.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`prefork\*(C'\fR pragma is intended to allow module writers to optimise
module loading for \fBboth\fR scenarios with as little additional code as
possible.
.PP
prefork.pm is intended to serve as a central and optional marshalling
point for state detection (are we running in compile-time or run-time
mode) and to act as a relatively light-weight module loader.
.SS "Loaders and Forkers"
.IX Subsection "Loaders and Forkers"
\&\f(CW\*(C`prefork\*(C'\fR is intended to be used in two different ways.
.PP
The first is by a module that wants to indicate that another module should
be loaded before forking. This is known as a \*(L"Loader\*(R".
.PP
The other is a script or module that will be initiating the forking. It
will tell prefork.pm that it is either going to fork, or is about to fork,
or for some other reason all modules previously mentioned by the Loaders
should be loaded immediately.
.SS "Usage as a Pragma"
.IX Subsection "Usage as a Pragma"
A Loader can register a module to be loaded using the following
.PP
.Vb 1
\&  use prefork \*(AqMy::Module\*(Aq;
.Ve
.PP
The same thing can be done in such a way as to not require prefork
being installed, but taking advantage of it if it is.
.PP
.Vb 1
\&  eval "use prefork \*(AqMy::Module\*(Aq;";
.Ve
.PP
A Forker can indicate that it will be forking with the following
.PP
.Vb 1
\&  use prefork \*(Aq:enable\*(Aq;
.Ve
.PP
In any use of \f(CW\*(C`prefork\*(C'\fR as a pragma, you can only pass a single value
as argument. Any additional arguments will be ignored. (This may throw
an error in future versions).
.SS "Compatbility with mod_perl and others"
.IX Subsection "Compatbility with mod_perl and others"
Part of the design of \f(CW\*(C`prefork\*(C'\fR, and its minimalistic nature, is that it
is intended to work easily with existing modules, needing only small
changes.
.PP
For example, \f(CW\*(C`prefork\*(C'\fR itself will detect the \f(CW$ENV{MOD_PERL}\fR
environment variable and automatically start in forking mode.
.PP
prefork has support for integrating with third-party modules, such as
Class::Autouse. The \f(CW\*(C`notify\*(C'\fR function allows these run-time loaders
to register callbacks, to be called once prefork enters forking mode.
.PP
The synopsis entry above describes adding support for prefork.pm as a
dependency. To allow your third-party module loader without a dependency
and only if it is installed use the following:
.PP
.Vb 2
\&  eval { require prefork; }
\&  prefork::notify( \e&function ) unless $@;
.Ve
.SS "Using prefork.pm"
.IX Subsection "Using prefork.pm"
From the Loader side, it is fairly simple. prefork becomes a dependency
for your module, and you use it as a pragma as documented above.
.PP
For the Forker, you have two options. Use as a dependency or optional use.
.PP
In the dependency case, you add prefork as a dependency and use it as a
pragma with the ':enable' option.
.PP
To add only optional support for prefork, without requiring it to be
installed, you should wait until the moment just before you fork and then
call \f(CW\*(C`prefork::enable\*(C'\fR directly \s-1ONLY\s0 if it is loaded.
.PP
.Vb 2
\&  # Load modules if any use the prefork pragma.
\&  prefork::enable() if $INC{prefork.pm};
.Ve
.PP
This will cause the modules to be loaded \s-1ONLY\s0 if there are any modules that
need to be loaded. The main advantage of the dependency version is that you
only need to enable the module once, and not before each fork.
.PP
If you wish to have your own module leverage off the forking-detection that
prefork provides, you can also do the following.
.PP
.Vb 4
\&  use prefork;
\&  if ( $prefork::FORKING ) {
\&      # Complete some preparation task
\&  }
.Ve
.SS "Modules that are prefork-aware"
.IX Subsection "Modules that are prefork-aware"
.IP "mod_perl/mod_perl2" 4
.IX Item "mod_perl/mod_perl2"
.PD 0
.IP "Class::Autouse" 4
.IX Item "Class::Autouse"
.PD
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .SS "prefork $module"
.el .SS "prefork \f(CW$module\fP"
.IX Subsection "prefork $module"
The 'prefork' function indicates that a module should be loaded before
the process will fork. If already in forking mode the module will be
loaded immediately.
.PP
Otherwise it will be added to a queue to be loaded later if it recieves
instructions that it is going to be forking.
.PP
Returns true on success, or dies on error.
.SS "enable"
.IX Subsection "enable"
The \f(CW\*(C`enable\*(C'\fR function indicates to the prefork module that the process is
going to fork, possibly immediately.
.PP
When called, prefork.pm will immediately load all outstanding modules, and
will set a flag so that any further 'prefork' calls will load the module
at that time.
.PP
Returns true, dieing as normal is there is a problem loading a module.
.SS "notify &function"
.IX Subsection "notify &function"
The \f(CW\*(C`notify\*(C'\fR function is used to integrate support for modules other than
prefork.pm itself.
.PP
A module loader calls the notify function, passing it a reference to a
\&\f(CW\*(C`CODE\*(C'\fR reference (either anon or a function reference). \f(CW\*(C`prefork\*(C'\fR will
store this \s-1CODE\s0 reference, and execute it immediately as soon as it knows
it is in forking-mode, but after it loads its own modules.
.PP
Callbacks are called in the order they are registered.
.PP
Normally, this will happen as soon as the \f(CW\*(C`enable\*(C'\fR function is called.
.PP
However, you should be aware that if prefork is \fBalready\fR in preforking
mode at the time that the notify function is called, prefork.pm will
execute the function immediately.
.PP
This means that any third party module loader should be fully loaded and
initialised \fBbefore\fR the callback is provided to \f(CW\*(C`notify\*(C'\fR.
.PP
Returns true if the function is stored, or dies if not passed a \f(CW\*(C`CODE\*(C'\fR
reference, or the callback is already set in the notify queue.
.SH "TO DO"
.IX Header "TO DO"
\&\- Add checks for more pre-forking situations
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be always submitted via the \s-1CPAN\s0 bug tracker, located at
.PP
<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=prefork>
.PP
For other issues, or commercial enhancement or support, contact the author.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Thank you to Phase N Australia (http://phase\-n.com/ <http://phase-n.com/>) for
permitting the open sourcing and release of this distribution.
.PP
Copyright 2004 \- 2009 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
