.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Report::Message 3"
.TH Log::Report::Message 3 "2011-08-23" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Report::Message \- a piece of text to be translated
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Created by Log::Report\*(Aqs _\|_ functions
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Any used of a translation function, like Log::Report::_\|_() or 
Log::Report::_\|\fI_x()\fR will result in this object.  It will capture
some environmental information, and delay the translation until it
is needed.
.PP
Creating an object first, and translating it later, is slower than
translating it immediately.  However, on the location where the message
is produced, we do not yet know to what language to translate: that
depends on the front-end, the log dispatcher.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBclone\fR(\s-1OPTIONS\s0, \s-1VARIABLES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBclone\fR(\s-1OPTIONS\s0, \s-1VARIABLES\s0)" 4
.IX Item "$obj->clone(OPTIONS, VARIABLES)"
Returns a new object which copies info from original, and updates it
with the specified \s-1OPTIONS\s0 and \s-1VARIABLES\s0.  The advantage is that the
cached translations are shared between the objects.
.Sp
example: use of \fIclone()\fR
.Sp
.Vb 5
\& my $s = _\|_x "found {nr} files", nr => 5;
\& my $t = $s\->clone(nr => 3);
\& my $t = $s\->(nr => 3);      # equivalent
\& print $s;     # found 5 files
\& print $t;     # found 3 files
.Ve
.IP "Log::Report::Message\->\fBnew\fR(\s-1OPTIONS\s0, \s-1VARIABLES\s0)" 4
.IX Item "Log::Report::Message->new(OPTIONS, VARIABLES)"
\&\fBDo not use this method directly\fR, but use Log::Report::_\|_() and
friends.
.Sp
.Vb 12
\& \-Option   \-\-Default
\&  _append    undef
\&  _category  undef
\&  _class     []
\&  _classes   []
\&  _count     undef
\&  _domain    from use
\&  _expand    false
\&  _msgid     undef
\&  _plural    undef
\&  _prepend   undef
\&  _to        <undef>
.Ve
.RS 4
.IP "_append => \s-1STRING\s0" 2
.IX Item "_append => STRING"
.PD 0
.IP "_category => \s-1INTEGER\s0" 2
.IX Item "_category => INTEGER"
.IP "_class => STRING|ARRAY" 2
.IX Item "_class => STRING|ARRAY"
.PD
When messages are used for exception based programming, you add
\&\f(CW\*(C`_class\*(C'\fR parameters to the argument list.  Later, with for instance
Log::Report::Dispatcher::Try::wasFatal(class), you can check the
category of the message.
.Sp
One message can be part of multiple classes.  The \s-1STRING\s0 is used as
comma\- and/or blank seperated list of class tokens, the \s-1ARRAY\s0 lists all
tokens seperately. See \fIclasses()\fR.
.IP "_classes => STRING|ARRAY" 2
.IX Item "_classes => STRING|ARRAY"
Alternative for \f(CW\*(C`_class\*(C'\fR, which cannot be used at the same time.
.IP "_count => \s-1INTEGER\s0" 2
.IX Item "_count => INTEGER"
When defined, then \f(CW\*(C`_plural\*(C'\fR need to be defined as well.
.IP "_domain => \s-1STRING\s0" 2
.IX Item "_domain => STRING"
The textdomain in which this msgid is defined.
.IP "_expand => \s-1BOOLEAN\s0" 2
.IX Item "_expand => BOOLEAN"
Indicates whether variables are filled-in.
.IP "_msgid => \s-1MSGID\s0" 2
.IX Item "_msgid => MSGID"
The message label, which refers to some translation information.  Usually
a string which is close the English version of the error message.  This
will also be used if there is no translation possible
.IP "_plural => \s-1MSGID\s0" 2
.IX Item "_plural => MSGID"
Can be specified when a \f(CW\*(C`_count\*(C'\fR is specified.  This plural form of
the message is used to simplify translation, and as fallback when no
translations are possible: therefore, this can best resemble an English
message.
.IP "_prepend => \s-1STRING\s0" 2
.IX Item "_prepend => STRING"
.PD 0
.IP "_to => \s-1NAME\s0" 2
.IX Item "_to => NAME"
.PD
Specify the \s-1NAME\s0 of a dispatcher as destination explicitly. Short
for  \f(CW\*(C`report {to => NAME}, ...\*(C'\fR  See \fIto()\fR
.RE
.RS 4
.RE
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBappend\fR" 4
.el .IP "\f(CW$obj\fR\->\fBappend\fR" 4
.IX Item "$obj->append"
Returns the string or Log::Report::Message object which is appended
after this one.  Usually \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$obj\->\fBclasses\fR" 4
.el .IP "\f(CW$obj\fR\->\fBclasses\fR" 4
.IX Item "$obj->classes"
Returns the \s-1LIST\s0 of classes which are defined for this message; message
group indicators, as often found in exception-based programming.
.ie n .IP "$obj\->\fBcount\fR" 4
.el .IP "\f(CW$obj\fR\->\fBcount\fR" 4
.IX Item "$obj->count"
Returns the count, which is used to select the translation
alternatives.
.ie n .IP "$obj\->\fBdomain\fR" 4
.el .IP "\f(CW$obj\fR\->\fBdomain\fR" 4
.IX Item "$obj->domain"
Returns the domain of the first translatable string in the structure.
.ie n .IP "$obj\->\fBmsgid\fR" 4
.el .IP "\f(CW$obj\fR\->\fBmsgid\fR" 4
.IX Item "$obj->msgid"
Returns the msgid which will later be translated.
.ie n .IP "$obj\->\fBprepend\fR" 4
.el .IP "\f(CW$obj\fR\->\fBprepend\fR" 4
.IX Item "$obj->prepend"
Returns the string which is prepended to this one.  Usually \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$obj\->\fBto\fR([\s-1NAME\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBto\fR([\s-1NAME\s0])" 4
.IX Item "$obj->to([NAME])"
Returns the \s-1NAME\s0 of a dispatcher if explicitly specified with
the '_to' key. Can also be used to set it.  Usually, this will
return undef, because usually all dispatchers get all messages.
.ie n .IP "$obj\->\fBvalueOf\fR(\s-1PARAMETER\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBvalueOf\fR(\s-1PARAMETER\s0)" 4
.IX Item "$obj->valueOf(PARAMETER)"
Lookup the named \s-1PARAMETER\s0 for the message.  All pre-defined names
have their own method, and should be used with preference.
.Sp
example:
.Sp
When the message was produced with
  my \f(CW@files\fR = qw/one two three/;
  my \f(CW$msg\fR = _\|_xn \*(L"found one file: {files}\*(R"
               , \*(L"found {_count} files: {files}\*(R"
               , scalar \f(CW@files\fR, files => \e@files
               , _class => '\s-1IO\s0, files';
.Sp
then the values can be takes from the produced message as
  my \f(CW$files\fR = \f(CW$msg\fR\->valueOf('files');  # returns \s-1ARRAY\s0 reference
  print @$files;              # 3
  my \f(CW$count\fR = \f(CW$msg\fR\->count;    # 3
  my \f(CW@class\fR = \f(CW$msg\fR\->classes;  # '\s-1IO\s0', 'files'
  if($msg\->inClass('files'))  # true
.SS "Processing"
.IX Subsection "Processing"
.ie n .IP "$obj\->\fBconcat\fR(STRING|OBJECT, [\s-1PREPEND\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBconcat\fR(STRING|OBJECT, [\s-1PREPEND\s0])" 4
.IX Item "$obj->concat(STRING|OBJECT, [PREPEND])"
This method implements the overloading of concatenation, which is needed
to delay translations even longer.  When \s-1PREPEND\s0 is true, the \s-1STRING\s0
or \s-1OBJECT\s0 (other \f(CW\*(C`Log::Report::Message\*(C'\fR) needs to prepended, otherwise
it is appended.
.Sp
example: of concatenation
.Sp
.Vb 2
\& print _\|_"Hello" . \*(Aq \*(Aq . _\|_"World!";
\& print _\|_("Hello")\->concat(\*(Aq \*(Aq)\->concat(_\|_"World!")\->concat("\en");
.Ve
.ie n .IP "$obj\->\fBinClass\fR(CLASS|REGEX)" 4
.el .IP "\f(CW$obj\fR\->\fBinClass\fR(CLASS|REGEX)" 4
.IX Item "$obj->inClass(CLASS|REGEX)"
Returns true if the message is in the specified \s-1CLASS\s0 (string) or
matches the \s-1REGEX\s0.  The trueth value is the (first matching) class.
.ie n .IP "$obj\->\fBtoString\fR([\s-1LOCALE\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBtoString\fR([\s-1LOCALE\s0])" 4
.IX Item "$obj->toString([LOCALE])"
Translate a message.  If not specified, the default locale is used.
.ie n .IP "$obj\->\fBuntranslated\fR" 4
.el .IP "\f(CW$obj\fR\->\fBuntranslated\fR" 4
.IX Item "$obj->untranslated"
Return the concatenation of the prepend, msgid, and append strings.  Variable
expansions within the msgid is not performed.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "\s-1OPTIONS\s0 and \s-1VARIABLES\s0"
.IX Subsection "OPTIONS and VARIABLES"
\fIInterpolating\fR
.IX Subsection "Interpolating"
.PP
With the \f(CW\*(C`_\|_x()\*(C'\fR or \f(CW\*(C`_\|_nx()\*(C'\fR, interpolation will take place on the
translated \s-1MSGID\s0 string.  The translation can contain the \s-1VARIABLE\s0
and \s-1OPTION\s0 names between curly brackets.  Text between curly brackets
which is not a known parameter will be left untouched.
.PP
Next to the name, you can specify a format code.  With \f(CW\*(C`gettext()\*(C'\fR,
you often see this:
.PP
.Vb 1
\& printf gettext("approx pi: %.6f\en"), PI;
.Ve
.PP
Locale::TextDomain has two ways.
.PP
.Vb 2
\& printf _\|_"approx pi: %.6f\en", PI;
\& print _\|_x"approx pi: {approx}\en", approx => sprintf("%.6f", PI);
.Ve
.PP
The first does not respect the wish to be able to reorder the
arguments during translation.  The second version is quite long.
With \f(CW\*(C`Log::Report\*(C'\fR, above syntaxes do work, but you can also do
.PP
.Vb 1
\& print _\|_x"approx pi: {pi%.6f}\en", pi => PI;
.Ve
.PP
So: the interpolation syntax is \f(CW\*(C` { name [format] } \*(C'\fR.  Other
examples:
.PP
.Vb 3
\& print _\|_x "{perms} {links%2d} {user%\-8s} {size%10d} {fn}\en"
\&         , perms => \*(Aq\-rw\-r\-\-r\-\-\*(Aq, links => 1, user => \*(Aqme\*(Aq
\&         , size => \*(Aq12345\*(Aq, fn => $filename;
.Ve
.PP
An additional advantage is the fact that not all languages produce
comparable length strings.  Now, the translators can take care that
the layout of tables is optimal.
.PP
\fIInterpolation of \s-1OPTIONS\s0\fR
.IX Subsection "Interpolation of OPTIONS"
.PP
You are permitted the interpolate \s-1OPTION\s0 values in your string.  This may
simplify your coding.  The useful names are:
.IP "_msgid" 4
.IX Item "_msgid"
The \s-1MSGID\s0 as provided with Log::Report::_\|_() and Log::Report::_\|\fI_x()\fR
.IP "_msgid, _plural, _count" 4
.IX Item "_msgid, _plural, _count"
The single \s-1MSGID\s0 and \s-1PLURAL\s0 MSGIDs, respectively the \s-1COUNT\s0 as used with
Log::Report::_\|\fI_n()\fR and Log::Report::_\|\fI_nx()\fR
.IP "_textdomain" 4
.IX Item "_textdomain"
The label of the textdomain in which the translation takes place.
.IP "_class or _classes" 4
.IX Item "_class or _classes"
Are to be used to group reports, and can be queried with \fIinClass()\fR,
\&\fILog::Report::Exception::inClass()\fR, or
\&\fILog::Report::Dispatcher::Try::wasFatal()\fR.
.PP
\fIInterpolation of \s-1VARIABLES\s0\fR
.IX Subsection "Interpolation of VARIABLES"
.PP
There is no way of checking beforehand whether you have provided all required
values, to be interpolated in the translated string.  A translation could be
specified like this:
.PP
.Vb 6
\& my @files = @ARGV;
\& local $"  = \*(Aq, \*(Aq;
\& my $s = _\|_nx "One file specified ({files})"
\&            , "{_count} files specified ({files})"
\&            , scalar @files     # actually, \*(Aqscalar\*(Aq is not needed
\&            , files => \e@files;
.Ve
.PP
For interpolating, the following rules apply:
.IP "." 4
Simple scalar values are interpolated \*(L"as is\*(R"
.IP "." 4
References to SCALARs will collect the value on the moment that the
output is made.  The \f(CW\*(C`Log::Report::Message\*(C'\fR object which is created with
the \f(CW\*(C`_\|_xn\*(C'\fR can be seen as a closure.  The translation can be reused.
See example below.
.IP "." 4
Code references can be used to create the data \*(L"under fly\*(R".  The
\&\f(CW\*(C`Log::Report::Message\*(C'\fR object which is being handled is passed as
only argument.  This is a hash in which all \s-1OPTIONS\s0 and \s-1VARIABLES\s0
can be found.
.IP "." 4
When the value is an \s-1ARRAY\s0, all members will be interpolated with \f(CW$"\fR
between the elements.
.PP
\fIAvoiding repetative translations\fR
.IX Subsection "Avoiding repetative translations"
.PP
This way of translating is somewhat expensive, because an object to
handle the \f(CW\*(C`_\|_x()\*(C'\fR is created each time.
.PP
.Vb 3
\& for my $i (1..100_000)
\& {   print _\|_x "Hello World {i}\en", $i;
\& }
.Ve
.PP
The suggestion that Locale::TextDomain makes to improve performance,
is to get the translation outside the loop, which only works without
interpolation:
.PP
.Vb 6
\& use Locale::TextDomain;
\& my $i = 42;
\& my $s = _\|_x("Hello World {i}\en", i => $i);
\& foreach $i (1..100_000)
\& {   print $s;
\& }
.Ve
.PP
Oops, not what you mean.
With Log::Report, you can do
.PP
.Vb 6
\& use Log::Report;
\& my $i;
\& my $s = _\|_x("Hello World {i}", i => \e$i);
\& foreach $i (1..100_000)
\& {   print $s;
\& }
.Ve
.PP
Mind you not to write: \f(CW\*(C`for my $i\*(C'\fR in this case!!!!
You can also write an incomplete translation:
.PP
.Vb 5
\& use Log::Report;
\& my $s = _\|_x "Hello World {i}";
\& foreach my $i (1..100_000)
\& {   print $s\->(i => $i);
\& }
.Ve
.PP
In either case, the translation will be looked-up only once.
.PP
The Log::Report functions which define translation request can all
have \s-1OPTIONS\s0.  Some can have \s-1VARIABLES\s0 to be interpolated in the string as
well.  To distinguish between the \s-1OPTIONS\s0 and \s-1VARIABLES\s0 (both a list
of key-value pairs), the keys of the \s-1OPTIONS\s0 start with an underscore \f(CW\*(C`_\*(C'\fR.
As result of this, please avoid the use of keys which start with an
underscore in variable names.  On the other hand, you are allowed to
interpolate \s-1OPTION\s0 values in your strings.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
.IP "overload: \fBas function\fR" 4
.IX Item "overload: as function"
When the object is used to call as function, a new object is
created with the data from the original one but updated with the
new parameters.  Implemented in \f(CW\*(C`clone()\*(C'\fR.
.IP "overload: \fBconcatenation\fR" 4
.IX Item "overload: concatenation"
An (accidental) use of concatenation (a dot where a comma should be
used) would immediately stringify the object.  This is avoided by
overloading that operation.
.IP "overload: \fBstringification\fR" 4
.IX Item "overload: stringification"
When the object is used in string context, it will get translated.
Implemented as \fItoString()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Log-Report distribution version 0.94,
built on August 23, 2011. Website: \fIhttp://perl.overmeer.net/log\-report/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2011 by Mark Overmeer. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
