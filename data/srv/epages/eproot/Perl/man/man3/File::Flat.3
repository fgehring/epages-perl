.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "File::Flat 3"
.TH File::Flat 3 "2008-03-24" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
File::Flat \- Implements a flat filesystem
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
File::Flat implements a flat filesystem. A flat filesystem is a filesystem in
which directories do not exist. It provides an abstraction over any normal
filesystem which makes it appear as if directories do not exist. In effect,
it will automatically create directories as needed. This is create for things
like install scripts and such, as you never need to worry about the existance
of directories, just write to a file, no matter where it is.
.SS "Comprehensive Implementation"
.IX Subsection "Comprehensive Implementation"
The implementation of File::Flat is extremely comprehensive in scope. It has
methods for all stardard file interaction taks, the \-X series of tests, and
some other things, such as slurp.
.PP
All methods are statically called, for example, to write some stuff to a file.
.PP
.Vb 2
\&  use File::Flat;
\&  File::Flat\->write( \*(Aqfilename\*(Aq, \*(Aqfile contents\*(Aq );
.Ve
.SS "Use of other modules"
.IX Subsection "Use of other modules"
File::Flat tries to use more task orientated modules wherever possible. This
includes the use of File::Copy, File::Copy::Recursive, File::Remove
and others. These are mostly loaded on-demand.
.ie n .SS "Pruning and $AUTO_PRUNE"
.el .SS "Pruning and \f(CW$AUTO_PRUNE\fP"
.IX Subsection "Pruning and $AUTO_PRUNE"
\&\*(L"Pruning\*(R" is a technique where empty directories are assumed to be useless,
and thus empty removed whenever one is created. Thus, when some other task
has the potential to leave an empty directory, it is checked and deleted if
it is empty.
.PP
By default File::Flat does not prune, and pruning must be done explicitly,
via either the \*(L"prune\*(R" in File::Flat method, or by setting the second
argument to the \*(L"remove\*(R" in File::Flat method to be true.
.PP
However by setting the global \f(CW$AUTO_PRUNE\fR variable to true, File::Flat
will automatically prune directories at all times. You should generally use
this locally, such as in the following example.
.PP
.Vb 1
\&  #!/usr/bin/perl
\&  
\&  use strict;
\&  use File::Flat;
\&  
\&  delete_files(@ARGV);
\&  exit();
\&  
\&  # Recursively delete and prune all files provided on the command line
\&  sub delete_files {
\&        local $File::Flat::AUTO_PRUNE = 1;
\&        foreach my $file ( @_ ) {
\&                File::Flat\->remove( $file ) or die "Failed to delete $file";
\&        }
\&  }
.Ve
.SS "Non-Unix platforms"
.IX Subsection "Non-Unix platforms"
As of version 0.97 File::Flat should work correctly on Win32. Other
platforms (such as \s-1VMS\s0) are believed to work, but require confirmation.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "exists $filename"
.el .SS "exists \f(CW$filename\fP"
.IX Subsection "exists $filename"
Tests for the existance of the file.
This is an exact duplicate of the \-e function.
.ie n .SS "isaFile $filename"
.el .SS "isaFile \f(CW$filename\fP"
.IX Subsection "isaFile $filename"
Tests whether \f(CW\*(C`filename\*(C'\fR is a file.
This is an exact duplicate of the \-f function.
.ie n .SS "isaDirectory $filename"
.el .SS "isaDirectory \f(CW$filename\fP"
.IX Subsection "isaDirectory $filename"
Test whether \f(CW\*(C`filename\*(C'\fR is a directory.
This is an exact duplicate of the \-d function.
.ie n .SS "canRead $filename"
.el .SS "canRead \f(CW$filename\fP"
.IX Subsection "canRead $filename"
Does the file or directory exist, and can we read from it.
.ie n .SS "canWrite $filename"
.el .SS "canWrite \f(CW$filename\fP"
.IX Subsection "canWrite $filename"
Does the file or directory exist, and can we write to it 
\&\fB\s-1OR\s0\fR can we create the file or directory.
.ie n .SS "canReadWrite $filename"
.el .SS "canReadWrite \f(CW$filename\fP"
.IX Subsection "canReadWrite $filename"
Does a file or directory exist, and can we both read and write it.
.ie n .SS "canExecute $filename"
.el .SS "canExecute \f(CW$filename\fP"
.IX Subsection "canExecute $filename"
Does a file or directory exist, and can we execute it.
.ie n .SS "canOpen $filename"
.el .SS "canOpen \f(CW$filename\fP"
.IX Subsection "canOpen $filename"
Is this something we can open a filehandle to. Returns true if filename
exists, is a file, and we can read from it.
.ie n .SS "canRemove $filename"
.el .SS "canRemove \f(CW$filename\fP"
.IX Subsection "canRemove $filename"
Can we remove the file or directory.
.ie n .SS "isaText $filename"
.el .SS "isaText \f(CW$filename\fP"
.IX Subsection "isaText $filename"
Does the file \f(CW\*(C`filename\*(C'\fR exist, and is it a text file.
.ie n .SS "isaBinary $filename"
.el .SS "isaBinary \f(CW$filename\fP"
.IX Subsection "isaBinary $filename"
Does the file \f(CW\*(C`filename\*(C'\fR exist, and is it a binary file.
.ie n .SS "fileSize $filename"
.el .SS "fileSize \f(CW$filename\fP"
.IX Subsection "fileSize $filename"
If the file exists, returns its size in bytes.
Returns undef if the file does not exist.
.ie n .SS "open [ $mode, ] $filename"
.el .SS "open [ \f(CW$mode\fP, ] \f(CW$filename\fP"
.IX Subsection "open [ $mode, ] $filename"
Rough analogue of the open function, but creates directories on demand
as needed. Supports most of the normal options to the normal open function.
.PP
In the single argument form, it takes modes in the form [mode]filename. For
example, all the following are valid.
.PP
.Vb 5
\&  File::Flat\->open( \*(Aqfilename\*(Aq );
\&  File::Flat\->open( \*(Aq<filename\*(Aq );
\&  File::Flat\->open( \*(Aq>filename\*(Aq );
\&  File::Flat\->open( \*(Aq>>filename\*(Aq );
\&  File::Flat\->open( \*(Aq+<filename\*(Aq );
.Ve
.PP
In the two argument form, it takes the following
.PP
.Vb 4
\&  File::Flat\->open( \*(Aq<\*(Aq, \*(Aqfilename\*(Aq );
\&  File::Flat\->open( \*(Aq>\*(Aq, \*(Aqfilename\*(Aq );
\&  File::Flat\->open( \*(Aq>>\*(Aq, \*(Aqfilename\*(Aq );
\&  File::Flat\->open( \*(Aq+<\*(Aq, \*(Aqfilename\*(Aq );
.Ve
.PP
It does not support the more esoteric forms of open, such us opening to a pipe
or other such things.
.PP
On successfully opening the file, it returns it as an IO::File object.
Returns undef on error.
.ie n .SS "getReadHandle $filename"
.el .SS "getReadHandle \f(CW$filename\fP"
.IX Subsection "getReadHandle $filename"
The same as File::Flat\->open( '<', 'filename' )
.ie n .SS "getWriteHandle $filename"
.el .SS "getWriteHandle \f(CW$filename\fP"
.IX Subsection "getWriteHandle $filename"
The same as File::Flat\->open( '>', 'filename' )
.ie n .SS "getAppendHandle $filename"
.el .SS "getAppendHandle \f(CW$filename\fP"
.IX Subsection "getAppendHandle $filename"
The same as File::Flat\->open( '>>', 'filename' )
.ie n .SS "getReadWriteHandle $filename"
.el .SS "getReadWriteHandle \f(CW$filename\fP"
.IX Subsection "getReadWriteHandle $filename"
The same as File::Flat\->open( '+<', 'filename' )
.ie n .SS "read $filename"
.el .SS "read \f(CW$filename\fP"
.IX Subsection "read $filename"
Opens and reads in an entire file, chomping as needed.
.PP
In array context, it returns an array containing each line of the file.
In scalar context, it returns a reference to an array containing each line of
the file. It returns undef on error.
.ie n .SS "slurp $filename"
.el .SS "slurp \f(CW$filename\fP"
.IX Subsection "slurp $filename"
The \f(CW\*(C`slurp\*(C'\fR method 'slurps' a file in. That is it attempts to read the entire
file into a variable in as quick and memory efficient method as possible.
.PP
On success, returns a reference to a scalar, containing the entire file.
Returns undef on error.
.ie n .SS "write $filename, ( $content | \e$content | \e@content )"
.el .SS "write \f(CW$filename\fP, ( \f(CW$content\fP | \e$content | \e@content )"
.IX Subsection "write $filename, ( $content | $content | @content )"
The \f(CW\*(C`write\*(C'\fR method is the main method for writing content to a file.
It takes two arguments, the location to write to, and the content to write, 
in several forms.
.PP
If the file already exists, it will be clobered before writing starts.
If the file doesn't exists, the file and any directories will be created as
needed.
.PP
Content can be provided in three forms. The contents of a scalar argument will
be written directly to the file. You can optionally pass a reference to the 
scalar. This is recommended when the file size is bigger than a few thousand
characters, is it does not duplicate the file contents in memory.
Alternatively, you can pass the content as a reference to an array containing
the contents. To ensure uniformity, \f(CW\*(C`write\*(C'\fR will add a newline to each line,
replacing any existing newline as needed.
.PP
Returns true on success, and undef on error.
.ie n .SS "append $filename, ( $content | \e$content | \e@content )"
.el .SS "append \f(CW$filename\fP, ( \f(CW$content\fP | \e$content | \e@content )"
.IX Subsection "append $filename, ( $content | $content | @content )"
This method is the same as \f(CW\*(C`write\*(C'\fR, except that it appends to the end of 
an existing file ( or creates the file as needed ).
.PP
This is the method you should be using to write to log files, etc.
.ie n .SS "overwrite $filename, ( $content | \e$content | \e@content )"
.el .SS "overwrite \f(CW$filename\fP, ( \f(CW$content\fP | \e$content | \e@content )"
.IX Subsection "overwrite $filename, ( $content | $content | @content )"
Performs an atomic write over a file. It does this by writing to a temporary
file, and moving the completed file over the top of the existing file ( or
creating a new file as needed ). When writing to a file that is on the same
partition as /tmp, this should always be atomic.
.PP
This method otherwise acts the same as \f(CW\*(C`write\*(C'\fR.
.ie n .SS "copy $source, $target"
.el .SS "copy \f(CW$source\fP, \f(CW$target\fP"
.IX Subsection "copy $source, $target"
The \f(CW\*(C`copy\*(C'\fR method attempts to copy a file or directory from the source to
the target. New directories to contain the target will be created as needed.
.PP
For example \f(CW\*(C`<File::Flat\-\*(C'\fR( './this', './a/b/c/d/that' );>> will create the
directory structure required as needed.
.PP
In the file copy case, if the target already exists, and is a writable file,
we replace the existing file, retaining file mode and owners. If the target
is a directory, we do \s-1NOT\s0 copy into that directory, unlike with the 'cp'
unix command. And error is instead returned.
.PP
\&\f(CW\*(C`copy\*(C'\fR will also do limited recursive copying or directories. If source
is a directory, and target does not exists, a recursive copy of source will
be made to target. If target already exists ( file or directory ), \f(CW\*(C`copy\*(C'\fR
will returns with an error.
.ie n .SS "move $source, $target"
.el .SS "move \f(CW$source\fP, \f(CW$target\fP"
.IX Subsection "move $source, $target"
The \f(CW\*(C`move\*(C'\fR method follows the conventions of the 'mv' command, with the 
exception that the directories containing target will of course be created
on demand.
.ie n .SS "remove $filename [, $prune ]"
.el .SS "remove \f(CW$filename\fP [, \f(CW$prune\fP ]"
.IX Subsection "remove $filename [, $prune ]"
The \f(CW\*(C`remove\*(C'\fR method will remove a file, or recursively remove a directory.
.PP
If a second (true) argument is provided, then once the file or directory
has been deleted, the method will the automatically work its way upwards
pruning (deleting) empty and thus assumably useless directories.
.PP
Returns true if the deletion (and pruning if requested) was a success, or
\&\f(CW\*(C`undef\*(C'\fR otherwise.
.ie n .SS "prune $filename"
.el .SS "prune \f(CW$filename\fP"
.IX Subsection "prune $filename"
For a file that has already been delete, \f(CW\*(C`prune\*(C'\fR will work upwards,
removing any empty directories it finds.
.PP
For anyone familiar with \s-1CVS\s0, it is similar to the \f(CW\*(C`update \-P\*(C'\fR flag.
.PP
Returns true, or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .SS "truncate $filename [, $size ]"
.el .SS "truncate \f(CW$filename\fP [, \f(CW$size\fP ]"
.IX Subsection "truncate $filename [, $size ]"
The \f(CW\*(C`truncate\*(C'\fR method will truncate an existing file to partular size.
A size of 0 ( zero ) is used if no size is provided. If the file does not
exists, it will be created, and set to 0. Attempting to truncate a 
directory will fail.
.PP
Returns true on success, or undef on error.
.ie n .SS "makeDirectory $directory [, mode ]"
.el .SS "makeDirectory \f(CW$directory\fP [, mode ]"
.IX Subsection "makeDirectory $directory [, mode ]"
In the case where you do actually have to create a directory only, the
\&\f(CW\*(C`makeDirectory\*(C'\fR method can be used to create a directory or any depth.
.PP
An optional file mode ( default 0755 ) can be provided.
.PP
Returns true on success, returns undef on error.
.SH "TO DO"
.IX Header "TO DO"
Function interface to be written, like
File::Spec::Functions, to provide importable functions.
.PP
There's something bigger here too, I'm not exactly sure what it is,
but I think there might be the beginings of a unified filesystem
interface here... \s-1FSI\s0.pm
.SH "SUPPORT"
.IX Header "SUPPORT"
Bugs should be filed at via the \s-1CPAN\s0 bug tracker at:
.PP
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File\-Flat <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Flat>
.PP
For other issues or comments, contact the author
.SH "AUTHORS"
.IX Header "AUTHORS"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
File::Spec, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 \- 2008 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
