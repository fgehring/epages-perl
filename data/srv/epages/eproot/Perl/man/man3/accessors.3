.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "accessors 3"
.TH accessors 3 "2014-08-08" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
accessors \- create accessor methods in caller's package.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Foo;
\&  use accessors qw( foo bar baz );
\&
\&  my $obj = bless {}, \*(AqFoo\*(Aq;
\&
\&  # generates chaining accessors
\&  # that you can set like this:
\&  $obj\->foo( \*(Aqhello \*(Aq )
\&      \->bar( \*(Aqworld\*(Aq )
\&      \->baz( "!\en" );
\&
\&  # you get the values by passing no params:
\&  print $obj\->foo, $obj\->bar, $obj\->baz;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fBaccessors\fR pragma lets you create simple accessors at compile-time.
.PP
This saves you from writing them by hand, which tends to result in
\&\fIcut-n-paste\fR errors and a mess of duplicated code.  It can also help you
reduce the ammount of unwanted \fIdirect-variable access\fR that may creep into
your codebase when you're feeling lazy.  \fBaccessors\fR was designed with
laziness in mind.
.PP
Method-chaining accessors are generated by default.  Note that you can still
use accessors::chained directly for reasons of backwards compatability.
.PP
See accessors::classic for accessors that always return the current value if
you don't like method chaining.
.SH "GENERATED METHODS"
.IX Header "GENERATED METHODS"
\&\fBaccessors\fR will generate methods that return the current object on set:
.PP
.Vb 5
\&  sub foo {
\&      my $self = shift;
\&      if (@_) { $self\->{\-foo} = shift; return $self; }
\&      else    { return $self\->{\-foo}; }
\&  }
.Ve
.PP
This way they can be \fIchained\fR together.
.SS "Why prepend the dash?"
.IX Subsection "Why prepend the dash?"
The dash (\f(CW\*(C`\-\*(C'\fR) is prepended to the property name for a few reasons:
.IP "\(bu" 4
interoperability with Error.
.IP "\(bu" 4
to make it difficult to accidentally access the property directly ala:
.Sp
.Vb 3
\&  use accessors qw( foo );
\&  $obj\->{foo};  # prevents this by mistake
\&  $obj\->foo;    # when you probably meant this
.Ve
.Sp
(this might sound woolly, but it's easy enough to do).
.IP "\(bu" 4
syntactic sugar (this \fIis\fR woolly :).
.PP
You shouldn't care too much about how the property is stored anyway \- if you do,
you're likely trying to do something special (and should really consider writing
the accessors out long hand), or it's simply a matter of preference in which
case you can use accessors::classic, or sub-class this module.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
There is \fBlittle-to-no performace hit\fR when using generated accessors; in
fact there is \fBusually a performance gain\fR.
.IP "\(bu" 4
typically \fI10\-30% faster\fR than hard-coded accessors (like the above example).
.IP "\(bu" 4
typically \fI1\-15% slower\fR than \fIoptimized\fR accessors (less readable).
.IP "\(bu" 4
typically a \fIsmall\fR performance hit at startup (accessors are created at
compile-time).
.IP "\(bu" 4
uses the same anonymous sub to reduce memory consumption (sometimes by 80%).
.PP
See the benchmark tests included with this distribution for more details.
.SH "MOTIVATION"
.IX Header "MOTIVATION"
The main difference between the \fBaccessors\fR pragma and other accessor
generators is \fBsimplicity\fR.
.IP "\(bu" 4
interface
.Sp
\&\fBuse accessors qw( ... )\fR is as easy as it gets.
.IP "\(bu" 4
a pragma
.Sp
it fits in nicely with the \fBbase\fR pragma:
.Sp
.Vb 2
\&  use base      qw( Some::Class );
\&  use accessors qw( foo bar baz );
.Ve
.Sp
and accessors get created at compile-time.
.IP "\(bu" 4
no bells and whistles
.Sp
The module is extensible instead.
.SH "SUB-CLASSING"
.IX Header "SUB-CLASSING"
If you prefer a different style of accessor or you need to do something more
complicated, there's nothing to stop you from sub-classing.  It should be
pretty easy.  Look through accessors::classic, accessors::ro, and
accessors::rw to see how it's done.
.SH "CAVEATS"
.IX Header "CAVEATS"
Classes using blessed scalarrefs, arrayrefs, etc. are not supported for sake
of simplicity.  Only hashrefs are supported.
.SH "THANKS"
.IX Header "THANKS"
Thanks to Michael G. Schwern for indirectly inspiring this module, and for his
feedback & suggestions.
.PP
Also to Paul Makepeace and David Wright for showing me faster accessors, to
chocolateboy for his contributions, the \s-1CPAN\s0 Testers for their bug reports,
and to James Duncan and people on London.pm for their feedback.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Purkis <spurkis@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
accessors::classic, accessors::chained
.PP
Similar and related modules:
.PP
base,
fields,
Class::Accessor,
Class::Struct,
Class::Methodmaker,
Class::Generate,
Class::Class,
Class::Tangram,
Object::Tiny
