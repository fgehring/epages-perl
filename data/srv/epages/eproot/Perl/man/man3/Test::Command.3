.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Command 3"
.TH Test::Command 3 "2015-09-17" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Command \- Test routines for external commands
.SH "VERSION"
.IX Header "VERSION"
Version 0.11
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Test the exit status, signal, \s-1STDOUT\s0 or \s-1STDERR\s0 of an external command.
.PP
.Vb 1
\&   use Test::Command tests => 11;
\&
\&   ## testing exit status
\&
\&   my $cmd = \*(Aqtrue\*(Aq;
\&
\&   exit_is_num($cmd, 0);
\&   exit_cmp_ok($cmd, \*(Aq<\*(Aq, 10);
\&
\&   $cmd = \*(Aqfalse\*(Aq;
\&
\&   exit_isnt_num($cmd, 0);
\&
\&   ## testing terminating signal 
\&
\&   $cmd = \*(Aqtrue\*(Aq;
\&
\&   signal_is_num($cmd, 0);
\&
\&   ## testing STDOUT
\&
\&   $cmd         = [qw/ echo out /];  ## run as "system @$cmd"
\&   my $file_exp = \*(Aqecho_stdout.exp\*(Aq;
\&
\&   stdout_is_eq($cmd, "out\en");
\&   stdout_isnt_eq($cmd, "out");
\&   stdout_is_file($cmd, $file_exp);
\&
\&   ## testing STDERR
\&
\&   $cmd = \*(Aqecho err >&2\*(Aq;
\&
\&   stderr_like($cmd, /err/);
\&   stderr_unlike($cmd, /rre/);
\&   stderr_cmp_ok($cmd, \*(Aqeq\*(Aq, "err\en");
\&
\&   ## run\-once\-test\-many\-OO\-style
\&   ## the first test lazily runs command
\&   ## the second test uses cached results
\&
\&   my $echo_test = Test::Command\->new( cmd => \*(Aqecho out\*(Aq );
\&
\&   $echo_test\->exit_is_num(0);
\&   $echo_test\->signal_is_num(0);
\&   $echo_test\->stdout_is_eq("out\en");
\&
\&   ## force a re\-run of the command
\&
\&   $echo_test\->run;
\&
\&   ## arbitrary results inspection
\&
\&   is( $echo_test\->exit_value, 0,         \*(Aqecho exit\*(Aq );
\&   is( $echo_test\->signal_value, undef,   \*(Aqecho signal\*(Aq );
\&   is( $echo_test\->stdout_value, "out\en", \*(Aqecho stdout\*(Aq );
\&   is( $echo_test\->stderr_value, \*(Aq\*(Aq,      \*(Aqecho stderr\*(Aq );
\&   is( \-s $echo_test\->stdout_file, 4,     \*(Aqecho stdout file size\*(Aq );
\&   is( \-s $echo_test\->stderr_file, 0,     \*(Aqecho stderr file size\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Test::Command\*(C'\fR intends to bridge the gap between the well tested functions and
objects you choose and their usage in your programs. By examining the exit
status, terminating signal, \s-1STDOUT\s0 and \s-1STDERR\s0 of your program you can determine
if it is behaving as expected.
.PP
This includes testing the various combinations and permutations of options and
arguments as well as the interactions between the various functions and objects
that make up your program.
.PP
The various test functions below can accept either a command string or an
array reference for the first argument. If the command is expressed as a
string it is passed to \f(CW\*(C`system\*(C'\fR as is. If the command is expressed as an
array reference it is dereferenced and passed to \f(CW\*(C`system\*(C'\fR as a list. See
\&'\f(CW\*(C`perldoc \-f system\*(C'\fR' for how these may differ.
.PP
The final argument for the test functions, \f(CW$name\fR, is optional. By default the
\&\f(CW$name\fR is a concatenation of the test function name, the command string and
the expected value. This construction is generally sufficient for identifying a
failing test, but you may always specify your own \f(CW$name\fR if desired.
.PP
Any of the test functions can be used as instance methods on a \f(CW\*(C`Test::Command\*(C'\fR
object. This is done by dropping the initial \f(CW$cmd\fR argument and instead using
arrow notation.
.PP
All of the following \f(CW\*(C`exit_is_num\*(C'\fR calls are equivalent.
.PP
.Vb 4
\&   exit_is_num(\*(Aqtrue\*(Aq, 0);
\&   exit_is_num(\*(Aqtrue\*(Aq, 0, \*(Aqexit_is_num: true, 0\*(Aq);
\&   exit_is_num([\*(Aqtrue\*(Aq], 0);
\&   exit_is_num([\*(Aqtrue\*(Aq], 0, \*(Aqexit_is_num: true, 0\*(Aq);
\&
\&   my $cmd = Test::Command\->new( cmd => \*(Aqtrue\*(Aq );
\&
\&   exit_is_num($cmd, 0);
\&   exit_is_num($cmd, 0, \*(Aqexit_is_num: true, 0\*(Aq);
\&   $cmd\->exit_is_num(0);
\&   $cmd\->exit_is_num(0, \*(Aqexit_is_num: true, 0\*(Aq);
\&
\&   $cmd = Test::Command\->new( cmd => [\*(Aqtrue\*(Aq] );
\&
\&   exit_is_num($cmd, 0);
\&   exit_is_num($cmd, 0, \*(Aqexit_is_num: true, 0\*(Aq);
\&   $cmd\->exit_is_num(0);
\&   $cmd\->exit_is_num(0, \*(Aqexit_is_num: true, 0\*(Aq);
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
All of the test functions mentioned below are exported by default.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&   my $test_cmd_obj = Test::Command\->new( cmd => $cmd )
.Ve
.PP
This constructor creates and returns a \f(CW\*(C`Test::Command\*(C'\fR object. Use this to test
multiple aspects of a single command execution while avoiding repeatedly running
commands which are slow or resource intensive.
.PP
The \f(CW\*(C`cmd\*(C'\fR parameter can accept either a string or an array reference for its
value. The value is dereferenced if necessary and passed directly to the
\&\f(CW\*(C`system\*(C'\fR builtin.
.SS "run"
.IX Subsection "run"
.Vb 1
\&   $test_cmd_obj\->run;
.Ve
.PP
This instance method forces the execution of the command specified by the
invocant.
.PP
You only need to call this when you wish to re-run a command since the first
test method invoked will lazily execute the command if necessary. However, if
the state of your inputs has changed and you wish to re-run the command, you may
do so by invoking this method at any point between your tests.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "Testing Exit Status"
.IX Subsection "Testing Exit Status"
The test routines below compare against the exit status of the executed
command right shifted by 8 (that is, \f(CW\*(C`$? >> 8\*(C'\fR).
.PP
\fIexit_value\fR
.IX Subsection "exit_value"
.PP
.Vb 1
\&   exit_value($cmd)
.Ve
.PP
Return the exit status of the command. Useful for performing arbitrary tests
not covered by this module.
.PP
\fIexit_is_num\fR
.IX Subsection "exit_is_num"
.PP
.Vb 1
\&   exit_is_num($cmd, $exp_num, $name)
.Ve
.PP
If the exit status of the command is numerically equal to the expected number,
this passes. Otherwise it fails.
.PP
\fIexit_isnt_num\fR
.IX Subsection "exit_isnt_num"
.PP
.Vb 1
\&   exit_isnt_num($cmd, $unexp_num, $name)
.Ve
.PP
If the exit status of the command is \fBnot\fR numerically equal to the given
number, this passes. Otherwise it fails.
.PP
\fIexit_cmp_ok\fR
.IX Subsection "exit_cmp_ok"
.PP
.Vb 1
\&   exit_cmp_ok($cmd, $op, $operand, $name)
.Ve
.PP
If the exit status of the command is compared with the given operand using
the given operator, and that operation returns true, this passes. Otherwise
it fails.
.PP
\fIexit_is_defined\fR
.IX Subsection "exit_is_defined"
.PP
.Vb 1
\&   exit_is_defined($cmd, $name)
.Ve
.PP
If the exit status of the command is defined, this passes. Otherwise it
fails. A defined exit status indicates that the command exited normally
by calling \fIexit()\fR or running off the end of the program.
.PP
\fIexit_is_undef\fR
.IX Subsection "exit_is_undef"
.PP
.Vb 1
\&   exit_is_undef($cmd, $name)
.Ve
.PP
If the exit status of the command is not defined, this passes. Otherwise it
fails. An undefined exit status indicates that the command likely exited
due to a signal.
.SS "Testing Terminating Signal"
.IX Subsection "Testing Terminating Signal"
The test routines below compare against the lower 8 bits of the exit status
of the executed command.
.PP
\fIsignal_value\fR
.IX Subsection "signal_value"
.PP
.Vb 1
\&   signal_value($cmd)
.Ve
.PP
Return the signal code of the command. Useful for performing arbitrary tests
not covered by this module.
.PP
\fIsignal_is_num\fR
.IX Subsection "signal_is_num"
.PP
.Vb 1
\&   signal_is_num($cmd, $exp_num, $name)
.Ve
.PP
If the terminating signal of the command is numerically equal to the expected number,
this passes. Otherwise it fails.
.PP
\fIsignal_isnt_num\fR
.IX Subsection "signal_isnt_num"
.PP
.Vb 1
\&   signal_isnt_num($cmd, $unexp_num, $name)
.Ve
.PP
If the terminating signal of the command is \fBnot\fR numerically equal to the given
number, this passes. Otherwise it fails.
.PP
\fIsignal_cmp_ok\fR
.IX Subsection "signal_cmp_ok"
.PP
.Vb 1
\&   signal_cmp_ok($cmd, $op, $operand, $name)
.Ve
.PP
If the terminating signal of the command is compared with the given operand
using the given operator, and that operation returns true, this passes. Otherwise
it fails.
.PP
\fIsignal_is_defined\fR
.IX Subsection "signal_is_defined"
.PP
.Vb 1
\&   signal_is_defined($cmd, $name)
.Ve
.PP
If the terminating signal of the command is defined, this passes. Otherwise it
fails. A defined signal indicates that the command likely exited due to a
signal.
.PP
\fIsignal_is_undef\fR
.IX Subsection "signal_is_undef"
.PP
.Vb 1
\&   signal_is_undef($cmd, $name)
.Ve
.PP
If the terminating signal of the command is not defined, this passes.
Otherwise it fails. An undefined signal indicates that the command exited
normally by calling \fIexit()\fR or running off the end of the program.
.SS "Testing \s-1STDOUT\s0"
.IX Subsection "Testing STDOUT"
Except where specified, the test routines below treat \s-1STDOUT\s0 as a single slurped
string.
.PP
\fIstdout_value\fR
.IX Subsection "stdout_value"
.PP
.Vb 1
\&   stdout_value($cmd)
.Ve
.PP
Return the \s-1STDOUT\s0 of the command. Useful for performing arbitrary tests
not covered by this module.
.PP
\fIstdout_file\fR
.IX Subsection "stdout_file"
.PP
.Vb 1
\&   stdout_file($cmd)
.Ve
.PP
Return the file name containing the \s-1STDOUT\s0 of the command. Useful for
performing arbitrary tests not covered by this module.
.PP
\fIstdout_is_eq\fR
.IX Subsection "stdout_is_eq"
.PP
.Vb 1
\&   stdout_is_eq($cmd, $exp_string, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command is equal (compared using \f(CW\*(C`eq\*(C'\fR) to the expected
string, then this passes. Otherwise it fails.
.PP
\fIstdout_isnt_eq\fR
.IX Subsection "stdout_isnt_eq"
.PP
.Vb 1
\&   stdout_isnt_eq($cmd, $unexp_string, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command is \fBnot\fR equal (compared using \f(CW\*(C`eq\*(C'\fR) to the
given string, this passes. Otherwise it fails.
.PP
\fIstdout_is_num\fR
.IX Subsection "stdout_is_num"
.PP
.Vb 1
\&   stdout_is_num($cmd, $exp_num, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command is equal (compared using \f(CW\*(C`==\*(C'\fR) to the expected
number, then this passes. Otherwise it fails.
.PP
\fIstdout_isnt_num\fR
.IX Subsection "stdout_isnt_num"
.PP
.Vb 1
\&   stdout_isnt_num($cmd, $unexp_num, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command is \fBnot\fR equal (compared using \f(CW\*(C`==\*(C'\fR) to the
given number, this passes. Otherwise it fails.
.PP
\fIstdout_like\fR
.IX Subsection "stdout_like"
.PP
.Vb 1
\&   stdout_like($cmd, $exp_regex, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command matches the expected regular expression,
this passes. Otherwise it fails.
.PP
\fIstdout_unlike\fR
.IX Subsection "stdout_unlike"
.PP
.Vb 1
\&   stdout_unlike($cmd, $unexp_regex, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command does \fBnot\fR match the given regular
expression, this passes. Otherwise it fails.
.PP
\fIstdout_cmp_ok\fR
.IX Subsection "stdout_cmp_ok"
.PP
.Vb 1
\&   stdout_cmp_ok($cmd, $op, $operand, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command is compared with the given operand using
the given operator, and that operation returns true, this passes. Otherwise
it fails.
.PP
\fIstdout_is_file\fR
.IX Subsection "stdout_is_file"
.PP
.Vb 1
\&   stdout_is_file($cmd, $exp_file, $name)
.Ve
.PP
If the \s-1STDOUT\s0 of the command is equal (compared using \f(CW\*(C`eq\*(C'\fR) to the contents of
the given file, then this passes. Otherwise it fails. Note that this comparison
is performed line by line, rather than slurping the entire file.
.SS "Testing \s-1STDERR\s0"
.IX Subsection "Testing STDERR"
Except where specified, the test routines below treat \s-1STDERR\s0 as a single slurped
string.
.PP
\fIstderr_value\fR
.IX Subsection "stderr_value"
.PP
.Vb 1
\&   stderr_value($cmd)
.Ve
.PP
Return the \s-1STDERR\s0 of the command. Useful for performing arbitrary tests
not covered by this module.
.PP
\fIstderr_file\fR
.IX Subsection "stderr_file"
.PP
.Vb 1
\&   stderr_file($cmd)
.Ve
.PP
Return the file name containing the \s-1STDERR\s0 of the command. Useful for
performing arbitrary tests not covered by this module.
.PP
\fIstderr_is_eq\fR
.IX Subsection "stderr_is_eq"
.PP
.Vb 1
\&   stderr_is_eq($cmd, $exp_string, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command is equal (compared using \f(CW\*(C`eq\*(C'\fR) to the expected
string, then this passes. Otherwise it fails.
.PP
\fIstderr_isnt_eq\fR
.IX Subsection "stderr_isnt_eq"
.PP
.Vb 1
\&   stderr_isnt_eq($cmd, $unexp_string, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command is \fBnot\fR equal (compared using \f(CW\*(C`eq\*(C'\fR) to the
given string, this passes. Otherwise it fails.
.PP
\fIstderr_is_num\fR
.IX Subsection "stderr_is_num"
.PP
.Vb 1
\&   stderr_is_num($cmd, $exp_num, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command is equal (compared using \f(CW\*(C`==\*(C'\fR) to the expected
number, then this passes. Otherwise it fails.
.PP
\fIstderr_isnt_num\fR
.IX Subsection "stderr_isnt_num"
.PP
.Vb 1
\&   stderr_isnt_num($cmd, $unexp_num, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command is \fBnot\fR equal (compared using \f(CW\*(C`==\*(C'\fR) to the
given number, this passes. Otherwise it fails.
.PP
\fIstderr_like\fR
.IX Subsection "stderr_like"
.PP
.Vb 1
\&   stderr_like($cmd, $exp_regex, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command matches the expected regular expression,
this passes. Otherwise it fails.
.PP
\fIstderr_unlike\fR
.IX Subsection "stderr_unlike"
.PP
.Vb 1
\&   stderr_unlike($cmd, $unexp_regex, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command does \fBnot\fR match the given regular
expression, this passes. Otherwise it fails.
.PP
\fIstderr_cmp_ok\fR
.IX Subsection "stderr_cmp_ok"
.PP
.Vb 1
\&   stderr_cmp_ok($cmd, $op, $operand, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command is compared with the given operand using
the given operator, and that operation returns true, this passes. Otherwise
it fails.
.PP
\fIstderr_is_file\fR
.IX Subsection "stderr_is_file"
.PP
.Vb 1
\&   stderr_is_file($cmd, $exp_file, $name)
.Ve
.PP
If the \s-1STDERR\s0 of the command is equal (compared using \f(CW\*(C`eq\*(C'\fR) to the contents of
the given file, then this passes. Otherwise it fails. Note that this comparison
is performed line by line, rather than slurping the entire file.
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel B. Boorstein, \f(CW\*(C`<danboo at cpan.org>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-test\-command at rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test\-Command <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Command>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Test::Command
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/Test\-Command <http://annocpan.org/dist/Test-Command>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/Test\-Command <http://cpanratings.perl.org/d/Test-Command>
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test\-Command <http://rt.cpan.org/NoAuth/Bugs.html?Dist=Test-Command>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/Test\-Command <http://search.cpan.org/dist/Test-Command>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Test::Builder by Michael Schwern allowed me to focus on the specifics related to
testing system commands by making it easy to produce proper test output.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007 Daniel B. Boorstein, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "DEVELOPMENT IDEAS"
.IX Header "DEVELOPMENT IDEAS"
.IP "\(bu" 3
create a tool that produces test scripts given a list of commands to run
.IP "\(bu" 3
optionally save the temp files with \s-1STDOUT\s0 and \s-1STDERR\s0 for user debugging
.IP "\(bu" 3
if user defines all options and sample arguments to basic command
.RS 3
.IP "\(bu" 3
create tool to enumerate all possible means of calling program
.IP "\(bu" 3
allow testing with randomized/permuted/collapsed opts and args
.RE
.RS 3
.RE
.IP "\(bu" 3
potential test functions:
.RS 3
.IP "\(bu" 3
time_lt($cmd, \f(CW$seconds\fR)
.IP "\(bu" 3
time_gt($cmd, \f(CW$seconds\fR)
.IP "\(bu" 3
stdout_line_custom($cmd, \e&code)
.IP "\(bu" 3
stderr_line_custom($cmd, \e&code)
.RE
.RS 3
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Builder provides the testing methods used in this module.
.PP
Test::Builder::Module is the superclass of this module.
