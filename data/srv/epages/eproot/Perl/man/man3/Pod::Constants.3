.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Constants 3"
.TH Constants 3 "2007-10-21" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Constants \- Include constants from POD
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use vars qw($myvar $VERSION @myarray $html %myhash);
\&
\& use Pod::Constants \-trim => 1,
\&     \*(AqPod Section Name\*(Aq => \e$myvar,
\&     \*(AqVersion\*(Aq => sub { eval },
\&     \*(AqSome list\*(Aq => \e@myarray,
\&     html => \e$html,
\&     \*(AqSome hash\*(Aq => \e%myhash;
\&
\& =head2 Pod Section Name
\&
\& This string will be loaded into $myvar
\&
\& =head2 Version
\&
\& # This is an example of using a closure.  $_ is set to the
\& # contents of the paragraph.  In this example, "eval" is
\& # used to execute this code at run time.
\& $VERSION = 0.16;
\&
\& =head2 Some list
\&
\& Each line from this section of the file
\& will be placed into a seperate array element.
\& For example, this is $myarray[2].
\&
\& =head2 Some hash
\&
\& This text will not go into the hash, because
\& it doesn\*(Aqt look like a definition list.
\&     key1 => Some value (this will go into the hash)
\&     var2 => Some Other value (so will this)
\&     wtf = This won\*(Aqt make it in.
\&
\& =head2 %myhash\*(Aqs value after the above:
\&
\&    ( key1 => "Some value (this will go into the hash)",
\&      var2 => "Some Other value (so will this)"          )
\&
\& =begin html <p>This text will be in $html</p>
\&
\& =cut
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to specify those constants that should be
documented in your \s-1POD\s0, and pull them out a run time in a fairly
arbitrary fashion.
.PP
Pod::Constants uses Pod::Parser to do the parsing of the source file.
It has to open the source file it is called from, and does so directly
either by lookup in \f(CW%INC\fR or by assuming it is \f(CW$0\fR if the caller is
\&\*(L"main\*(R" (or it can't find \f(CW%INC\fR{\fIcaller()\fR})
.SS "\s-1ARBITARY\s0 \s-1DECISIONS\s0"
.IX Subsection "ARBITARY DECISIONS"
I have made this code only allow the \*(L"Pod Section Name\*(R" to match
`headN', `item', `for' and `begin' \s-1POD\s0 sections.  If you have a good
reason why you think it should match other \s-1POD\s0 sections, drop me a
line and if I'm convinced I'll put it in the standard version.
.PP
For `for' and `begin' sections, only the first word is counted as
being a part of the specifier, as opposed to `headN' and `item', where
the entire rest of the line counts.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "import(@args)"
.IX Subsection "import(@args)"
This function is called when we are \*(L"use\*(R"'d.  It determines the source
file by inspecting the value of \fIcaller()\fR or \f(CW$0\fR.
.PP
The form of \f(CW@args\fR is \s-1HOOK\s0 => \f(CW$where\fR.
.PP
\&\f(CW$where\fR may be a scalar reference, in which case the contents of the
\&\s-1POD\s0 section called \*(L"\s-1HOOK\s0\*(R" will be loaded into \f(CW$where\fR.
.PP
\&\f(CW$where\fR may be an array reference, in which case the contents of the
array will be the contents of the \s-1POD\s0 section called \*(L"\s-1HOOK\s0\*(R", split
into lines.
.PP
\&\f(CW$where\fR may be a hash reference, in which case any lines with a \*(L"=>\*(R"
symbol present will have everything on the left have side of the =>
operator as keys and everything on the right as values.  You do not
need to quote either, nor have trailing commas at the end of the
lines.
.PP
\&\f(CW$where\fR may be a code reference (sub { }), in which case the sub is
called when the hook is encountered.  \f(CW$_\fR is set to the value of the
\&\s-1POD\s0 paragraph.
.PP
You may also specify the behaviour of whitespace trimming; by default,
no trimming is done except on the \s-1HOOK\s0 names.  Setting \*(L"\-trim => 1\*(R"
turns on a package \*(L"global\*(R" (until the next time import is called)
that will trim the \f(CW$_\fR sent for processing by the hook processing
function (be it a given function, or the built-in array/hash
splitters) for leading and trailing whitespace.
.PP
The name of \s-1HOOK\s0 is matched against any \*(L"=head1\*(R", \*(L"=head2\*(R", \*(L"=item\*(R",
\&\*(L"=for\*(R", \*(L"=begin\*(R" value.  If you specify the special hooknames \*(L"*item\*(R",
\&\*(L"*head1\*(R", etc, then you will get a function that is run for every
.PP
Note that the supplied functions for array and hash splitting are
exactly equivalent to fairly simple Perl blocks:
.PP
Array:
.PP
.Vb 1
\&  HOOK => sub { @array = split /\en/, $_ }
.Ve
.PP
Hash:
.PP
.Vb 9
\&  HOOK => sub {
\&  %hash =
\&      (map { map { s/^\es+|\es+$//g; $_ } split /=>/, $_ }
\&            (grep m/^
\&                    ( (?:[^=]|=[^>])+ )   # scan up to "=>"
\&                    =>
\&                    ( (?:[^=]|=[^>])+ =? )# don\*(Aqt allow more "=>"\*(Aqs
\&                    $/x, split /\en/, $_));
\&  }
.Ve
.PP
Well, they're simple if you can grok map, a regular expression like
that and a functional programming style.  If you can't I'm sure it is
probably voodoo to you.
.PP
Here's the procedural equivalent:
.PP
.Vb 9
\&  HOOK => sub {
\&     for my $line (split /\en/, $_) {
\&         my ($key, $value, $junk) = split /=>/, $line;
\&         next if $junk;
\&         $key =~ s/^\es+|\es+$//g
\&         $value =~ s/^\es+|\es+$//g
\&         $hash{$key} = $value;
\&     }
\&  },
.Ve
.ie n .SS "import_from_file($filename, @args)"
.el .SS "import_from_file($filename, \f(CW@args\fP)"
.IX Subsection "import_from_file($filename, @args)"
Very similar to straight \*(L"import\*(R", but you specify the source filename
explicitly.
.SS "add_hook(\s-1NAME\s0 => value)"
.IX Subsection "add_hook(NAME => value)"
This function adds another hook, it is useful for dynamic updating of
parsing through the document.
.PP
For an example, please see t/01\-constants.t in the source
distribution.  More detailed examples will be added in a later
release.
.SS "delete_hook(@list)"
.IX Subsection "delete_hook(@list)"
Deletes the named hooks.  Companion function to add_hook
.SS "\s-1CLOSURES\s0 \s-1AS\s0 \s-1DESTINATIONS\s0"
.IX Subsection "CLOSURES AS DESTINATIONS"
If the given value is a ref \s-1CODE\s0, then that function is called, with
\&\f(CW$_\fR set to the value of the paragraph.  This can be very useful for
applying your own custom mutations to the \s-1POD\s0 to change it from human
readable text into something your program can use.
.PP
After I added this function, I just kept on thinking of cool uses for
it.  The nice, succinct code you can make with it is one of
Pod::Constant's strongest features.
.PP
Below are some examples.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Module Makefile.PL maintenance"
.IX Subsection "Module Makefile.PL maintenance"
Tired of keeping those module Makefile.PL's up to date?  Note: This
method seems to break dh-make-perl.
.SS "Example Makefile.PL"
.IX Subsection "Example Makefile.PL"
.Vb 8
\& eval "use Pod::Constants";
\& ($Pod::Constants::VERSION >= 0.11)
\&     or die <<EOF
\& ####
\& ####  ERROR: This module requires Pod::Constants 0.11 or
\& ####  higher to be installed.
\& ####
\& EOF
\&
\& my ($VERSION, $NAME, $PREREQ_PM, $ABSTRACT, $AUTHOR);
\& Pod::Constants::import_from_file 
\&     (
\&      \*(AqMyTestModule.pm\*(Aq,
\&      \*(AqMODULE RELEASE\*(Aq => sub { ($VERSION) = m/(\ed+\e.\ed+)/ },
\&      \*(AqDEPENDANCIES\*(Aq => ($PREREQ_PM = { }),
\&       \-trim => 1,
\&      \*(AqNAME\*(Aq => sub { $ABSTRACT=$_; ($NAME) = m/(\eS+)/ },
\&      \*(AqAUTHOR\*(Aq => \e$AUTHOR,
\&     );
\&
\& WriteMakefile
\&     (
\&      \*(AqNAME\*(Aq            => $NAME,
\&      \*(AqPREREQ_PM\*(Aq        => $PREREQ_PM,
\&      \*(AqVERSION\*(Aq          => $VERSION,
\&      ($] >= 5.005 ?    ## Add these new keywords supported since 5.005
\&       (ABSTRACT         => $ABSTRACT,
\&        AUTHOR           => $AUTHOR) : ()),
\&     );
.Ve
.SS "Corresponding Module"
.IX Subsection "Corresponding Module"
.Vb 1
\& =head1 NAME
\&
\& MyTestModule \- Demonstrate Pod::Constant\*(Aqs Makefile.PL usefulness
\&
\& =head2 MODULE RELEASE
\&
\& This is release 1.05 of this module.
\&
\& =head2 DEPENDANCIES
\&
\& The following modules are required to make this module:
\&
\&    Some::Module => 0.02
\&
\& =head2 AUTHOR
\&
\& Ima Twat <ima@twat.name>
\&
\& =cut
\&
\& use vars qw($VERSION);
\& use Pod::Constants \-trim => 1,
\&     \*(AqMODULE RELEASE\*(Aq => sub { ($VERSION) = m/(\ed+\e.\ed+) or die };
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Sam Vilain, <samv@cpan.org>
.SH "BUGS/TODO"
.IX Header "BUGS/TODO"
I keep thinking it would be nice to be able to import an =item list
into an array or something, eg for a program argument list.  But I'm
not too sure how it would be all that useful in practice; you'd end up
putting the function names for callbacks in the pod or something
(perhaps not all that bad).
.PP
Would this be useful?
.PP
.Vb 1
\& Pod::Constants::import(Foo::SECTION => \e$myvar);
.Ve
.PP
Debug output is not very readable
.SH "PATCHES WELCOME"
.IX Header "PATCHES WELCOME"
If you have any suggestions for enhancements, they are much more likely
to happen if you submit them as a patch to the distribution.
.PP
Source is kept at
.PP
.Vb 1
\&  git://utsl.gen.nz/Pod\-Constants
.Ve
