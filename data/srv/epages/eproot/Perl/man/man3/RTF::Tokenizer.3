.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RTF::Tokenizer 3"
.TH RTF::Tokenizer 3 "2011-01-01" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RTF::Tokenizer \- Tokenize RTF
.SH "VERSION"
.IX Header "VERSION"
version 1.13
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Tokenizes \s-1RTF\s0
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use RTF::Tokenizer;
\&
\& # Create a tokenizer object
\&        my $tokenizer = RTF::Tokenizer\->new();
\&
\&        my $tokenizer = RTF::Tokenizer\->new( string => \*(Aq{\ertf1}\*(Aq  );
\&        my $tokenizer = RTF::Tokenizer\->new( string => \*(Aq{\ertf1}\*(Aq, note_escapes => 1 );
\&
\&        my $tokenizer = RTF::Tokenizer\->new( file   => \e*STDIN    );
\&        my $tokenizer = RTF::Tokenizer\->new( file   => \*(Aqlala.rtf\*(Aq );
\&        my $tokenizer = RTF::Tokenizer\->new( file   => \*(Aqlala.rtf\*(Aq, sloppy => 1 );
\&
\& # Populate it from a file
\&        $tokenizer\->read_file(\*(Aqfilename.txt\*(Aq);
\&
\& # Or a file handle
\&        $tokenizer\->read_file( \e*STDIN );
\&
\& # Or a string
\&        $tokenizer\->read_string( \*(Aq{\e*\esome rtf}\*(Aq );
\&
\& # Get the first token
\&        my ( $token_type, $argument, $parameter ) = $tokenizer\->get_token();
\&
\& # Ooops, that was wrong...
\&        $tokenizer\->put_token( \*(Aqcontrol\*(Aq, \*(Aqb\*(Aq, 1 );
.Ve
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
This documentation assumes some basic knowledge of \s-1RTF\s0.
If you lack that, go read The_RTF_Cookbook:
.PP
http://search.cpan.org/search?dist=RTF\-Writer <http://search.cpan.org/search?dist=RTF-Writer>
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Instantiates an RTF::Tokenizer object.
.PP
\&\fBNamed parameters\fR:
.PP
\&\f(CW\*(C`file\*(C'\fR \- calls the \f(CW\*(C`read_file\*(C'\fR method with the value provided after instantiation
.PP
\&\f(CW\*(C`string\*(C'\fR \- calls the \f(CW\*(C`read_string\*(C'\fR method with the value provided after instantiation
.PP
\&\f(CW\*(C`note_escapes\*(C'\fR \- boolean \- whether to give \s-1RTF\s0 Escapes a token type of \f(CW\*(C`escape\*(C'\fR (true) or \f(CW\*(C`control\*(C'\fR (false)
.PP
\&\f(CW\*(C`sloppy\*(C'\fR \- boolean \- whether or not to allow some illegal but common \s-1RTF\s0 sequences found 'in the wild'. As of \f(CW1.08\fR, this currently only allows
control words with a numeric argument to have a text field right after with
no delimiter, like:
.PP
.Vb 1
\& \econtrol1Plaintext
.Ve
.PP
but this may change in future releases.
.SS "read_string( \s-1STRING\s0 )"
.IX Subsection "read_string( STRING )"
Appends the string to the tokenizer-object's buffer
(earlier versions would over-write the buffer \-
this version does not).
.SS "read_file( \e*FILEHANDLE )"
.IX Subsection "read_file( *FILEHANDLE )"
.ie n .SS "read_file( $IO_File_object )"
.el .SS "read_file( \f(CW$IO_File_object\fP )"
.IX Subsection "read_file( $IO_File_object )"
.SS "read_file( 'filename' )"
.IX Subsection "read_file( 'filename' )"
Appends a chunk of data from the filehandle to the buffer,
and remembers the filehandle, so if you ask for a token,
and the buffer is empty, it'll try and read the next line
from the file (earlier versions would over-write the buffer \-
this version does not).
.PP
This chunk is 500 characters, and then whatever is left until
the next occurrence of the \s-1IRS\s0 (a newline character in this case).
If for whatever reason, you want to change that number to something
else, use \f(CW\*(C`initial_read\*(C'\fR.
.SS "\fIget_token()\fP"
.IX Subsection "get_token()"
Returns the next token as a three-item list: 'type', 'argument', 'parameter'.
Token is one of: \f(CW\*(C`text\*(C'\fR, \f(CW\*(C`control\*(C'\fR, \f(CW\*(C`group\*(C'\fR, \f(CW\*(C`escape\*(C'\fR or \f(CW\*(C`eof\*(C'\fR.
.ie n .IP """text""" 4
.el .IP "\f(CWtext\fR" 4
.IX Item "text"
\&'type' is set to 'text'. 'argument' is set to the text itself. 'parameter'
is left blank. \s-1NOTE:\s0 \f(CW\*(C`\e{\*(C'\fR, \f(CW\*(C`\e}\*(C'\fR, and \f(CW\*(C`\e\e\*(C'\fR are all returned as control words,
rather than rendered as text for you, as are \f(CW\*(C`\e_\*(C'\fR, \f(CW\*(C`\e\-\*(C'\fR and friends.
.ie n .IP """control""" 4
.el .IP "\f(CWcontrol\fR" 4
.IX Item "control"
\&'type' is 'control'. 'argument' is the control word or control symbol.
\&'parameter' is the control word's parameter if it has one \- this will
be numeric, \s-1EXCEPT\s0 when 'argument' is a literal ', in which case it
will be a two-letter hex string.
.ie n .IP """group""" 4
.el .IP "\f(CWgroup\fR" 4
.IX Item "group"
\&'type' is 'group'. If it's the beginning of an \s-1RTF\s0 group, then
\&'argument' is 1, else if it's the end, argument is 0. 'parameter'
is not set.
.ie n .IP """eof""" 4
.el .IP "\f(CWeof\fR" 4
.IX Item "eof"
End of file reached. 'type' is 'eof'. 'argument' is 1. 'parameter' is
0.
.ie n .IP """escape""" 4
.el .IP "\f(CWescape\fR" 4
.IX Item "escape"
If you specifically turn on this functionality, you'll get an
\&\f(CW\*(C`escape\*(C'\fR type, which is identical to \f(CW\*(C`control\*(C'\fR, only, it's
only returned for escapes.
.SS "put_token( type, token, argument )"
.IX Subsection "put_token( type, token, argument )"
Adds an item to the token cache, so that the next time you
call get_token, the arguments you passed here will be returned.
We don't check any of the values, so use this carefully. This
is on a first in last out basis.
.SS "sloppy( [bool] )"
.IX Subsection "sloppy( [bool] )"
Decides whether we allow some types of broken \s-1RTF\s0. See \f(CW\*(C`new()\*(C'\fR's docs
for a little more explanation about this. Pass it 1 to turn it on, 0 to
turn it off. This will always return undef.
.SS "initial_read( [number] )"
.IX Subsection "initial_read( [number] )"
Don't call this unless you actually have a good reason. When
the Tokenizer reads from a file, it first attempts to work out
what the correct input record-seperator should be, by reading
some characters from the file handle. This value starts off
as 512, which is twice the amount of characters that version 1.7
of the \s-1RTF\s0 specification says you should go before including a
line feed if you're writing \s-1RTF\s0.
.PP
Called with no argument, this returns the current value of the
number of characters we're going to read. Called with a numeric
argument, it sets the number of characters we'll read.
.PP
You really don't need to use this method.
.SS "debug( [number] )"
.IX Subsection "debug( [number] )"
Returns (non-destructively) the next 50 characters from the buffer,
\&\s-1OR\s0, the number of characters you specify. Printing these to \s-1STDERR\s0,
causing fatal errors, and the like, are left as an exercise to the
programmer.
.PP
Note the part about 'from the buffer'. It really means that, which means
if there's nothing in the buffer, but still stuff we're reading from a
file it won't be shown. Chances are, if you're using this function, you're
debugging. There's an internal method called \f(CW\*(C`_get_line\*(C'\fR, which is called
without arguments (\f(CW\*(C`$self\-\*(C'\fR\fI_get_line()\fR>) that's how we get more stuff into
the buffer when we're reading from filehandles. There's no guarentee that'll
stay, or will always work that way, but, if you're debugging, that shouldn't
matter.
.SH "NOTES"
.IX Header "NOTES"
To avoid intrusively deep parsing, if an alternative \s-1ASCII\s0
representation is available for a Unicode entity, and that
\&\s-1ASCII\s0 representation contains \f(CW\*(C`{\*(C'\fR, or \f(CW\*(C`\e\*(C'\fR, by themselves, things
will go \fIfunky\fR. But I'm not convinced either of those is
allowed by the spec.
.SH "AUTHOR"
.IX Header "AUTHOR"
Pete Sergeant \*(-- \f(CW\*(C`pete@clueball.com\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyright \fBPete Sergeant\fR.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
