.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Report::Dispatcher::LogDispatch 3"
.TH Log::Report::Dispatcher::LogDispatch 3 "2016-10-21" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Report::Dispatcher::LogDispatch \- send messages to Log::Dispatch back\-end
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Log::Report::Dispatcher::LogDispatch
\&   is a Log::Report::Dispatcher
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Log::Dispatch::File;
\& dispatcher Log::Dispatch::File => \*(Aqlogger\*(Aq, accept => \*(AqNOTICE\-\*(Aq
\&   , filename => \*(Aqlogfile\*(Aq, to_level => [ \*(AqALERT\-\*(Aq => \*(Aqerr\*(Aq ];
\&
\& # disable default dispatcher
\& dispatcher close => \*(Aqlogger\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This dispatchers produces output to and \f(CW\*(C`Log::Dispatch\*(C'\fR back-end.
(which will \s-1NOT\s0 be automatically installed for you).
.PP
The \s-1REASON\s0 for a message often uses names which are quite similar to the
log-levels used by Log::Dispatch.  However: they have a different
approach.  The \s-1REASON\s0 of Log::Report limits the responsibility of the
programmer to indicate the cause of the message: whether it was able to
handle a certain situation.  The Log::Dispatch levels are there for the
user's of the program.  However: the programmer does not known anything
about the application (in the general case).  This is cause of much of
the trickery in Perl programs.
.PP
The default translation table is list below.  You can change the mapping
using new(to_level).  See example in \s-1SYNOPSIS\s0.
.PP
Extends \*(L"\s-1DESCRIPTION\s0\*(R" in Log::Report::Dispatcher.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\s0\*(R" in Log::Report::Dispatcher.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in Log::Report::Dispatcher.
.ie n .IP "$obj\->\fBclose\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclose\fR()" 4
.IX Item "$obj->close()"
Inherited, see \*(L"Constructors\*(R" in Log::Report::Dispatcher
.ie n .IP "Log::Report::Dispatcher::LogDispatch\->\fBnew\fR($type, $name, %options)" 4
.el .IP "Log::Report::Dispatcher::LogDispatch\->\fBnew\fR($type, \f(CW$name\fR, \f(CW%options\fR)" 4
.IX Item "Log::Report::Dispatcher::LogDispatch->new($type, $name, %options)"
The Log::Dispatch infrastructure has quite a large number of output
TYPEs, each extending the Log::Dispatch::Output base-class.  You
do not create these objects yourself: Log::Report is doing it for you.
.Sp
The Log::Dispatch back-ends are very careful with validating their
parameters, so you will need to restrict the options to what is supported
for the specific back-end.  See their respective manual-pages.  The errors
produced by the back-ends quite horrible and untranslated, sorry.
.Sp
.Vb 10
\& \-Option       \-\-Defined in             \-\-Default
\&  accept         Log::Report::Dispatcher  depend on mode
\&  callbacks                               []
\&  charset        Log::Report::Dispatcher  <undef>
\&  format_reason  Log::Report::Dispatcher  \*(AqLOWERCASE\*(Aq
\&  locale         Log::Report::Dispatcher  <system locale>
\&  max_level                               undef
\&  min_level                               debug
\&  mode           Log::Report::Dispatcher  \*(AqNORMAL\*(Aq
\&  to_level                                []
.Ve
.RS 4
.IP "accept => \s-1REASONS\s0" 2
.IX Item "accept => REASONS"
.PD 0
.IP "callbacks => CODE|ARRAY\-of\-CODE" 2
.IX Item "callbacks => CODE|ARRAY-of-CODE"
.PD
See Log::Dispatch::Output.
.IP "charset => \s-1CHARSET\s0" 2
.IX Item "charset => CHARSET"
.PD 0
.IP "format_reason => '\s-1UPPERCASE\s0'|'\s-1LOWERCASE\s0'|'\s-1UCFIRST\s0'|'\s-1IGNORE\s0'|CODE" 2
.IX Item "format_reason => 'UPPERCASE'|'LOWERCASE'|'UCFIRST'|'IGNORE'|CODE"
.IP "locale => \s-1LOCALE\s0" 2
.IX Item "locale => LOCALE"
.IP "max_level => \s-1LEVEL\s0" 2
.IX Item "max_level => LEVEL"
.PD
Like \f(CW\*(C`min_level\*(C'\fR.
.IP "min_level => \s-1LEVEL\s0" 2
.IX Item "min_level => LEVEL"
Restrict the messages which are passed through based on the \s-1LEVEL\s0,
so after the reason got translated into a Log::Dispatch compatible
\&\s-1LEVEL\s0.  The default will use Log::Report restrictions only.
.IP "mode => '\s-1NORMAL\s0'|'\s-1VERBOSE\s0'|'\s-1ASSERT\s0'|'\s-1DEBUG\s0'|0..3" 2
.IX Item "mode => 'NORMAL'|'VERBOSE'|'ASSERT'|'DEBUG'|0..3"
.PD 0
.IP "to_level => ARRAY-of-PAIRS" 2
.IX Item "to_level => ARRAY-of-PAIRS"
.PD
See \fIreasonToLevel()\fR.
.RE
.RS 4
.RE
.SS "Accessors"
.IX Subsection "Accessors"
Extends \*(L"Accessors\*(R" in Log::Report::Dispatcher.
.ie n .IP "$obj\->\fBbackend\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBbackend\fR()" 4
.IX Item "$obj->backend()"
Returns the Log::Dispatch::Output object which is used for logging.
.ie n .IP "$obj\->\fBisDisabled\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDisabled\fR()" 4
.IX Item "$obj->isDisabled()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBmode\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmode\fR()" 4
.IX Item "$obj->mode()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBneeds\fR( [$reason] )" 4
.el .IP "\f(CW$obj\fR\->\fBneeds\fR( [$reason] )" 4
.IX Item "$obj->needs( [$reason] )"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.SS "Logging"
.IX Subsection "Logging"
Extends \*(L"Logging\*(R" in Log::Report::Dispatcher.
.ie n .IP "$obj\->\fBaddSkipStack\fR(@CODE)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSkipStack\fR(@CODE)" 4
.IX Item "$obj->addSkipStack(@CODE)"
.PD 0
.IP "Log::Report::Dispatcher::LogDispatch\->\fBaddSkipStack\fR(@CODE)" 4
.IX Item "Log::Report::Dispatcher::LogDispatch->addSkipStack(@CODE)"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBcollectLocation\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcollectLocation\fR()" 4
.IX Item "$obj->collectLocation()"
.PD 0
.IP "Log::Report::Dispatcher::LogDispatch\->\fBcollectLocation\fR()" 4
.IX Item "Log::Report::Dispatcher::LogDispatch->collectLocation()"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBcollectStack\fR( [$maxdepth] )" 4
.el .IP "\f(CW$obj\fR\->\fBcollectStack\fR( [$maxdepth] )" 4
.IX Item "$obj->collectStack( [$maxdepth] )"
.PD 0
.IP "Log::Report::Dispatcher::LogDispatch\->\fBcollectStack\fR( [$maxdepth] )" 4
.IX Item "Log::Report::Dispatcher::LogDispatch->collectStack( [$maxdepth] )"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBlog\fR(HASH\-$of\-%options, $reason, $message, $domain)" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR(HASH\-$of\-%options, \f(CW$reason\fR, \f(CW$message\fR, \f(CW$domain\fR)" 4
.IX Item "$obj->log(HASH-$of-%options, $reason, $message, $domain)"
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBreasonToLevel\fR($reason)" 4
.el .IP "\f(CW$obj\fR\->\fBreasonToLevel\fR($reason)" 4
.IX Item "$obj->reasonToLevel($reason)"
Returns a level which is understood by Log::Dispatch, based on
a translation table.  This can be changed with new(to_level).
.ie n .IP "$obj\->\fBskipStack\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBskipStack\fR()" 4
.IX Item "$obj->skipStack()"
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBstackTraceLine\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBstackTraceLine\fR(%options)" 4
.IX Item "$obj->stackTraceLine(%options)"
.PD 0
.IP "Log::Report::Dispatcher::LogDispatch\->\fBstackTraceLine\fR(%options)" 4
.IX Item "Log::Report::Dispatcher::LogDispatch->stackTraceLine(%options)"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBtranslate\fR(HASH\-$of\-%options, $reason, $message)" 4
.el .IP "\f(CW$obj\fR\->\fBtranslate\fR(HASH\-$of\-%options, \f(CW$reason\fR, \f(CW$message\fR)" 4
.IX Item "$obj->translate(HASH-$of-%options, $reason, $message)"
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.SH "DETAILS"
.IX Header "DETAILS"
Extends \*(L"\s-1DETAILS\s0\*(R" in Log::Report::Dispatcher.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Log-Report distribution version 1.18,
built on October 21, 2016. Website: \fIhttp://perl.overmeer.net/log\-report/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
