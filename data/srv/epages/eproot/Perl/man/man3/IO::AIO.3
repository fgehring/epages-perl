.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "AIO 3"
.TH AIO 3 "2012-10-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::AIO \- Asynchronous Input/Output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use IO::AIO;
\&
\& aio_open "/etc/passwd", IO::AIO::O_RDONLY, 0, sub {
\&    my $fh = shift
\&       or die "/etc/passwd: $!";
\&    ...
\& };
\&
\& aio_unlink "/tmp/file", sub { };
\&
\& aio_read $fh, 30000, 1024, $buffer, 0, sub {
\&    $_[0] > 0 or die "read error: $!";
\& };
\&
\& # version 2+ has request and group objects
\& use IO::AIO 2;
\&
\& aioreq_pri 4; # give next request a very high priority
\& my $req = aio_unlink "/tmp/file", sub { };
\& $req\->cancel; # cancel request if still in queue
\&
\& my $grp = aio_group sub { print "all stats done\en" };
\& add $grp aio_stat "..." for ...;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements asynchronous I/O using whatever means your
operating system supports. It is implemented as an interface to \f(CW\*(C`libeio\*(C'\fR
(<http://software.schmorp.de/pkg/libeio.html>).
.PP
Asynchronous means that operations that can normally block your program
(e.g. reading from disk) will be done asynchronously: the operation
will still block, but you can do something else in the meantime. This
is extremely useful for programs that need to stay interactive even
when doing heavy I/O (\s-1GUI\s0 programs, high performance network servers
etc.), but can also be used to easily do operations in parallel that are
normally done sequentially, e.g. stat'ing many files, which is much faster
on a \s-1RAID\s0 volume or over \s-1NFS\s0 when you do a number of stat operations
concurrently.
.PP
While most of this works on all types of file descriptors (for
example sockets), using these functions on file descriptors that
support nonblocking operation (again, sockets, pipes etc.) is
very inefficient. Use an event loop for that (such as the \s-1EV\s0
module): \s-1IO::AIO\s0 will naturally fit into such an event loop itself.
.PP
In this version, a number of threads are started that execute your
requests and signal their completion. You don't need thread support
in perl, and the threads created by this module will not be visible
to perl. In the future, this module might make use of the native aio
functions available on many operating systems. However, they are often
not well-supported or restricted (GNU/Linux doesn't allow them on normal
files currently, for example), and they would only support aio_read and
aio_write, so the remaining functionality would have to be implemented
using threads anyway.
.PP
Although the module will work in the presence of other (Perl\-) threads,
it is currently not reentrant in any way, so use appropriate locking
yourself, always call \f(CW\*(C`poll_cb\*(C'\fR from within the same thread, or never
call \f(CW\*(C`poll_cb\*(C'\fR (or other \f(CW\*(C`aio_\*(C'\fR functions) recursively.
.SS "\s-1EXAMPLE\s0"
.IX Subsection "EXAMPLE"
This is a simple example that uses the \s-1EV\s0 module and loads
\&\fI/etc/passwd\fR asynchronously:
.PP
.Vb 3
\&   use Fcntl;
\&   use EV;
\&   use IO::AIO;
\&
\&   # register the IO::AIO callback with EV
\&   my $aio_w = EV::io IO::AIO::poll_fileno, EV::READ, \e&IO::AIO::poll_cb;
\&
\&   # queue the request to open /etc/passwd
\&   aio_open "/etc/passwd", IO::AIO::O_RDONLY, 0, sub {
\&      my $fh = shift
\&         or die "error while opening: $!";
\&
\&      # stat\*(Aqing filehandles is generally non\-blocking
\&      my $size = \-s $fh;
\&
\&      # queue a request to read the file
\&      my $contents;
\&      aio_read $fh, 0, $size, $contents, 0, sub {
\&         $_[0] == $size
\&            or die "short read: $!";
\&
\&         close $fh;
\&
\&         # file contents now in $contents
\&         print $contents;
\&
\&         # exit event loop and program
\&         EV::unloop;
\&      };
\&   };
\&
\&   # possibly queue up other requests, or open GUI windows,
\&   # check for sockets etc. etc.
\&
\&   # process events as long as there are some:
\&   EV::loop;
.Ve
.SH "REQUEST ANATOMY AND LIFETIME"
.IX Header "REQUEST ANATOMY AND LIFETIME"
Every \f(CW\*(C`aio_*\*(C'\fR function creates a request. which is a C data structure not
directly visible to Perl.
.PP
If called in non-void context, every request function returns a Perl
object representing the request. In void context, nothing is returned,
which saves a bit of memory.
.PP
The perl object is a fairly standard ref-to-hash object. The hash contents
are not used by \s-1IO::AIO\s0 so you are free to store anything you like in it.
.PP
During their existance, aio requests travel through the following states,
in order:
.IP "ready" 4
.IX Item "ready"
Immediately after a request is created it is put into the ready state,
waiting for a thread to execute it.
.IP "execute" 4
.IX Item "execute"
A thread has accepted the request for processing and is currently
executing it (e.g. blocking in read).
.IP "pending" 4
.IX Item "pending"
The request has been executed and is waiting for result processing.
.Sp
While request submission and execution is fully asynchronous, result
processing is not and relies on the perl interpreter calling \f(CW\*(C`poll_cb\*(C'\fR
(or another function with the same effect).
.IP "result" 4
.IX Item "result"
The request results are processed synchronously by \f(CW\*(C`poll_cb\*(C'\fR.
.Sp
The \f(CW\*(C`poll_cb\*(C'\fR function will process all outstanding aio requests by
calling their callbacks, freeing memory associated with them and managing
any groups they are contained in.
.IP "done" 4
.IX Item "done"
Request has reached the end of its lifetime and holds no resources anymore
(except possibly for the Perl object, but its connection to the actual
aio request is severed and calling its methods will either do nothing or
result in a runtime error).
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1QUICK\s0 \s-1OVERVIEW\s0"
.IX Subsection "QUICK OVERVIEW"
This section simply lists the prototypes most of the functions for
quick reference. See the following sections for function-by-function
documentation.
.PP
.Vb 10
\&   aio_wd $pathname, $callback\->($wd)
\&   aio_open $pathname, $flags, $mode, $callback\->($fh)
\&   aio_close $fh, $callback\->($status)
\&   aio_seek  $fh,$offset,$whence, $callback\->($offs)
\&   aio_read  $fh,$offset,$length, $data,$dataoffset, $callback\->($retval)
\&   aio_write $fh,$offset,$length, $data,$dataoffset, $callback\->($retval)
\&   aio_sendfile $out_fh, $in_fh, $in_offset, $length, $callback\->($retval)
\&   aio_readahead $fh,$offset,$length, $callback\->($retval)
\&   aio_stat  $fh_or_path, $callback\->($status)
\&   aio_lstat $fh, $callback\->($status)
\&   aio_statvfs $fh_or_path, $callback\->($statvfs)
\&   aio_utime $fh_or_path, $atime, $mtime, $callback\->($status)
\&   aio_chown $fh_or_path, $uid, $gid, $callback\->($status)
\&   aio_chmod $fh_or_path, $mode, $callback\->($status)
\&   aio_truncate $fh_or_path, $offset, $callback\->($status)
\&   aio_allocate $fh, $mode, $offset, $len, $callback\->($status)
\&   aio_fiemap $fh, $start, $length, $flags, $count, $cb\->(\e@extents)
\&   aio_unlink $pathname, $callback\->($status)
\&   aio_mknod $pathname, $mode, $dev, $callback\->($status)
\&   aio_link $srcpath, $dstpath, $callback\->($status)
\&   aio_symlink $srcpath, $dstpath, $callback\->($status)
\&   aio_readlink $pathname, $callback\->($link)
\&   aio_realpath $pathname, $callback\->($link)
\&   aio_rename $srcpath, $dstpath, $callback\->($status)
\&   aio_mkdir $pathname, $mode, $callback\->($status)
\&   aio_rmdir $pathname, $callback\->($status)
\&   aio_readdir $pathname, $callback\->($entries)
\&   aio_readdirx $pathname, $flags, $callback\->($entries, $flags)
\&      IO::AIO::READDIR_DENTS IO::AIO::READDIR_DIRS_FIRST
\&      IO::AIO::READDIR_STAT_ORDER IO::AIO::READDIR_FOUND_UNKNOWN
\&   aio_scandir $pathname, $maxreq, $callback\->($dirs, $nondirs)
\&   aio_load $pathname, $data, $callback\->($status)
\&   aio_copy $srcpath, $dstpath, $callback\->($status)
\&   aio_move $srcpath, $dstpath, $callback\->($status)
\&   aio_rmtree $pathname, $callback\->($status)
\&   aio_sync $callback\->($status)
\&   aio_syncfs $fh, $callback\->($status)
\&   aio_fsync $fh, $callback\->($status)
\&   aio_fdatasync $fh, $callback\->($status)
\&   aio_sync_file_range $fh, $offset, $nbytes, $flags, $callback\->($status)
\&   aio_pathsync $pathname, $callback\->($status)
\&   aio_msync $scalar, $offset = 0, $length = undef, flags = 0, $callback\->($status)
\&   aio_mtouch $scalar, $offset = 0, $length = undef, flags = 0, $callback\->($status)
\&   aio_mlock $scalar, $offset = 0, $length = undef, $callback\->($status)
\&   aio_mlockall $flags, $callback\->($status)
\&   aio_group $callback\->(...)
\&   aio_nop $callback\->()
\&
\&   $prev_pri = aioreq_pri [$pri]
\&   aioreq_nice $pri_adjust
\&
\&   IO::AIO::poll_wait
\&   IO::AIO::poll_cb
\&   IO::AIO::poll
\&   IO::AIO::flush
\&   IO::AIO::max_poll_reqs $nreqs
\&   IO::AIO::max_poll_time $seconds
\&   IO::AIO::min_parallel $nthreads
\&   IO::AIO::max_parallel $nthreads
\&   IO::AIO::max_idle $nthreads
\&   IO::AIO::idle_timeout $seconds
\&   IO::AIO::max_outstanding $maxreqs
\&   IO::AIO::nreqs
\&   IO::AIO::nready
\&   IO::AIO::npending
\&
\&   IO::AIO::sendfile $ofh, $ifh, $offset, $count
\&   IO::AIO::fadvise $fh, $offset, $len, $advice
\&   IO::AIO::mmap $scalar, $length, $prot, $flags[, $fh[, $offset]]
\&   IO::AIO::munmap $scalar
\&   IO::AIO::madvise $scalar, $offset, $length, $advice
\&   IO::AIO::mprotect $scalar, $offset, $length, $protect
\&   IO::AIO::munlock $scalar, $offset = 0, $length = undef
\&   IO::AIO::munlockall
.Ve
.SS "\s-1API\s0 \s-1NOTES\s0"
.IX Subsection "API NOTES"
All the \f(CW\*(C`aio_*\*(C'\fR calls are more or less thin wrappers around the syscall
with the same name (sans \f(CW\*(C`aio_\*(C'\fR). The arguments are similar or identical,
and they all accept an additional (and optional) \f(CW$callback\fR argument
which must be a code reference. This code reference will be called after
the syscall has been executed in an asynchronous fashion. The results
of the request will be passed as arguments to the callback (and, if an
error occured, in \f(CW$!\fR) \- for most requests the syscall return code (e.g.
most syscalls return \f(CW\*(C`\-1\*(C'\fR on error, unlike perl, which usually delivers
\&\*(L"false\*(R").
.PP
Some requests (such as \f(CW\*(C`aio_readdir\*(C'\fR) pass the actual results and
communicate failures by passing \f(CW\*(C`undef\*(C'\fR.
.PP
All functions expecting a filehandle keep a copy of the filehandle
internally until the request has finished.
.PP
All functions return request objects of type \s-1IO::AIO::REQ\s0 that allow
further manipulation of those requests while they are in-flight.
.PP
The pathnames you pass to these routines \fIshould\fR be absolute. The
reason for this is that at the time the request is being executed, the
current working directory could have changed. Alternatively, you can
make sure that you never change the current working directory anywhere
in the program and then use relative paths. You can also take advantage
of IO::AIOs working directory abstraction, that lets you specify paths
relative to some previously-opened \*(L"working directory object\*(R" \- see the
description of the \f(CW\*(C`IO::AIO::WD\*(C'\fR class later in this document.
.PP
To encode pathnames as octets, either make sure you either: a) always pass
in filenames you got from outside (command line, readdir etc.) without
tinkering, b) are in your native filesystem encoding, c) use the Encode
module and encode your pathnames to the locale (or other) encoding in
effect in the user environment, d) use Glib::filename_from_unicode on
unicode filenames or e) use something else to ensure your scalar has the
correct contents.
.PP
This works, btw. independent of the internal \s-1UTF\-8\s0 bit, which \s-1IO::AIO\s0
handles correctly whether it is set or not.
.SS "\s-1AIO\s0 \s-1REQUEST\s0 \s-1FUNCTIONS\s0"
.IX Subsection "AIO REQUEST FUNCTIONS"
.ie n .IP "$prev_pri = aioreq_pri [$pri]" 4
.el .IP "\f(CW$prev_pri\fR = aioreq_pri [$pri]" 4
.IX Item "$prev_pri = aioreq_pri [$pri]"
Returns the priority value that would be used for the next request and, if
\&\f(CW$pri\fR is given, sets the priority for the next aio request.
.Sp
The default priority is \f(CW0\fR, the minimum and maximum priorities are \f(CW\*(C`\-4\*(C'\fR
and \f(CW4\fR, respectively. Requests with higher priority will be serviced
first.
.Sp
The priority will be reset to \f(CW0\fR after each call to one of the \f(CW\*(C`aio_*\*(C'\fR
functions.
.Sp
Example: open a file with low priority, then read something from it with
higher priority so the read request is serviced before other low priority
open requests (potentially spamming the cache):
.Sp
.Vb 3
\&   aioreq_pri \-3;
\&   aio_open ..., sub {
\&      return unless $_[0];
\&
\&      aioreq_pri \-2;
\&      aio_read $_[0], ..., sub {
\&         ...
\&      };
\&   };
.Ve
.ie n .IP "aioreq_nice $pri_adjust" 4
.el .IP "aioreq_nice \f(CW$pri_adjust\fR" 4
.IX Item "aioreq_nice $pri_adjust"
Similar to \f(CW\*(C`aioreq_pri\*(C'\fR, but subtracts the given value from the current
priority, so the effect is cumulative.
.ie n .IP "aio_open $pathname, $flags, $mode, $callback\->($fh)" 4
.el .IP "aio_open \f(CW$pathname\fR, \f(CW$flags\fR, \f(CW$mode\fR, \f(CW$callback\fR\->($fh)" 4
.IX Item "aio_open $pathname, $flags, $mode, $callback->($fh)"
Asynchronously open or create a file and call the callback with a newly
created filehandle for the file (or \f(CW\*(C`undef\*(C'\fR in case of an error).
.Sp
The pathname passed to \f(CW\*(C`aio_open\*(C'\fR must be absolute. See \s-1API\s0 \s-1NOTES\s0, above,
for an explanation.
.Sp
The \f(CW$flags\fR argument is a bitmask. See the \f(CW\*(C`Fcntl\*(C'\fR module for a
list. They are the same as used by \f(CW\*(C`sysopen\*(C'\fR.
.Sp
Likewise, \f(CW$mode\fR specifies the mode of the newly created file, if it
didn't exist and \f(CW\*(C`O_CREAT\*(C'\fR has been given, just like perl's \f(CW\*(C`sysopen\*(C'\fR,
except that it is mandatory (i.e. use \f(CW0\fR if you don't create new files,
and \f(CW0666\fR or \f(CW0777\fR if you do). Note that the \f(CW$mode\fR will be modified
by the umask in effect then the request is being executed, so better never
change the umask.
.Sp
Example:
.Sp
.Vb 8
\&   aio_open "/etc/passwd", IO::AIO::O_RDONLY, 0, sub {
\&      if ($_[0]) {
\&         print "open successful, fh is $_[0]\en";
\&         ...
\&      } else {
\&         die "open failed: $!\en";
\&      }
\&   };
.Ve
.Sp
In addition to all the common open modes/flags (\f(CW\*(C`O_RDONLY\*(C'\fR, \f(CW\*(C`O_WRONLY\*(C'\fR,
\&\f(CW\*(C`O_RDWR\*(C'\fR, \f(CW\*(C`O_CREAT\*(C'\fR, \f(CW\*(C`O_TRUNC\*(C'\fR, \f(CW\*(C`O_EXCL\*(C'\fR and \f(CW\*(C`O_APPEND\*(C'\fR), the
following \s-1POSIX\s0 and non-POSIX constants are available (missing ones on
your system are, as usual, \f(CW0\fR):
.Sp
\&\f(CW\*(C`O_ASYNC\*(C'\fR, \f(CW\*(C`O_DIRECT\*(C'\fR, \f(CW\*(C`O_NOATIME\*(C'\fR, \f(CW\*(C`O_CLOEXEC\*(C'\fR, \f(CW\*(C`O_NOCTTY\*(C'\fR, \f(CW\*(C`O_NOFOLLOW\*(C'\fR,
\&\f(CW\*(C`O_NONBLOCK\*(C'\fR, \f(CW\*(C`O_EXEC\*(C'\fR, \f(CW\*(C`O_SEARCH\*(C'\fR, \f(CW\*(C`O_DIRECTORY\*(C'\fR, \f(CW\*(C`O_DSYNC\*(C'\fR,
\&\f(CW\*(C`O_RSYNC\*(C'\fR, \f(CW\*(C`O_SYNC\*(C'\fR and \f(CW\*(C`O_TTY_INIT\*(C'\fR.
.ie n .IP "aio_close $fh, $callback\->($status)" 4
.el .IP "aio_close \f(CW$fh\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_close $fh, $callback->($status)"
Asynchronously close a file and call the callback with the result
code.
.Sp
Unfortunately, you can't do this to perl. Perl \fIinsists\fR very strongly on
closing the file descriptor associated with the filehandle itself.
.Sp
Therefore, \f(CW\*(C`aio_close\*(C'\fR will not close the filehandle \- instead it will
use dup2 to overwrite the file descriptor with the write-end of a pipe
(the pipe fd will be created on demand and will be cached).
.Sp
Or in other words: the file descriptor will be closed, but it will not be
free for reuse until the perl filehandle is closed.
.ie n .IP "aio_seek $fh, $offset, $whence, $callback\->($offs)" 4
.el .IP "aio_seek \f(CW$fh\fR, \f(CW$offset\fR, \f(CW$whence\fR, \f(CW$callback\fR\->($offs)" 4
.IX Item "aio_seek $fh, $offset, $whence, $callback->($offs)"
Seeks the filehandle to the new \f(CW$offset\fR, similarly to perl's
\&\f(CW\*(C`sysseek\*(C'\fR. The \f(CW$whence\fR can use the traditional values (\f(CW0\fR for
\&\f(CW\*(C`IO::AIO::SEEK_SET\*(C'\fR, \f(CW1\fR for \f(CW\*(C`IO::AIO::SEEK_CUR\*(C'\fR or \f(CW2\fR for
\&\f(CW\*(C`IO::AIO::SEEK_END\*(C'\fR).
.Sp
The resulting absolute offset will be passed to the callback, or \f(CW\*(C`\-1\*(C'\fR in
case of an error.
.Sp
In theory, the \f(CW$whence\fR constants could be different than the
corresponding values from Fcntl, but perl guarantees they are the same,
so don't panic.
.Sp
As a GNU/Linux (and maybe Solaris) extension, also the constants
\&\f(CW\*(C`IO::AIO::SEEK_DATA\*(C'\fR and \f(CW\*(C`IO::AIO::SEEK_HOLE\*(C'\fR are available, if they
could be found. No guarantees about suitability for use in \f(CW\*(C`aio_seek\*(C'\fR or
Perl's \f(CW\*(C`sysseek\*(C'\fR can be made though, although I would naively assume they
\&\*(L"just work\*(R".
.ie n .IP "aio_read  $fh,$offset,$length, $data,$dataoffset, $callback\->($retval)" 4
.el .IP "aio_read  \f(CW$fh\fR,$offset,$length, \f(CW$data\fR,$dataoffset, \f(CW$callback\fR\->($retval)" 4
.IX Item "aio_read  $fh,$offset,$length, $data,$dataoffset, $callback->($retval)"
.PD 0
.ie n .IP "aio_write $fh,$offset,$length, $data,$dataoffset, $callback\->($retval)" 4
.el .IP "aio_write \f(CW$fh\fR,$offset,$length, \f(CW$data\fR,$dataoffset, \f(CW$callback\fR\->($retval)" 4
.IX Item "aio_write $fh,$offset,$length, $data,$dataoffset, $callback->($retval)"
.PD
Reads or writes \f(CW$length\fR bytes from or to the specified \f(CW$fh\fR and
\&\f(CW$offset\fR into the scalar given by \f(CW$data\fR and offset \f(CW$dataoffset\fR
and calls the callback without the actual number of bytes read (or \-1 on
error, just like the syscall).
.Sp
\&\f(CW\*(C`aio_read\*(C'\fR will, like \f(CW\*(C`sysread\*(C'\fR, shrink or grow the \f(CW$data\fR scalar to
offset plus the actual number of bytes read.
.Sp
If \f(CW$offset\fR is undefined, then the current file descriptor offset will
be used (and updated), otherwise the file descriptor offset will not be
changed by these calls.
.Sp
If \f(CW$length\fR is undefined in \f(CW\*(C`aio_write\*(C'\fR, use the remaining length of
\&\f(CW$data\fR.
.Sp
If \f(CW$dataoffset\fR is less than zero, it will be counted from the end of
\&\f(CW$data\fR.
.Sp
The \f(CW$data\fR scalar \fI\s-1MUST\s0 \s-1NOT\s0\fR be modified in any way while the request
is outstanding. Modifying it can result in segfaults or World War \s-1III\s0 (if
the necessary/optional hardware is installed).
.Sp
Example: Read 15 bytes at offset 7 into scalar \f(CW$buffer\fR, starting at
offset \f(CW0\fR within the scalar:
.Sp
.Vb 4
\&   aio_read $fh, 7, 15, $buffer, 0, sub {
\&      $_[0] > 0 or die "read error: $!";
\&      print "read $_[0] bytes: <$buffer>\en";
\&   };
.Ve
.ie n .IP "aio_sendfile $out_fh, $in_fh, $in_offset, $length, $callback\->($retval)" 4
.el .IP "aio_sendfile \f(CW$out_fh\fR, \f(CW$in_fh\fR, \f(CW$in_offset\fR, \f(CW$length\fR, \f(CW$callback\fR\->($retval)" 4
.IX Item "aio_sendfile $out_fh, $in_fh, $in_offset, $length, $callback->($retval)"
Tries to copy \f(CW$length\fR bytes from \f(CW$in_fh\fR to \f(CW$out_fh\fR. It starts
reading at byte offset \f(CW$in_offset\fR, and starts writing at the current
file offset of \f(CW$out_fh\fR. Because of that, it is not safe to issue more
than one \f(CW\*(C`aio_sendfile\*(C'\fR per \f(CW$out_fh\fR, as they will interfere with each
other. The same \f(CW$in_fh\fR works fine though, as this function does not
move or use the file offset of \f(CW$in_fh\fR.
.Sp
Please note that \f(CW\*(C`aio_sendfile\*(C'\fR can read more bytes from \f(CW$in_fh\fR than
are written, and there is no way to find out how many more bytes have been
read from \f(CW\*(C`aio_sendfile\*(C'\fR alone, as \f(CW\*(C`aio_sendfile\*(C'\fR only provides the
number of bytes written to \f(CW$out_fh\fR. Only if the result value equals
\&\f(CW$length\fR one can assume that \f(CW$length\fR bytes have been read.
.Sp
Unlike with other \f(CW\*(C`aio_\*(C'\fR functions, it makes a lot of sense to use
\&\f(CW\*(C`aio_sendfile\*(C'\fR on non-blocking sockets, as long as one end (typically
the \f(CW$in_fh\fR) is a file \- the file I/O will then be asynchronous, while
the socket I/O will be non-blocking. Note, however, that you can run
into a trap where \f(CW\*(C`aio_sendfile\*(C'\fR reads some data with readahead, then
fails to write all data, and when the socket is ready the next time, the
data in the cache is already lost, forcing \f(CW\*(C`aio_sendfile\*(C'\fR to again hit
the disk. Explicit \f(CW\*(C`aio_read\*(C'\fR + \f(CW\*(C`aio_write\*(C'\fR let's you better control
resource usage.
.Sp
This call tries to make use of a native \f(CW\*(C`sendfile\*(C'\fR\-like syscall to
provide zero-copy operation. For this to work, \f(CW$out_fh\fR should refer to
a socket, and \f(CW$in_fh\fR should refer to an mmap'able file.
.Sp
If a native sendfile cannot be found or it fails with \f(CW\*(C`ENOSYS\*(C'\fR,
\&\f(CW\*(C`EINVAL\*(C'\fR, \f(CW\*(C`ENOTSUP\*(C'\fR, \f(CW\*(C`EOPNOTSUPP\*(C'\fR, \f(CW\*(C`EAFNOSUPPORT\*(C'\fR, \f(CW\*(C`EPROTOTYPE\*(C'\fR or
\&\f(CW\*(C`ENOTSOCK\*(C'\fR, it will be emulated, so you can call \f(CW\*(C`aio_sendfile\*(C'\fR on any
type of filehandle regardless of the limitations of the operating system.
.Sp
As native sendfile syscalls (as practically any non-POSIX interface hacked
together in a hurry to improve benchmark numbers) tend to be rather buggy
on many systems, this implementation tries to work around some known bugs
in Linux and FreeBSD kernels (probably others, too), but that might fail,
so you really really should check the return value of \f(CW\*(C`aio_sendfile\*(C'\fR \-
fewre bytes than expected might have been transferred.
.ie n .IP "aio_readahead $fh,$offset,$length, $callback\->($retval)" 4
.el .IP "aio_readahead \f(CW$fh\fR,$offset,$length, \f(CW$callback\fR\->($retval)" 4
.IX Item "aio_readahead $fh,$offset,$length, $callback->($retval)"
\&\f(CW\*(C`aio_readahead\*(C'\fR populates the page cache with data from a file so that
subsequent reads from that file will not block on disk I/O. The \f(CW$offset\fR
argument specifies the starting point from which data is to be read and
\&\f(CW$length\fR specifies the number of bytes to be read. I/O is performed in
whole pages, so that offset is effectively rounded down to a page boundary
and bytes are read up to the next page boundary greater than or equal to
(off\-set+length). \f(CW\*(C`aio_readahead\*(C'\fR does not read beyond the end of the
file. The current file offset of the file is left unchanged.
.Sp
If that syscall doesn't exist (likely if your \s-1OS\s0 isn't Linux) it will be
emulated by simply reading the data, which would have a similar effect.
.ie n .IP "aio_stat  $fh_or_path, $callback\->($status)" 4
.el .IP "aio_stat  \f(CW$fh_or_path\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_stat  $fh_or_path, $callback->($status)"
.PD 0
.ie n .IP "aio_lstat $fh, $callback\->($status)" 4
.el .IP "aio_lstat \f(CW$fh\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_lstat $fh, $callback->($status)"
.PD
Works like perl's \f(CW\*(C`stat\*(C'\fR or \f(CW\*(C`lstat\*(C'\fR in void context. The callback will
be called after the stat and the results will be available using \f(CW\*(C`stat _\*(C'\fR
or \f(CW\*(C`\-s _\*(C'\fR etc...
.Sp
The pathname passed to \f(CW\*(C`aio_stat\*(C'\fR must be absolute. See \s-1API\s0 \s-1NOTES\s0, above,
for an explanation.
.Sp
Currently, the stats are always 64\-bit\-stats, i.e. instead of returning an
error when stat'ing a large file, the results will be silently truncated
unless perl itself is compiled with large file support.
.Sp
To help interpret the mode and dev/rdev stat values, \s-1IO::AIO\s0 offers the
following constants and functions (if not implemented, the constants will
be \f(CW0\fR and the functions will either \f(CW\*(C`croak\*(C'\fR or fall back on traditional
behaviour).
.Sp
\&\f(CW\*(C`S_IFMT\*(C'\fR, \f(CW\*(C`S_IFIFO\*(C'\fR, \f(CW\*(C`S_IFCHR\*(C'\fR, \f(CW\*(C`S_IFBLK\*(C'\fR, \f(CW\*(C`S_IFLNK\*(C'\fR, \f(CW\*(C`S_IFREG\*(C'\fR,
\&\f(CW\*(C`S_IFDIR\*(C'\fR, \f(CW\*(C`S_IFWHT\*(C'\fR, \f(CW\*(C`S_IFSOCK\*(C'\fR, \f(CW\*(C`IO::AIO::major $dev_t\*(C'\fR,
\&\f(CW\*(C`IO::AIO::minor $dev_t\*(C'\fR, \f(CW\*(C`IO::AIO::makedev $major, $minor\*(C'\fR.
.Sp
Example: Print the length of \fI/etc/passwd\fR:
.Sp
.Vb 4
\&   aio_stat "/etc/passwd", sub {
\&      $_[0] and die "stat failed: $!";
\&      print "size is ", \-s _, "\en";
\&   };
.Ve
.ie n .IP "aio_statvfs $fh_or_path, $callback\->($statvfs)" 4
.el .IP "aio_statvfs \f(CW$fh_or_path\fR, \f(CW$callback\fR\->($statvfs)" 4
.IX Item "aio_statvfs $fh_or_path, $callback->($statvfs)"
Works like the \s-1POSIX\s0 \f(CW\*(C`statvfs\*(C'\fR or \f(CW\*(C`fstatvfs\*(C'\fR syscalls, depending on
whether a file handle or path was passed.
.Sp
On success, the callback is passed a hash reference with the following
members: \f(CW\*(C`bsize\*(C'\fR, \f(CW\*(C`frsize\*(C'\fR, \f(CW\*(C`blocks\*(C'\fR, \f(CW\*(C`bfree\*(C'\fR, \f(CW\*(C`bavail\*(C'\fR, \f(CW\*(C`files\*(C'\fR,
\&\f(CW\*(C`ffree\*(C'\fR, \f(CW\*(C`favail\*(C'\fR, \f(CW\*(C`fsid\*(C'\fR, \f(CW\*(C`flag\*(C'\fR and \f(CW\*(C`namemax\*(C'\fR. On failure, \f(CW\*(C`undef\*(C'\fR
is passed.
.Sp
The following \s-1POSIX\s0 IO::AIO::ST_* constants are defined: \f(CW\*(C`ST_RDONLY\*(C'\fR and
\&\f(CW\*(C`ST_NOSUID\*(C'\fR.
.Sp
The following non-POSIX IO::AIO::ST_* flag masks are defined to
their correct value when available, or to \f(CW0\fR on systems that do
not support them:  \f(CW\*(C`ST_NODEV\*(C'\fR, \f(CW\*(C`ST_NOEXEC\*(C'\fR, \f(CW\*(C`ST_SYNCHRONOUS\*(C'\fR,
\&\f(CW\*(C`ST_MANDLOCK\*(C'\fR, \f(CW\*(C`ST_WRITE\*(C'\fR, \f(CW\*(C`ST_APPEND\*(C'\fR, \f(CW\*(C`ST_IMMUTABLE\*(C'\fR, \f(CW\*(C`ST_NOATIME\*(C'\fR,
\&\f(CW\*(C`ST_NODIRATIME\*(C'\fR and \f(CW\*(C`ST_RELATIME\*(C'\fR.
.Sp
Example: stat \f(CW\*(C`/wd\*(C'\fR and dump out the data if successful.
.Sp
.Vb 3
\&   aio_statvfs "/wd", sub {
\&      my $f = $_[0]
\&         or die "statvfs: $!";
\&
\&      use Data::Dumper;
\&      say Dumper $f;
\&   };
\&
\&   # result:
\&   {
\&      bsize   => 1024,
\&      bfree   => 4333064312,
\&      blocks  => 10253828096,
\&      files   => 2050765568,
\&      flag    => 4096,
\&      favail  => 2042092649,
\&      bavail  => 4333064312,
\&      ffree   => 2042092649,
\&      namemax => 255,
\&      frsize  => 1024,
\&      fsid    => 1810
\&   }
.Ve
.Sp
Here is a (likely partial) list of fsid values used by Linux \- it is safe
to hardcode these when the $^O is \f(CW\*(C`linux\*(C'\fR:
.Sp
.Vb 10
\&   0x0000adf5 adfs
\&   0x0000adff affs
\&   0x5346414f afs
\&   0x09041934 anon\-inode filesystem
\&   0x00000187 autofs
\&   0x42465331 befs
\&   0x1badface bfs
\&   0x42494e4d binfmt_misc
\&   0x9123683e btrfs
\&   0x0027e0eb cgroupfs
\&   0xff534d42 cifs
\&   0x73757245 coda
\&   0x012ff7b7 coh
\&   0x28cd3d45 cramfs
\&   0x453dcd28 cramfs\-wend (wrong endianness)
\&   0x64626720 debugfs
\&   0x00001373 devfs
\&   0x00001cd1 devpts
\&   0x0000f15f ecryptfs
\&   0x00414a53 efs
\&   0x0000137d ext
\&   0x0000ef53 ext2/ext3
\&   0x0000ef51 ext2
\&   0x00004006 fat
\&   0x65735546 fuseblk
\&   0x65735543 fusectl
\&   0x0bad1dea futexfs
\&   0x01161970 gfs2
\&   0x47504653 gpfs
\&   0x00004244 hfs
\&   0xf995e849 hpfs
\&   0x958458f6 hugetlbfs
\&   0x2bad1dea inotifyfs
\&   0x00009660 isofs
\&   0x000072b6 jffs2
\&   0x3153464a jfs
\&   0x6b414653 k\-afs
\&   0x0bd00bd0 lustre
\&   0x0000137f minix
\&   0x0000138f minix 30 char names
\&   0x00002468 minix v2
\&   0x00002478 minix v2 30 char names
\&   0x00004d5a minix v3
\&   0x19800202 mqueue
\&   0x00004d44 msdos
\&   0x0000564c novell
\&   0x00006969 nfs
\&   0x6e667364 nfsd
\&   0x00003434 nilfs
\&   0x5346544e ntfs
\&   0x00009fa1 openprom
\&   0x7461636F ocfs2
\&   0x00009fa0 proc
\&   0x6165676c pstorefs
\&   0x0000002f qnx4
\&   0x858458f6 ramfs
\&   0x52654973 reiserfs
\&   0x00007275 romfs
\&   0x67596969 rpc_pipefs
\&   0x73636673 securityfs
\&   0xf97cff8c selinux
\&   0x0000517b smb
\&   0x534f434b sockfs
\&   0x73717368 squashfs
\&   0x62656572 sysfs
\&   0x012ff7b6 sysv2
\&   0x012ff7b5 sysv4
\&   0x01021994 tmpfs
\&   0x15013346 udf
\&   0x00011954 ufs
\&   0x54190100 ufs byteswapped
\&   0x00009fa2 usbdevfs
\&   0x01021997 v9fs
\&   0xa501fcf5 vxfs
\&   0xabba1974 xenfs
\&   0x012ff7b4 xenix
\&   0x58465342 xfs
\&   0x012fd16d xia
.Ve
.ie n .IP "aio_utime $fh_or_path, $atime, $mtime, $callback\->($status)" 4
.el .IP "aio_utime \f(CW$fh_or_path\fR, \f(CW$atime\fR, \f(CW$mtime\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_utime $fh_or_path, $atime, $mtime, $callback->($status)"
Works like perl's \f(CW\*(C`utime\*(C'\fR function (including the special case of \f(CW$atime\fR
and \f(CW$mtime\fR being undef). Fractional times are supported if the underlying
syscalls support them.
.Sp
When called with a pathname, uses \fIutimes\fR\|(2) if available, otherwise
\&\fIutime\fR\|(2). If called on a file descriptor, uses \fIfutimes\fR\|(2) if available,
otherwise returns \s-1ENOSYS\s0, so this is not portable.
.Sp
Examples:
.Sp
.Vb 4
\&   # set atime and mtime to current time (basically touch(1)):
\&   aio_utime "path", undef, undef;
\&   # set atime to current time and mtime to beginning of the epoch:
\&   aio_utime "path", time, undef; # undef==0
.Ve
.ie n .IP "aio_chown $fh_or_path, $uid, $gid, $callback\->($status)" 4
.el .IP "aio_chown \f(CW$fh_or_path\fR, \f(CW$uid\fR, \f(CW$gid\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_chown $fh_or_path, $uid, $gid, $callback->($status)"
Works like perl's \f(CW\*(C`chown\*(C'\fR function, except that \f(CW\*(C`undef\*(C'\fR for either \f(CW$uid\fR
or \f(CW$gid\fR is being interpreted as \*(L"do not change\*(R" (but \-1 can also be used).
.Sp
Examples:
.Sp
.Vb 4
\&   # same as "chown root path" in the shell:
\&   aio_chown "path", 0, \-1;
\&   # same as above:
\&   aio_chown "path", 0, undef;
.Ve
.ie n .IP "aio_truncate $fh_or_path, $offset, $callback\->($status)" 4
.el .IP "aio_truncate \f(CW$fh_or_path\fR, \f(CW$offset\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_truncate $fh_or_path, $offset, $callback->($status)"
Works like \fItruncate\fR\|(2) or \fIftruncate\fR\|(2).
.ie n .IP "aio_allocate $fh, $mode, $offset, $len, $callback\->($status)" 4
.el .IP "aio_allocate \f(CW$fh\fR, \f(CW$mode\fR, \f(CW$offset\fR, \f(CW$len\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_allocate $fh, $mode, $offset, $len, $callback->($status)"
Allocates or freed disk space according to the \f(CW$mode\fR argument. See the
linux \f(CW\*(C`fallocate\*(C'\fR docuemntation for details.
.Sp
\&\f(CW$mode\fR can currently be \f(CW0\fR or \f(CW\*(C`IO::AIO::FALLOC_FL_KEEP_SIZE\*(C'\fR
to allocate space, or \f(CW\*(C`IO::AIO::FALLOC_FL_PUNCH_HOLE |
IO::AIO::FALLOC_FL_KEEP_SIZE\*(C'\fR, to deallocate a file range.
.Sp
The file system block size used by \f(CW\*(C`fallocate\*(C'\fR is presumably the
\&\f(CW\*(C`f_bsize\*(C'\fR returned by \f(CW\*(C`statvfs\*(C'\fR.
.Sp
If \f(CW\*(C`fallocate\*(C'\fR isn't available or cannot be emulated (currently no
emulation will be attempted), passes \f(CW\*(C`\-1\*(C'\fR and sets \f(CW$!\fR to \f(CW\*(C`ENOSYS\*(C'\fR.
.ie n .IP "aio_chmod $fh_or_path, $mode, $callback\->($status)" 4
.el .IP "aio_chmod \f(CW$fh_or_path\fR, \f(CW$mode\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_chmod $fh_or_path, $mode, $callback->($status)"
Works like perl's \f(CW\*(C`chmod\*(C'\fR function.
.ie n .IP "aio_unlink $pathname, $callback\->($status)" 4
.el .IP "aio_unlink \f(CW$pathname\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_unlink $pathname, $callback->($status)"
Asynchronously unlink (delete) a file and call the callback with the
result code.
.ie n .IP "aio_mknod $pathname, $mode, $dev, $callback\->($status)" 4
.el .IP "aio_mknod \f(CW$pathname\fR, \f(CW$mode\fR, \f(CW$dev\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_mknod $pathname, $mode, $dev, $callback->($status)"
[\s-1EXPERIMENTAL\s0]
.Sp
Asynchronously create a device node (or fifo). See \fImknod\fR\|(2).
.Sp
The only (\s-1POSIX\-\s0) portable way of calling this function is:
.Sp
.Vb 1
\&   aio_mknod $pathname, IO::AIO::S_IFIFO | $mode, 0, sub { ...
.Ve
.Sp
See \f(CW\*(C`aio_stat\*(C'\fR for info about some potentially helpful extra constants
and functions.
.ie n .IP "aio_link $srcpath, $dstpath, $callback\->($status)" 4
.el .IP "aio_link \f(CW$srcpath\fR, \f(CW$dstpath\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_link $srcpath, $dstpath, $callback->($status)"
Asynchronously create a new link to the existing object at \f(CW$srcpath\fR at
the path \f(CW$dstpath\fR and call the callback with the result code.
.ie n .IP "aio_symlink $srcpath, $dstpath, $callback\->($status)" 4
.el .IP "aio_symlink \f(CW$srcpath\fR, \f(CW$dstpath\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_symlink $srcpath, $dstpath, $callback->($status)"
Asynchronously create a new symbolic link to the existing object at \f(CW$srcpath\fR at
the path \f(CW$dstpath\fR and call the callback with the result code.
.ie n .IP "aio_readlink $pathname, $callback\->($link)" 4
.el .IP "aio_readlink \f(CW$pathname\fR, \f(CW$callback\fR\->($link)" 4
.IX Item "aio_readlink $pathname, $callback->($link)"
Asynchronously read the symlink specified by \f(CW$path\fR and pass it to
the callback. If an error occurs, nothing or undef gets passed to the
callback.
.ie n .IP "aio_realpath $pathname, $callback\->($path)" 4
.el .IP "aio_realpath \f(CW$pathname\fR, \f(CW$callback\fR\->($path)" 4
.IX Item "aio_realpath $pathname, $callback->($path)"
Asynchronously make the path absolute and resolve any symlinks in
\&\f(CW$path\fR. The resulting path only consists of directories (Same as
Cwd::realpath).
.Sp
This request can be used to get the absolute path of the current working
directory by passing it a path of \fI.\fR (a single dot).
.ie n .IP "aio_rename $srcpath, $dstpath, $callback\->($status)" 4
.el .IP "aio_rename \f(CW$srcpath\fR, \f(CW$dstpath\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_rename $srcpath, $dstpath, $callback->($status)"
Asynchronously rename the object at \f(CW$srcpath\fR to \f(CW$dstpath\fR, just as
\&\fIrename\fR\|(2) and call the callback with the result code.
.ie n .IP "aio_mkdir $pathname, $mode, $callback\->($status)" 4
.el .IP "aio_mkdir \f(CW$pathname\fR, \f(CW$mode\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_mkdir $pathname, $mode, $callback->($status)"
Asynchronously mkdir (create) a directory and call the callback with
the result code. \f(CW$mode\fR will be modified by the umask at the time the
request is executed, so do not change your umask.
.ie n .IP "aio_rmdir $pathname, $callback\->($status)" 4
.el .IP "aio_rmdir \f(CW$pathname\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_rmdir $pathname, $callback->($status)"
Asynchronously rmdir (delete) a directory and call the callback with the
result code.
.ie n .IP "aio_readdir $pathname, $callback\->($entries)" 4
.el .IP "aio_readdir \f(CW$pathname\fR, \f(CW$callback\fR\->($entries)" 4
.IX Item "aio_readdir $pathname, $callback->($entries)"
Unlike the \s-1POSIX\s0 call of the same name, \f(CW\*(C`aio_readdir\*(C'\fR reads an entire
directory (i.e. opendir + readdir + closedir). The entries will not be
sorted, and will \fB\s-1NOT\s0\fR include the \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR entries.
.Sp
The callback is passed a single argument which is either \f(CW\*(C`undef\*(C'\fR or an
array-ref with the filenames.
.ie n .IP "aio_readdirx $pathname, $flags, $callback\->($entries, $flags)" 4
.el .IP "aio_readdirx \f(CW$pathname\fR, \f(CW$flags\fR, \f(CW$callback\fR\->($entries, \f(CW$flags\fR)" 4
.IX Item "aio_readdirx $pathname, $flags, $callback->($entries, $flags)"
Quite similar to \f(CW\*(C`aio_readdir\*(C'\fR, but the \f(CW$flags\fR argument allows one to
tune behaviour and output format. In case of an error, \f(CW$entries\fR will be
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
The flags are a combination of the following constants, ORed together (the
flags will also be passed to the callback, possibly modified):
.RS 4
.IP "\s-1IO::AIO::READDIR_DENTS\s0" 4
.IX Item "IO::AIO::READDIR_DENTS"
When this flag is off, then the callback gets an arrayref consisting of
names only (as with \f(CW\*(C`aio_readdir\*(C'\fR), otherwise it gets an arrayref with
\&\f(CW\*(C`[$name, $type, $inode]\*(C'\fR arrayrefs, each describing a single directory
entry in more detail.
.Sp
\&\f(CW$name\fR is the name of the entry.
.Sp
\&\f(CW$type\fR is one of the \f(CW\*(C`IO::AIO::DT_xxx\*(C'\fR constants:
.Sp
\&\f(CW\*(C`IO::AIO::DT_UNKNOWN\*(C'\fR, \f(CW\*(C`IO::AIO::DT_FIFO\*(C'\fR, \f(CW\*(C`IO::AIO::DT_CHR\*(C'\fR, \f(CW\*(C`IO::AIO::DT_DIR\*(C'\fR,
\&\f(CW\*(C`IO::AIO::DT_BLK\*(C'\fR, \f(CW\*(C`IO::AIO::DT_REG\*(C'\fR, \f(CW\*(C`IO::AIO::DT_LNK\*(C'\fR, \f(CW\*(C`IO::AIO::DT_SOCK\*(C'\fR,
\&\f(CW\*(C`IO::AIO::DT_WHT\*(C'\fR.
.Sp
\&\f(CW\*(C`IO::AIO::DT_UNKNOWN\*(C'\fR means just that: readdir does not know. If you need to
know, you have to run stat yourself. Also, for speed reasons, the \f(CW$type\fR
scalars are read-only: you can not modify them.
.Sp
\&\f(CW$inode\fR is the inode number (which might not be exact on systems with 64
bit inode numbers and 32 bit perls). This field has unspecified content on
systems that do not deliver the inode information.
.IP "\s-1IO::AIO::READDIR_DIRS_FIRST\s0" 4
.IX Item "IO::AIO::READDIR_DIRS_FIRST"
When this flag is set, then the names will be returned in an order where
likely directories come first, in optimal stat order. This is useful when
you need to quickly find directories, or you want to find all directories
while avoiding to \fIstat()\fR each entry.
.Sp
If the system returns type information in readdir, then this is used
to find directories directly. Otherwise, likely directories are names
beginning with \*(L".\*(R", or otherwise names with no dots, of which names with
short names are tried first.
.IP "\s-1IO::AIO::READDIR_STAT_ORDER\s0" 4
.IX Item "IO::AIO::READDIR_STAT_ORDER"
When this flag is set, then the names will be returned in an order
suitable for \fIstat()\fR'ing each one. That is, when you plan to \fIstat()\fR
all files in the given directory, then the returned order will likely
be fastest.
.Sp
If both this flag and \f(CW\*(C`IO::AIO::READDIR_DIRS_FIRST\*(C'\fR are specified, then
the likely dirs come first, resulting in a less optimal stat order.
.IP "\s-1IO::AIO::READDIR_FOUND_UNKNOWN\s0" 4
.IX Item "IO::AIO::READDIR_FOUND_UNKNOWN"
This flag should not be set when calling \f(CW\*(C`aio_readdirx\*(C'\fR. Instead, it
is being set by \f(CW\*(C`aio_readdirx\*(C'\fR, when any of the \f(CW$type\fR's found were
\&\f(CW\*(C`IO::AIO::DT_UNKNOWN\*(C'\fR. The absence of this flag therefore indicates that all
\&\f(CW$type\fR's are known, which can be used to speed up some algorithms.
.RE
.RS 4
.RE
.ie n .IP "aio_load $pathname, $data, $callback\->($status)" 4
.el .IP "aio_load \f(CW$pathname\fR, \f(CW$data\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_load $pathname, $data, $callback->($status)"
This is a composite request that tries to fully load the given file into
memory. Status is the same as with aio_read.
.ie n .IP "aio_copy $srcpath, $dstpath, $callback\->($status)" 4
.el .IP "aio_copy \f(CW$srcpath\fR, \f(CW$dstpath\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_copy $srcpath, $dstpath, $callback->($status)"
Try to copy the \fIfile\fR (directories not supported as either source or
destination) from \f(CW$srcpath\fR to \f(CW$dstpath\fR and call the callback with
a status of \f(CW0\fR (ok) or \f(CW\*(C`\-1\*(C'\fR (error, see \f(CW$!\fR).
.Sp
This is a composite request that creates the destination file with
mode 0200 and copies the contents of the source file into it using
\&\f(CW\*(C`aio_sendfile\*(C'\fR, followed by restoring atime, mtime, access mode and
uid/gid, in that order.
.Sp
If an error occurs, the partial destination file will be unlinked, if
possible, except when setting atime, mtime, access mode and uid/gid, where
errors are being ignored.
.ie n .IP "aio_move $srcpath, $dstpath, $callback\->($status)" 4
.el .IP "aio_move \f(CW$srcpath\fR, \f(CW$dstpath\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_move $srcpath, $dstpath, $callback->($status)"
Try to move the \fIfile\fR (directories not supported as either source or
destination) from \f(CW$srcpath\fR to \f(CW$dstpath\fR and call the callback with
a status of \f(CW0\fR (ok) or \f(CW\*(C`\-1\*(C'\fR (error, see \f(CW$!\fR).
.Sp
This is a composite request that tries to \fIrename\fR\|(2) the file first; if
rename fails with \f(CW\*(C`EXDEV\*(C'\fR, it copies the file with \f(CW\*(C`aio_copy\*(C'\fR and, if
that is successful, unlinks the \f(CW$srcpath\fR.
.ie n .IP "aio_scandir $pathname, $maxreq, $callback\->($dirs, $nondirs)" 4
.el .IP "aio_scandir \f(CW$pathname\fR, \f(CW$maxreq\fR, \f(CW$callback\fR\->($dirs, \f(CW$nondirs\fR)" 4
.IX Item "aio_scandir $pathname, $maxreq, $callback->($dirs, $nondirs)"
Scans a directory (similar to \f(CW\*(C`aio_readdir\*(C'\fR) but additionally tries to
efficiently separate the entries of directory \f(CW$path\fR into two sets of
names, directories you can recurse into (directories), and ones you cannot
recurse into (everything else, including symlinks to directories).
.Sp
\&\f(CW\*(C`aio_scandir\*(C'\fR is a composite request that creates of many sub requests_
\&\f(CW$maxreq\fR specifies the maximum number of outstanding aio requests that
this function generates. If it is \f(CW\*(C`<= 0\*(C'\fR, then a suitable default
will be chosen (currently 4).
.Sp
On error, the callback is called without arguments, otherwise it receives
two array-refs with path-relative entry names.
.Sp
Example:
.Sp
.Vb 5
\&   aio_scandir $dir, 0, sub {
\&      my ($dirs, $nondirs) = @_;
\&      print "real directories: @$dirs\en";
\&      print "everything else: @$nondirs\en";
\&   };
.Ve
.Sp
Implementation notes.
.Sp
The \f(CW\*(C`aio_readdir\*(C'\fR cannot be avoided, but \f(CW\*(C`stat()\*(C'\fR'ing every entry can.
.Sp
If readdir returns file type information, then this is used directly to
find directories.
.Sp
Otherwise, after reading the directory, the modification time, size etc.
of the directory before and after the readdir is checked, and if they
match (and isn't the current time), the link count will be used to decide
how many entries are directories (if >= 2). Otherwise, no knowledge of the
number of subdirectories will be assumed.
.Sp
Then entries will be sorted into likely directories a non-initial dot
currently) and likely non-directories (see \f(CW\*(C`aio_readdirx\*(C'\fR). Then every
entry plus an appended \f(CW\*(C`/.\*(C'\fR will be \f(CW\*(C`stat\*(C'\fR'ed, likely directories first,
in order of their inode numbers. If that succeeds, it assumes that the
entry is a directory or a symlink to directory (which will be checked
separately). This is often faster than stat'ing the entry itself because
filesystems might detect the type of the entry without reading the inode
data (e.g. ext2fs filetype feature), even on systems that cannot return
the filetype information on readdir.
.Sp
If the known number of directories (link count \- 2) has been reached, the
rest of the entries is assumed to be non-directories.
.Sp
This only works with certainty on \s-1POSIX\s0 (= \s-1UNIX\s0) filesystems, which
fortunately are the vast majority of filesystems around.
.Sp
It will also likely work on non-POSIX filesystems with reduced efficiency
as those tend to return 0 or 1 as link counts, which disables the
directory counting heuristic.
.ie n .IP "aio_rmtree $pathname, $callback\->($status)" 4
.el .IP "aio_rmtree \f(CW$pathname\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_rmtree $pathname, $callback->($status)"
Delete a directory tree starting (and including) \f(CW$path\fR, return the
status of the final \f(CW\*(C`rmdir\*(C'\fR only.  This is a composite request that
uses \f(CW\*(C`aio_scandir\*(C'\fR to recurse into and rmdir directories, and unlink
everything else.
.ie n .IP "aio_sync $callback\->($status)" 4
.el .IP "aio_sync \f(CW$callback\fR\->($status)" 4
.IX Item "aio_sync $callback->($status)"
Asynchronously call sync and call the callback when finished.
.ie n .IP "aio_fsync $fh, $callback\->($status)" 4
.el .IP "aio_fsync \f(CW$fh\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_fsync $fh, $callback->($status)"
Asynchronously call fsync on the given filehandle and call the callback
with the fsync result code.
.ie n .IP "aio_fdatasync $fh, $callback\->($status)" 4
.el .IP "aio_fdatasync \f(CW$fh\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_fdatasync $fh, $callback->($status)"
Asynchronously call fdatasync on the given filehandle and call the
callback with the fdatasync result code.
.Sp
If this call isn't available because your \s-1OS\s0 lacks it or it couldn't be
detected, it will be emulated by calling \f(CW\*(C`fsync\*(C'\fR instead.
.ie n .IP "aio_syncfs $fh, $callback\->($status)" 4
.el .IP "aio_syncfs \f(CW$fh\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_syncfs $fh, $callback->($status)"
Asynchronously call the syncfs syscall to sync the filesystem associated
to the given filehandle and call the callback with the syncfs result
code. If syncfs is not available, calls \fIsync()\fR, but returns \f(CW\*(C`\-1\*(C'\fR and sets
errno to \f(CW\*(C`ENOSYS\*(C'\fR nevertheless.
.ie n .IP "aio_sync_file_range $fh, $offset, $nbytes, $flags, $callback\->($status)" 4
.el .IP "aio_sync_file_range \f(CW$fh\fR, \f(CW$offset\fR, \f(CW$nbytes\fR, \f(CW$flags\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_sync_file_range $fh, $offset, $nbytes, $flags, $callback->($status)"
Sync the data portion of the file specified by \f(CW$offset\fR and \f(CW$length\fR
to disk (but \s-1NOT\s0 the metadata), by calling the Linux-specific
sync_file_range call. If sync_file_range is not available or it returns
\&\s-1ENOSYS\s0, then fdatasync or fsync is being substituted.
.Sp
\&\f(CW$flags\fR can be a combination of \f(CW\*(C`IO::AIO::SYNC_FILE_RANGE_WAIT_BEFORE\*(C'\fR,
\&\f(CW\*(C`IO::AIO::SYNC_FILE_RANGE_WRITE\*(C'\fR and
\&\f(CW\*(C`IO::AIO::SYNC_FILE_RANGE_WAIT_AFTER\*(C'\fR: refer to the sync_file_range
manpage for details.
.ie n .IP "aio_pathsync $pathname, $callback\->($status)" 4
.el .IP "aio_pathsync \f(CW$pathname\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_pathsync $pathname, $callback->($status)"
This request tries to open, fsync and close the given path. This is a
composite request intended to sync directories after directory operations
(E.g. rename). This might not work on all operating systems or have any
specific effect, but usually it makes sure that directory changes get
written to disc. It works for anything that can be opened for read-only,
not just directories.
.Sp
Future versions of this function might fall back to other methods when
\&\f(CW\*(C`fsync\*(C'\fR on the directory fails (such as calling \f(CW\*(C`sync\*(C'\fR).
.Sp
Passes \f(CW0\fR when everything went ok, and \f(CW\*(C`\-1\*(C'\fR on error.
.ie n .IP "aio_msync $scalar, $offset = 0, $length = undef, flags = 0, $callback\->($status)" 4
.el .IP "aio_msync \f(CW$scalar\fR, \f(CW$offset\fR = 0, \f(CW$length\fR = undef, flags = 0, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_msync $scalar, $offset = 0, $length = undef, flags = 0, $callback->($status)"
This is a rather advanced \s-1IO::AIO\s0 call, which only works on \fImmap\fR\|(2)ed
scalars (see the \f(CW\*(C`IO::AIO::mmap\*(C'\fR function, although it also works on data
scalars managed by the Sys::Mmap or Mmap modules, note that the
scalar must only be modified in-place while an aio operation is pending on
it).
.Sp
It calls the \f(CW\*(C`msync\*(C'\fR function of your \s-1OS\s0, if available, with the memory
area starting at \f(CW$offset\fR in the string and ending \f(CW$length\fR bytes
later. If \f(CW$length\fR is negative, counts from the end, and if \f(CW$length\fR
is \f(CW\*(C`undef\*(C'\fR, then it goes till the end of the string. The flags can be
a combination of \f(CW\*(C`IO::AIO::MS_ASYNC\*(C'\fR, \f(CW\*(C`IO::AIO::MS_INVALIDATE\*(C'\fR and
\&\f(CW\*(C`IO::AIO::MS_SYNC\*(C'\fR.
.ie n .IP "aio_mtouch $scalar, $offset = 0, $length = undef, flags = 0, $callback\->($status)" 4
.el .IP "aio_mtouch \f(CW$scalar\fR, \f(CW$offset\fR = 0, \f(CW$length\fR = undef, flags = 0, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_mtouch $scalar, $offset = 0, $length = undef, flags = 0, $callback->($status)"
This is a rather advanced \s-1IO::AIO\s0 call, which works best on \fImmap\fR\|(2)ed
scalars.
.Sp
It touches (reads or writes) all memory pages in the specified
range inside the scalar.  All caveats and parameters are the same
as for \f(CW\*(C`aio_msync\*(C'\fR, above, except for flags, which must be either
\&\f(CW0\fR (which reads all pages and ensures they are instantiated) or
\&\f(CW\*(C`IO::AIO::MT_MODIFY\*(C'\fR, which modifies the memory page s(by reading and
writing an octet from it, which dirties the page).
.ie n .IP "aio_mlock $scalar, $offset = 0, $length = undef, $callback\->($status)" 4
.el .IP "aio_mlock \f(CW$scalar\fR, \f(CW$offset\fR = 0, \f(CW$length\fR = undef, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_mlock $scalar, $offset = 0, $length = undef, $callback->($status)"
This is a rather advanced \s-1IO::AIO\s0 call, which works best on \fImmap\fR\|(2)ed
scalars.
.Sp
It reads in all the pages of the underlying storage into memory (if any)
and locks them, so they are not getting swapped/paged out or removed.
.Sp
If \f(CW$length\fR is undefined, then the scalar will be locked till the end.
.Sp
On systems that do not implement \f(CW\*(C`mlock\*(C'\fR, this function returns \f(CW\*(C`\-1\*(C'\fR
and sets errno to \f(CW\*(C`ENOSYS\*(C'\fR.
.Sp
Note that the corresponding \f(CW\*(C`munlock\*(C'\fR is synchronous and is
documented under \*(L"\s-1MISCELLANEOUS\s0 \s-1FUNCTIONS\s0\*(R".
.Sp
Example: open a file, mmap and mlock it \- both will be undone when
\&\f(CW$data\fR gets destroyed.
.Sp
.Vb 4
\&   open my $fh, "<", $path or die "$path: $!";
\&   my $data;
\&   IO::AIO::mmap $data, \-s $fh, IO::AIO::PROT_READ, IO::AIO::MAP_SHARED, $fh;
\&   aio_mlock $data; # mlock in background
.Ve
.ie n .IP "aio_mlockall $flags, $callback\->($status)" 4
.el .IP "aio_mlockall \f(CW$flags\fR, \f(CW$callback\fR\->($status)" 4
.IX Item "aio_mlockall $flags, $callback->($status)"
Calls the \f(CW\*(C`mlockall\*(C'\fR function with the given \f(CW$flags\fR (a combination of
\&\f(CW\*(C`IO::AIO::MCL_CURRENT\*(C'\fR and \f(CW\*(C`IO::AIO::MCL_FUTURE\*(C'\fR).
.Sp
On systems that do not implement \f(CW\*(C`mlockall\*(C'\fR, this function returns \f(CW\*(C`\-1\*(C'\fR
and sets errno to \f(CW\*(C`ENOSYS\*(C'\fR.
.Sp
Note that the corresponding \f(CW\*(C`munlockall\*(C'\fR is synchronous and is
documented under \*(L"\s-1MISCELLANEOUS\s0 \s-1FUNCTIONS\s0\*(R".
.Sp
Example: asynchronously lock all current and future pages into memory.
.Sp
.Vb 1
\&   aio_mlockall IO::AIO::MCL_FUTURE;
.Ve
.ie n .IP "aio_fiemap $fh, $start, $length, $flags, $count, $cb\->(\e@extents)" 4
.el .IP "aio_fiemap \f(CW$fh\fR, \f(CW$start\fR, \f(CW$length\fR, \f(CW$flags\fR, \f(CW$count\fR, \f(CW$cb\fR\->(\e@extents)" 4
.IX Item "aio_fiemap $fh, $start, $length, $flags, $count, $cb->(@extents)"
Queries the extents of the given file (by calling the Linux \f(CW\*(C`FIEMAP\*(C'\fR
ioctl, see http://cvs.schmorp.de/IO\-AIO/doc/fiemap.txt <http://cvs.schmorp.de/IO-AIO/doc/fiemap.txt> for details). If
the ioctl is not available on your \s-1OS\s0, then this request will fail with
\&\f(CW\*(C`ENOSYS\*(C'\fR.
.Sp
\&\f(CW$start\fR is the starting offset to query extents for, \f(CW$length\fR is the
size of the range to query \- if it is \f(CW\*(C`undef\*(C'\fR, then the whole file will
be queried.
.Sp
\&\f(CW$flags\fR is a combination of flags (\f(CW\*(C`IO::AIO::FIEMAP_FLAG_SYNC\*(C'\fR or
\&\f(CW\*(C`IO::AIO::FIEMAP_FLAG_XATTR\*(C'\fR \- \f(CW\*(C`IO::AIO::FIEMAP_FLAGS_COMPAT\*(C'\fR is also
exported), and is normally \f(CW0\fR or \f(CW\*(C`IO::AIO::FIEMAP_FLAG_SYNC\*(C'\fR to query
the data portion.
.Sp
\&\f(CW$count\fR is the maximum number of extent records to return. If it is
\&\f(CW\*(C`undef\*(C'\fR, then \s-1IO::AIO\s0 queries all extents of the range. As a very special
case, if it is \f(CW0\fR, then the callback receives the number of extents
instead of the extents themselves (which is unreliable, see below).
.Sp
If an error occurs, the callback receives no arguments. The special
\&\f(CW\*(C`errno\*(C'\fR value \f(CW\*(C`IO::AIO::EBADR\*(C'\fR is available to test for flag errors.
.Sp
Otherwise, the callback receives an array reference with extent
structures. Each extent structure is an array reference itself, with the
following members:
.Sp
.Vb 1
\&   [$logical, $physical, $length, $flags]
.Ve
.Sp
Flags is any combination of the following flag values (typically either \f(CW0\fR
or \f(CW\*(C`IO::AIO::FIEMAP_EXTENT_LAST\*(C'\fR (1)):
.Sp
\&\f(CW\*(C`IO::AIO::FIEMAP_EXTENT_LAST\*(C'\fR, \f(CW\*(C`IO::AIO::FIEMAP_EXTENT_UNKNOWN\*(C'\fR,
\&\f(CW\*(C`IO::AIO::FIEMAP_EXTENT_DELALLOC\*(C'\fR, \f(CW\*(C`IO::AIO::FIEMAP_EXTENT_ENCODED\*(C'\fR,
\&\f(CW\*(C`IO::AIO::FIEMAP_EXTENT_DATA_ENCRYPTED\*(C'\fR, \f(CW\*(C`IO::AIO::FIEMAP_EXTENT_NOT_ALIGNED\*(C'\fR,
\&\f(CW\*(C`IO::AIO::FIEMAP_EXTENT_DATA_INLINE\*(C'\fR, \f(CW\*(C`IO::AIO::FIEMAP_EXTENT_DATA_TAIL\*(C'\fR,
\&\f(CW\*(C`IO::AIO::FIEMAP_EXTENT_UNWRITTEN\*(C'\fR, \f(CW\*(C`IO::AIO::FIEMAP_EXTENT_MERGED\*(C'\fR or
\&\f(CW\*(C`IO::AIO::FIEMAP_EXTENT_SHARED\*(C'\fR.
.Sp
At the time of this writing (Linux 3.2), this requets is unreliable unless
\&\f(CW$count\fR is \f(CW\*(C`undef\*(C'\fR, as the kernel has all sorts of bugs preventing
it to return all extents of a range for files with large number of
extents. The code works around all these issues if \f(CW$count\fR is undef.
.ie n .IP "aio_group $callback\->(...)" 4
.el .IP "aio_group \f(CW$callback\fR\->(...)" 4
.IX Item "aio_group $callback->(...)"
This is a very special aio request: Instead of doing something, it is a
container for other aio requests, which is useful if you want to bundle
many requests into a single, composite, request with a definite callback
and the ability to cancel the whole request with its subrequests.
.Sp
Returns an object of class \s-1IO::AIO::GRP\s0. See its documentation below
for more info.
.Sp
Example:
.Sp
.Vb 3
\&   my $grp = aio_group sub {
\&      print "all stats done\en";
\&   };
\&
\&   add $grp
\&      (aio_stat ...),
\&      (aio_stat ...),
\&      ...;
.Ve
.ie n .IP "aio_nop $callback\->()" 4
.el .IP "aio_nop \f(CW$callback\fR\->()" 4
.IX Item "aio_nop $callback->()"
This is a special request \- it does nothing in itself and is only used for
side effects, such as when you want to add a dummy request to a group so
that finishing the requests in the group depends on executing the given
code.
.Sp
While this request does nothing, it still goes through the execution
phase and still requires a worker thread. Thus, the callback will not
be executed immediately but only after other requests in the queue have
entered their execution phase. This can be used to measure request
latency.
.ie n .IP "IO::AIO::aio_busy $fractional_seconds, $callback\->()  *NOT EXPORTED*" 4
.el .IP "IO::AIO::aio_busy \f(CW$fractional_seconds\fR, \f(CW$callback\fR\->()  *NOT EXPORTED*" 4
.IX Item "IO::AIO::aio_busy $fractional_seconds, $callback->()  *NOT EXPORTED*"
Mainly used for debugging and benchmarking, this aio request puts one of
the request workers to sleep for the given time.
.Sp
While it is theoretically handy to have simple I/O scheduling requests
like sleep and file handle readable/writable, the overhead this creates is
immense (it blocks a thread for a long time) so do not use this function
except to put your application under artificial I/O pressure.
.SS "\s-1IO::AIO::WD\s0 \- multiple working directories"
.IX Subsection "IO::AIO::WD - multiple working directories"
Your process only has one current working directory, which is used by all
threads. This makes it hard to use relative paths (some other component
could call \f(CW\*(C`chdir\*(C'\fR at any time, and it is hard to control when the path
will be used by \s-1IO::AIO\s0).
.PP
One solution for this is to always use absolute paths. This usually works,
but can be quite slow (the kernel has to walk the whole path on every
access), and can also be a hassle to implement.
.PP
Newer \s-1POSIX\s0 systems have a number of functions (openat, fdopendir,
futimensat and so on) that make it possible to specify working directories
per operation.
.PP
For portability, and because the clowns who \*(L"designed\*(R", or shall I write,
perpetrated this new interface were obviously half-drunk, this abstraction
cannot be perfect, though.
.PP
\&\s-1IO::AIO\s0 allows you to convert directory paths into a so-called \s-1IO::AIO::WD\s0
object. This object stores the canonicalised, absolute version of the
path, and on systems that allow it, also a directory file descriptor.
.PP
Everywhere where a pathname is accepted by \s-1IO::AIO\s0 (e.g. in \f(CW\*(C`aio_stat\*(C'\fR
or \f(CW\*(C`aio_unlink\*(C'\fR), one can specify an array reference with an \s-1IO::AIO::WD\s0
object and a pathname instead (or the \s-1IO::AIO::WD\s0 object alone, which
gets interpreted as \f(CW\*(C`[$wd, "."]\*(C'\fR). If the pathname is absolute, the
\&\s-1IO::AIO::WD\s0 object is ignored, otherwise the pathname is resolved relative
to that \s-1IO::AIO::WD\s0 object.
.PP
For example, to get a wd object for \fI/etc\fR and then stat \fIpasswd\fR
inside, you would write:
.PP
.Vb 2
\&   aio_wd "/etc", sub {
\&      my $etcdir = shift;
\&
\&      # although $etcdir can be undef on error, there is generally no reason
\&      # to check for errors here, as aio_stat will fail with ENOENT
\&      # when $etcdir is undef.
\&
\&      aio_stat [$etcdir, "passwd"], sub {
\&         # yay
\&      };
\&   };
.Ve
.PP
That \f(CW\*(C`aio_wd\*(C'\fR is a request and not a normal function shows that creating
an \s-1IO::AIO::WD\s0 object is itself a potentially blocking operation, which is
why it is done asynchronously.
.PP
To stat the directory obtained with \f(CW\*(C`aio_wd\*(C'\fR above, one could write
either of the following three request calls:
.PP
.Vb 3
\&   aio_lstat "/etc"    , sub { ...  # pathname as normal string
\&   aio_lstat [$wd, "."], sub { ...  # "." relative to $wd (i.e. $wd itself)
\&   aio_lstat $wd       , sub { ...  # shorthand for the previous
.Ve
.PP
As with normal pathnames, \s-1IO::AIO\s0 keeps a copy of the working directory
object and the pathname string, so you could write the following without
causing any issues due to \f(CW$path\fR getting reused:
.PP
.Vb 1
\&   my $path = [$wd, undef];
\&
\&   for my $name (qw(abc def ghi)) {
\&      $path\->[1] = $name;
\&      aio_stat $path, sub {
\&         # ...
\&      };
\&   }
.Ve
.PP
There are some caveats: when directories get renamed (or deleted), the
pathname string doesn't change, so will point to the new directory (or
nowhere at all), while the directory fd, if available on the system,
will still point to the original directory. Most functions accepting a
pathname will use the directory fd on newer systems, and the string on
older systems. Some functions (such as realpath) will always rely on the
string form of the pathname.
.PP
So this fucntionality is mainly useful to get some protection against
\&\f(CW\*(C`chdir\*(C'\fR, to easily get an absolute path out of a relative path for future
reference, and to speed up doing many operations in the same directory
(e.g. when stat'ing all files in a directory).
.PP
The following functions implement this working directory abstraction:
.ie n .IP "aio_wd $pathname, $callback\->($wd)" 4
.el .IP "aio_wd \f(CW$pathname\fR, \f(CW$callback\fR\->($wd)" 4
.IX Item "aio_wd $pathname, $callback->($wd)"
Asynchonously canonicalise the given pathname and convert it to an
\&\s-1IO::AIO::WD\s0 object representing it. If possible and supported on the
system, also open a directory fd to speed up pathname resolution relative
to this working directory.
.Sp
If something goes wrong, then \f(CW\*(C`undef\*(C'\fR is passwd to the callback instead
of a working directory object and \f(CW$!\fR is set appropriately. Since
passing \f(CW\*(C`undef\*(C'\fR as working directory component of a pathname fails the
request with \f(CW\*(C`ENOENT\*(C'\fR, there is often no need for error checking in the
\&\f(CW\*(C`aio_wd\*(C'\fR callback, as future requests using the value will fail in the
expected way.
.Sp
If this call isn't available because your \s-1OS\s0 lacks it or it couldn't be
detected, it will be emulated by calling \f(CW\*(C`fsync\*(C'\fR instead.
.IP "\s-1IO::AIO::CWD\s0" 4
.IX Item "IO::AIO::CWD"
This is a compiletime constant (object) that represents the process
current working directory.
.Sp
Specifying this object as working directory object for a pathname is as
if the pathname would be specified directly, without a directory object,
e.g., these calls are functionally identical:
.Sp
.Vb 2
\&   aio_stat "somefile", sub { ... };
\&   aio_stat [IO::AIO::CWD, "somefile"], sub { ... };
.Ve
.SS "\s-1IO::AIO::REQ\s0 \s-1CLASS\s0"
.IX Subsection "IO::AIO::REQ CLASS"
All non-aggregate \f(CW\*(C`aio_*\*(C'\fR functions return an object of this class when
called in non-void context.
.ie n .IP "cancel $req" 4
.el .IP "cancel \f(CW$req\fR" 4
.IX Item "cancel $req"
Cancels the request, if possible. Has the effect of skipping execution
when entering the \fBexecute\fR state and skipping calling the callback when
entering the the \fBresult\fR state, but will leave the request otherwise
untouched (with the exception of readdir). That means that requests that
currently execute will not be stopped and resources held by the request
will not be freed prematurely.
.ie n .IP "cb $req $callback\->(...)" 4
.el .IP "cb \f(CW$req\fR \f(CW$callback\fR\->(...)" 4
.IX Item "cb $req $callback->(...)"
Replace (or simply set) the callback registered to the request.
.SS "\s-1IO::AIO::GRP\s0 \s-1CLASS\s0"
.IX Subsection "IO::AIO::GRP CLASS"
This class is a subclass of \s-1IO::AIO::REQ\s0, so all its methods apply to
objects of this class, too.
.PP
A \s-1IO::AIO::GRP\s0 object is a special request that can contain multiple other
aio requests.
.PP
You create one by calling the \f(CW\*(C`aio_group\*(C'\fR constructing function with a
callback that will be called when all contained requests have entered the
\&\f(CW\*(C`done\*(C'\fR state:
.PP
.Vb 3
\&   my $grp = aio_group sub {
\&      print "all requests are done\en";
\&   };
.Ve
.PP
You add requests by calling the \f(CW\*(C`add\*(C'\fR method with one or more
\&\f(CW\*(C`IO::AIO::REQ\*(C'\fR objects:
.PP
.Vb 1
\&   $grp\->add (aio_unlink "...");
\&
\&   add $grp aio_stat "...", sub {
\&      $_[0] or return $grp\->result ("error");
\&
\&      # add another request dynamically, if first succeeded
\&      add $grp aio_open "...", sub {
\&         $grp\->result ("ok");
\&      };
\&   };
.Ve
.PP
This makes it very easy to create composite requests (see the source of
\&\f(CW\*(C`aio_move\*(C'\fR for an application) that work and feel like simple requests.
.IP "\(bu" 4
The \s-1IO::AIO::GRP\s0 objects will be cleaned up during calls to
\&\f(CW\*(C`IO::AIO::poll_cb\*(C'\fR, just like any other request.
.IP "\(bu" 4
They can be canceled like any other request. Canceling will cancel not
only the request itself, but also all requests it contains.
.IP "\(bu" 4
They can also can also be added to other \s-1IO::AIO::GRP\s0 objects.
.IP "\(bu" 4
You must not add requests to a group from within the group callback (or
any later time).
.PP
Their lifetime, simplified, looks like this: when they are empty, they
will finish very quickly. If they contain only requests that are in the
\&\f(CW\*(C`done\*(C'\fR state, they will also finish. Otherwise they will continue to
exist.
.PP
That means after creating a group you have some time to add requests
(precisely before the callback has been invoked, which is only done within
the \f(CW\*(C`poll_cb\*(C'\fR). And in the callbacks of those requests, you can add
further requests to the group. And only when all those requests have
finished will the the group itself finish.
.ie n .IP "add $grp ..." 4
.el .IP "add \f(CW$grp\fR ..." 4
.IX Item "add $grp ..."
.PD 0
.ie n .IP "$grp\->add (...)" 4
.el .IP "\f(CW$grp\fR\->add (...)" 4
.IX Item "$grp->add (...)"
.PD
Add one or more requests to the group. Any type of \s-1IO::AIO::REQ\s0 can
be added, including other groups, as long as you do not create circular
dependencies.
.Sp
Returns all its arguments.
.ie n .IP "$grp\->cancel_subs" 4
.el .IP "\f(CW$grp\fR\->cancel_subs" 4
.IX Item "$grp->cancel_subs"
Cancel all subrequests and clears any feeder, but not the group request
itself. Useful when you queued a lot of events but got a result early.
.Sp
The group request will finish normally (you cannot add requests to the
group).
.ie n .IP "$grp\->result (...)" 4
.el .IP "\f(CW$grp\fR\->result (...)" 4
.IX Item "$grp->result (...)"
Set the result value(s) that will be passed to the group callback when all
subrequests have finished and set the groups errno to the current value
of errno (just like calling \f(CW\*(C`errno\*(C'\fR without an error number). By default,
no argument will be passed and errno is zero.
.ie n .IP "$grp\->errno ([$errno])" 4
.el .IP "\f(CW$grp\fR\->errno ([$errno])" 4
.IX Item "$grp->errno ([$errno])"
Sets the group errno value to \f(CW$errno\fR, or the current value of errno
when the argument is missing.
.Sp
Every aio request has an associated errno value that is restored when
the callback is invoked. This method lets you change this value from its
default (0).
.Sp
Calling \f(CW\*(C`result\*(C'\fR will also set errno, so make sure you either set \f(CW$!\fR
before the call to \f(CW\*(C`result\*(C'\fR, or call c<errno> after it.
.ie n .IP "feed $grp $callback\->($grp)" 4
.el .IP "feed \f(CW$grp\fR \f(CW$callback\fR\->($grp)" 4
.IX Item "feed $grp $callback->($grp)"
Sets a feeder/generator on this group: every group can have an attached
generator that generates requests if idle. The idea behind this is that,
although you could just queue as many requests as you want in a group,
this might starve other requests for a potentially long time. For example,
\&\f(CW\*(C`aio_scandir\*(C'\fR might generate hundreds of thousands of \f(CW\*(C`aio_stat\*(C'\fR
requests, delaying any later requests for a long time.
.Sp
To avoid this, and allow incremental generation of requests, you can
instead a group and set a feeder on it that generates those requests. The
feed callback will be called whenever there are few enough (see \f(CW\*(C`limit\*(C'\fR,
below) requests active in the group itself and is expected to queue more
requests.
.Sp
The feed callback can queue as many requests as it likes (i.e. \f(CW\*(C`add\*(C'\fR does
not impose any limits).
.Sp
If the feed does not queue more requests when called, it will be
automatically removed from the group.
.Sp
If the feed limit is \f(CW0\fR when this method is called, it will be set to
\&\f(CW2\fR automatically.
.Sp
Example:
.Sp
.Vb 1
\&   # stat all files in @files, but only ever use four aio requests concurrently:
\&
\&   my $grp = aio_group sub { print "finished\en" };
\&   limit $grp 4;
\&   feed $grp sub {
\&      my $file = pop @files
\&         or return;
\&
\&      add $grp aio_stat $file, sub { ... };
\&   };
.Ve
.ie n .IP "limit $grp $num" 4
.el .IP "limit \f(CW$grp\fR \f(CW$num\fR" 4
.IX Item "limit $grp $num"
Sets the feeder limit for the group: The feeder will be called whenever
the group contains less than this many requests.
.Sp
Setting the limit to \f(CW0\fR will pause the feeding process.
.Sp
The default value for the limit is \f(CW0\fR, but note that setting a feeder
automatically bumps it up to \f(CW2\fR.
.SS "\s-1SUPPORT\s0 \s-1FUNCTIONS\s0"
.IX Subsection "SUPPORT FUNCTIONS"
\fI\s-1EVENT\s0 \s-1PROCESSING\s0 \s-1AND\s0 \s-1EVENT\s0 \s-1LOOP\s0 \s-1INTEGRATION\s0\fR
.IX Subsection "EVENT PROCESSING AND EVENT LOOP INTEGRATION"
.ie n .IP "$fileno = IO::AIO::poll_fileno" 4
.el .IP "\f(CW$fileno\fR = IO::AIO::poll_fileno" 4
.IX Item "$fileno = IO::AIO::poll_fileno"
Return the \fIrequest result pipe file descriptor\fR. This filehandle must be
polled for reading by some mechanism outside this module (e.g. \s-1EV\s0, Glib,
select and so on, see below or the \s-1SYNOPSIS\s0). If the pipe becomes readable
you have to call \f(CW\*(C`poll_cb\*(C'\fR to check the results.
.Sp
See \f(CW\*(C`poll_cb\*(C'\fR for an example.
.IP "IO::AIO::poll_cb" 4
.IX Item "IO::AIO::poll_cb"
Process some outstanding events on the result pipe. You have to call
this regularly. Returns \f(CW0\fR if all events could be processed (or there
were no events to process), or \f(CW\*(C`\-1\*(C'\fR if it returned earlier for whatever
reason. Returns immediately when no events are outstanding. The amount of
events processed depends on the settings of \f(CW\*(C`IO::AIO::max_poll_req\*(C'\fR and
\&\f(CW\*(C`IO::AIO::max_poll_time\*(C'\fR.
.Sp
If not all requests were processed for whatever reason, the filehandle
will still be ready when \f(CW\*(C`poll_cb\*(C'\fR returns, so normally you don't have to
do anything special to have it called later.
.Sp
Apart from calling \f(CW\*(C`IO::AIO::poll_cb\*(C'\fR when the event filehandle becomes
ready, it can be beneficial to call this function from loops which submit
a lot of requests, to make sure the results get processed when they become
available and not just when the loop is finished and the event loop takes
over again. This function returns very fast when there are no outstanding
requests.
.Sp
Example: Install an Event watcher that automatically calls
IO::AIO::poll_cb with high priority (more examples can be found in the
\&\s-1SYNOPSIS\s0 section, at the top of this document):
.Sp
.Vb 3
\&   Event\->io (fd => IO::AIO::poll_fileno,
\&              poll => \*(Aqr\*(Aq, async => 1,
\&              cb => \e&IO::AIO::poll_cb);
.Ve
.IP "IO::AIO::poll_wait" 4
.IX Item "IO::AIO::poll_wait"
If there are any outstanding requests and none of them in the result
phase, wait till the result filehandle becomes ready for reading (simply
does a \f(CW\*(C`select\*(C'\fR on the filehandle. This is useful if you want to
synchronously wait for some requests to finish).
.Sp
See \f(CW\*(C`nreqs\*(C'\fR for an example.
.IP "IO::AIO::poll" 4
.IX Item "IO::AIO::poll"
Waits until some requests have been handled.
.Sp
Returns the number of requests processed, but is otherwise strictly
equivalent to:
.Sp
.Vb 1
\&   IO::AIO::poll_wait, IO::AIO::poll_cb
.Ve
.IP "IO::AIO::flush" 4
.IX Item "IO::AIO::flush"
Wait till all outstanding \s-1AIO\s0 requests have been handled.
.Sp
Strictly equivalent to:
.Sp
.Vb 2
\&   IO::AIO::poll_wait, IO::AIO::poll_cb
\&      while IO::AIO::nreqs;
.Ve
.ie n .IP "IO::AIO::max_poll_reqs $nreqs" 4
.el .IP "IO::AIO::max_poll_reqs \f(CW$nreqs\fR" 4
.IX Item "IO::AIO::max_poll_reqs $nreqs"
.PD 0
.ie n .IP "IO::AIO::max_poll_time $seconds" 4
.el .IP "IO::AIO::max_poll_time \f(CW$seconds\fR" 4
.IX Item "IO::AIO::max_poll_time $seconds"
.PD
These set the maximum number of requests (default \f(CW0\fR, meaning infinity)
that are being processed by \f(CW\*(C`IO::AIO::poll_cb\*(C'\fR in one call, respectively
the maximum amount of time (default \f(CW0\fR, meaning infinity) spent in
\&\f(CW\*(C`IO::AIO::poll_cb\*(C'\fR to process requests (more correctly the mininum amount
of time \f(CW\*(C`poll_cb\*(C'\fR is allowed to use).
.Sp
Setting \f(CW\*(C`max_poll_time\*(C'\fR to a non-zero value creates an overhead of one
syscall per request processed, which is not normally a problem unless your
callbacks are really really fast or your \s-1OS\s0 is really really slow (I am
not mentioning Solaris here). Using \f(CW\*(C`max_poll_reqs\*(C'\fR incurs no overhead.
.Sp
Setting these is useful if you want to ensure some level of
interactiveness when perl is not fast enough to process all requests in
time.
.Sp
For interactive programs, values such as \f(CW0.01\fR to \f(CW0.1\fR should be fine.
.Sp
Example: Install an Event watcher that automatically calls
IO::AIO::poll_cb with low priority, to ensure that other parts of the
program get the \s-1CPU\s0 sometimes even under high \s-1AIO\s0 load.
.Sp
.Vb 2
\&   # try not to spend much more than 0.1s in poll_cb
\&   IO::AIO::max_poll_time 0.1;
\&
\&   # use a low priority so other tasks have priority
\&   Event\->io (fd => IO::AIO::poll_fileno,
\&              poll => \*(Aqr\*(Aq, nice => 1,
\&              cb => &IO::AIO::poll_cb);
.Ve
.PP
\fI\s-1CONTROLLING\s0 \s-1THE\s0 \s-1NUMBER\s0 \s-1OF\s0 \s-1THREADS\s0\fR
.IX Subsection "CONTROLLING THE NUMBER OF THREADS"
.ie n .IP "IO::AIO::min_parallel $nthreads" 4
.el .IP "IO::AIO::min_parallel \f(CW$nthreads\fR" 4
.IX Item "IO::AIO::min_parallel $nthreads"
Set the minimum number of \s-1AIO\s0 threads to \f(CW$nthreads\fR. The current
default is \f(CW8\fR, which means eight asynchronous operations can execute
concurrently at any one time (the number of outstanding requests,
however, is unlimited).
.Sp
\&\s-1IO::AIO\s0 starts threads only on demand, when an \s-1AIO\s0 request is queued and
no free thread exists. Please note that queueing up a hundred requests can
create demand for a hundred threads, even if it turns out that everything
is in the cache and could have been processed faster by a single thread.
.Sp
It is recommended to keep the number of threads relatively low, as some
Linux kernel versions will scale negatively with the number of threads
(higher parallelity => \s-1MUCH\s0 higher latency). With current Linux 2.6
versions, 4\-32 threads should be fine.
.Sp
Under most circumstances you don't need to call this function, as the
module selects a default that is suitable for low to moderate load.
.ie n .IP "IO::AIO::max_parallel $nthreads" 4
.el .IP "IO::AIO::max_parallel \f(CW$nthreads\fR" 4
.IX Item "IO::AIO::max_parallel $nthreads"
Sets the maximum number of \s-1AIO\s0 threads to \f(CW$nthreads\fR. If more than the
specified number of threads are currently running, this function kills
them. This function blocks until the limit is reached.
.Sp
While \f(CW$nthreads\fR are zero, aio requests get queued but not executed
until the number of threads has been increased again.
.Sp
This module automatically runs \f(CW\*(C`max_parallel 0\*(C'\fR at program end, to ensure
that all threads are killed and that there are no outstanding requests.
.Sp
Under normal circumstances you don't need to call this function.
.ie n .IP "IO::AIO::max_idle $nthreads" 4
.el .IP "IO::AIO::max_idle \f(CW$nthreads\fR" 4
.IX Item "IO::AIO::max_idle $nthreads"
Limit the number of threads (default: 4) that are allowed to idle
(i.e., threads that did not get a request to process within the idle
timeout (default: 10 seconds). That means if a thread becomes idle while
\&\f(CW$nthreads\fR other threads are also idle, it will free its resources and
exit.
.Sp
This is useful when you allow a large number of threads (e.g. 100 or 1000)
to allow for extremely high load situations, but want to free resources
under normal circumstances (1000 threads can easily consume 30MB of \s-1RAM\s0).
.Sp
The default is probably ok in most situations, especially if thread
creation is fast. If thread creation is very slow on your system you might
want to use larger values.
.ie n .IP "IO::AIO::idle_timeout $seconds" 4
.el .IP "IO::AIO::idle_timeout \f(CW$seconds\fR" 4
.IX Item "IO::AIO::idle_timeout $seconds"
Sets the minimum idle timeout (default 10) after which worker threads are
allowed to exit. SEe \f(CW\*(C`IO::AIO::max_idle\*(C'\fR.
.ie n .IP "IO::AIO::max_outstanding $maxreqs" 4
.el .IP "IO::AIO::max_outstanding \f(CW$maxreqs\fR" 4
.IX Item "IO::AIO::max_outstanding $maxreqs"
Sets the maximum number of outstanding requests to \f(CW$nreqs\fR. If
you do queue up more than this number of requests, the next call to
\&\f(CW\*(C`IO::AIO::poll_cb\*(C'\fR (and other functions calling \f(CW\*(C`poll_cb\*(C'\fR, such as
\&\f(CW\*(C`IO::AIO::flush\*(C'\fR or \f(CW\*(C`IO::AIO::poll\*(C'\fR) will block until the limit is no
longer exceeded.
.Sp
In other words, this setting does not enforce a queue limit, but can be
used to make poll functions block if the limit is exceeded.
.Sp
This is a very bad function to use in interactive programs because it
blocks, and a bad way to reduce concurrency because it is inexact: Better
use an \f(CW\*(C`aio_group\*(C'\fR together with a feed callback.
.Sp
It's main use is in scripts without an event loop \- when you want to stat
a lot of files, you can write somehting like this:
.Sp
.Vb 1
\&   IO::AIO::max_outstanding 32;
\&
\&   for my $path (...) {
\&      aio_stat $path , ...;
\&      IO::AIO::poll_cb;
\&   }
\&
\&   IO::AIO::flush;
.Ve
.Sp
The call to \f(CW\*(C`poll_cb\*(C'\fR inside the loop will normally return instantly, but
as soon as more thna \f(CW32\fR reqeusts are in-flight, it will block until
some requests have been handled. This keeps the loop from pushing a large
number of \f(CW\*(C`aio_stat\*(C'\fR requests onto the queue.
.Sp
The default value for \f(CW\*(C`max_outstanding\*(C'\fR is very large, so there is no
practical limit on the number of outstanding requests.
.PP
\fI\s-1STATISTICAL\s0 \s-1INFORMATION\s0\fR
.IX Subsection "STATISTICAL INFORMATION"
.IP "IO::AIO::nreqs" 4
.IX Item "IO::AIO::nreqs"
Returns the number of requests currently in the ready, execute or pending
states (i.e. for which their callback has not been invoked yet).
.Sp
Example: wait till there are no outstanding requests anymore:
.Sp
.Vb 2
\&   IO::AIO::poll_wait, IO::AIO::poll_cb
\&      while IO::AIO::nreqs;
.Ve
.IP "IO::AIO::nready" 4
.IX Item "IO::AIO::nready"
Returns the number of requests currently in the ready state (not yet
executed).
.IP "IO::AIO::npending" 4
.IX Item "IO::AIO::npending"
Returns the number of requests currently in the pending state (executed,
but not yet processed by poll_cb).
.PP
\fI\s-1MISCELLANEOUS\s0 \s-1FUNCTIONS\s0\fR
.IX Subsection "MISCELLANEOUS FUNCTIONS"
.PP
\&\s-1IO::AIO\s0 implements some functions that might be useful, but are not
asynchronous.
.ie n .IP "IO::AIO::sendfile $ofh, $ifh, $offset, $count" 4
.el .IP "IO::AIO::sendfile \f(CW$ofh\fR, \f(CW$ifh\fR, \f(CW$offset\fR, \f(CW$count\fR" 4
.IX Item "IO::AIO::sendfile $ofh, $ifh, $offset, $count"
Calls the \f(CW\*(C`eio_sendfile_sync\*(C'\fR function, which is like \f(CW\*(C`aio_sendfile\*(C'\fR,
but is blocking (this makes most sense if you know the input data is
likely cached already and the output filehandle is set to non-blocking
operations).
.Sp
Returns the number of bytes copied, or \f(CW\*(C`\-1\*(C'\fR on error.
.ie n .IP "IO::AIO::fadvise $fh, $offset, $len, $advice" 4
.el .IP "IO::AIO::fadvise \f(CW$fh\fR, \f(CW$offset\fR, \f(CW$len\fR, \f(CW$advice\fR" 4
.IX Item "IO::AIO::fadvise $fh, $offset, $len, $advice"
Simply calls the \f(CW\*(C`posix_fadvise\*(C'\fR function (see its
manpage for details). The following advice constants are
available: \f(CW\*(C`IO::AIO::FADV_NORMAL\*(C'\fR, \f(CW\*(C`IO::AIO::FADV_SEQUENTIAL\*(C'\fR,
\&\f(CW\*(C`IO::AIO::FADV_RANDOM\*(C'\fR, \f(CW\*(C`IO::AIO::FADV_NOREUSE\*(C'\fR,
\&\f(CW\*(C`IO::AIO::FADV_WILLNEED\*(C'\fR, \f(CW\*(C`IO::AIO::FADV_DONTNEED\*(C'\fR.
.Sp
On systems that do not implement \f(CW\*(C`posix_fadvise\*(C'\fR, this function returns
\&\s-1ENOSYS\s0, otherwise the return value of \f(CW\*(C`posix_fadvise\*(C'\fR.
.ie n .IP "IO::AIO::madvise $scalar, $offset, $len, $advice" 4
.el .IP "IO::AIO::madvise \f(CW$scalar\fR, \f(CW$offset\fR, \f(CW$len\fR, \f(CW$advice\fR" 4
.IX Item "IO::AIO::madvise $scalar, $offset, $len, $advice"
Simply calls the \f(CW\*(C`posix_madvise\*(C'\fR function (see its
manpage for details). The following advice constants are
available: \f(CW\*(C`IO::AIO::MADV_NORMAL\*(C'\fR, \f(CW\*(C`IO::AIO::MADV_SEQUENTIAL\*(C'\fR,
\&\f(CW\*(C`IO::AIO::MADV_RANDOM\*(C'\fR, \f(CW\*(C`IO::AIO::MADV_WILLNEED\*(C'\fR, \f(CW\*(C`IO::AIO::MADV_DONTNEED\*(C'\fR.
.Sp
On systems that do not implement \f(CW\*(C`posix_madvise\*(C'\fR, this function returns
\&\s-1ENOSYS\s0, otherwise the return value of \f(CW\*(C`posix_madvise\*(C'\fR.
.ie n .IP "IO::AIO::mprotect $scalar, $offset, $len, $protect" 4
.el .IP "IO::AIO::mprotect \f(CW$scalar\fR, \f(CW$offset\fR, \f(CW$len\fR, \f(CW$protect\fR" 4
.IX Item "IO::AIO::mprotect $scalar, $offset, $len, $protect"
Simply calls the \f(CW\*(C`mprotect\*(C'\fR function on the preferably AIO::mmap'ed
\&\f(CW$scalar\fR (see its manpage for details). The following protect
constants are available: \f(CW\*(C`IO::AIO::PROT_NONE\*(C'\fR, \f(CW\*(C`IO::AIO::PROT_READ\*(C'\fR,
\&\f(CW\*(C`IO::AIO::PROT_WRITE\*(C'\fR, \f(CW\*(C`IO::AIO::PROT_EXEC\*(C'\fR.
.Sp
On systems that do not implement \f(CW\*(C`mprotect\*(C'\fR, this function returns
\&\s-1ENOSYS\s0, otherwise the return value of \f(CW\*(C`mprotect\*(C'\fR.
.ie n .IP "IO::AIO::mmap $scalar, $length, $prot, $flags, $fh[, $offset]" 4
.el .IP "IO::AIO::mmap \f(CW$scalar\fR, \f(CW$length\fR, \f(CW$prot\fR, \f(CW$flags\fR, \f(CW$fh\fR[, \f(CW$offset\fR]" 4
.IX Item "IO::AIO::mmap $scalar, $length, $prot, $flags, $fh[, $offset]"
Memory-maps a file (or anonymous memory range) and attaches it to the
given \f(CW$scalar\fR, which will act like a string scalar. Returns true on
success, and false otherwise.
.Sp
The only operations allowed on the scalar are \f(CW\*(C`substr\*(C'\fR/\f(CW\*(C`vec\*(C'\fR that don't
change the string length, and most read-only operations such as copying it
or searching it with regexes and so on.
.Sp
Anything else is unsafe and will, at best, result in memory leaks.
.Sp
The memory map associated with the \f(CW$scalar\fR is automatically removed
when the \f(CW$scalar\fR is destroyed, or when the \f(CW\*(C`IO::AIO::mmap\*(C'\fR or
\&\f(CW\*(C`IO::AIO::munmap\*(C'\fR functions are called.
.Sp
This calls the \f(CW\*(C`mmap\*(C'\fR(2) function internally. See your system's manual
page for details on the \f(CW$length\fR, \f(CW$prot\fR and \f(CW$flags\fR parameters.
.Sp
The \f(CW$length\fR must be larger than zero and smaller than the actual
filesize.
.Sp
\&\f(CW$prot\fR is a combination of \f(CW\*(C`IO::AIO::PROT_NONE\*(C'\fR, \f(CW\*(C`IO::AIO::PROT_EXEC\*(C'\fR,
\&\f(CW\*(C`IO::AIO::PROT_READ\*(C'\fR and/or \f(CW\*(C`IO::AIO::PROT_WRITE\*(C'\fR,
.Sp
\&\f(CW$flags\fR can be a combination of \f(CW\*(C`IO::AIO::MAP_SHARED\*(C'\fR or
\&\f(CW\*(C`IO::AIO::MAP_PRIVATE\*(C'\fR, or a number of system-specific flags (when
not available, the are defined as 0): \f(CW\*(C`IO::AIO::MAP_ANONYMOUS\*(C'\fR
(which is set to \f(CW\*(C`MAP_ANON\*(C'\fR if your system only provides this
constant), \f(CW\*(C`IO::AIO::MAP_HUGETLB\*(C'\fR, \f(CW\*(C`IO::AIO::MAP_LOCKED\*(C'\fR,
\&\f(CW\*(C`IO::AIO::MAP_NORESERVE\*(C'\fR, \f(CW\*(C`IO::AIO::MAP_POPULATE\*(C'\fR or
\&\f(CW\*(C`IO::AIO::MAP_NONBLOCK\*(C'\fR
.Sp
If \f(CW$fh\fR is \f(CW\*(C`undef\*(C'\fR, then a file descriptor of \f(CW\*(C`\-1\*(C'\fR is passed.
.Sp
\&\f(CW$offset\fR is the offset from the start of the file \- it generally must be
a multiple of \f(CW\*(C`IO::AIO::PAGESIZE\*(C'\fR and defaults to \f(CW0\fR.
.Sp
Example:
.Sp
.Vb 2
\&   use Digest::MD5;
\&   use IO::AIO;
\&
\&   open my $fh, "<verybigfile"
\&      or die "$!";
\&
\&   IO::AIO::mmap my $data, \-s $fh, IO::AIO::PROT_READ, IO::AIO::MAP_SHARED, $fh
\&      or die "verybigfile: $!";
\&
\&   my $fast_md5 = md5 $data;
.Ve
.ie n .IP "IO::AIO::munmap $scalar" 4
.el .IP "IO::AIO::munmap \f(CW$scalar\fR" 4
.IX Item "IO::AIO::munmap $scalar"
Removes a previous mmap and undefines the \f(CW$scalar\fR.
.ie n .IP "IO::AIO::munlock $scalar, $offset = 0, $length = undef" 4
.el .IP "IO::AIO::munlock \f(CW$scalar\fR, \f(CW$offset\fR = 0, \f(CW$length\fR = undef" 4
.IX Item "IO::AIO::munlock $scalar, $offset = 0, $length = undef"
Calls the \f(CW\*(C`munlock\*(C'\fR function, undoing the effects of a previous
\&\f(CW\*(C`aio_mlock\*(C'\fR call (see its description for details).
.IP "IO::AIO::munlockall" 4
.IX Item "IO::AIO::munlockall"
Calls the \f(CW\*(C`munlockall\*(C'\fR function.
.Sp
On systems that do not implement \f(CW\*(C`munlockall\*(C'\fR, this function returns
\&\s-1ENOSYS\s0, otherwise the return value of \f(CW\*(C`munlockall\*(C'\fR.
.ie n .IP "IO::AIO::splice $r_fh, $r_off, $w_fh, $w_off, $length, $flags" 4
.el .IP "IO::AIO::splice \f(CW$r_fh\fR, \f(CW$r_off\fR, \f(CW$w_fh\fR, \f(CW$w_off\fR, \f(CW$length\fR, \f(CW$flags\fR" 4
.IX Item "IO::AIO::splice $r_fh, $r_off, $w_fh, $w_off, $length, $flags"
Calls the GNU/Linux \f(CWsplice(2)\fR syscall, if available. If \f(CW$r_off\fR or
\&\f(CW$w_off\fR are \f(CW\*(C`undef\*(C'\fR, then \f(CW\*(C`NULL\*(C'\fR is passed for these, otherwise they
should be the file offset.
.Sp
\&\f(CW$r_fh\fR and \f(CW$w_fh\fR should not refer to the same file, as splice might
silently corrupt the data in this case.
.Sp
The following symbol flag values are available: \f(CW\*(C`IO::AIO::SPLICE_F_MOVE\*(C'\fR,
\&\f(CW\*(C`IO::AIO::SPLICE_F_NONBLOCK\*(C'\fR, \f(CW\*(C`IO::AIO::SPLICE_F_MORE\*(C'\fR and
\&\f(CW\*(C`IO::AIO::SPLICE_F_GIFT\*(C'\fR.
.Sp
See the \f(CWsplice(2)\fR manpage for details.
.ie n .IP "IO::AIO::tee $r_fh, $w_fh, $length, $flags" 4
.el .IP "IO::AIO::tee \f(CW$r_fh\fR, \f(CW$w_fh\fR, \f(CW$length\fR, \f(CW$flags\fR" 4
.IX Item "IO::AIO::tee $r_fh, $w_fh, $length, $flags"
Calls the GNU/Linux \f(CWtee(2)\fR syscall, see it's manpage and the
description for \f(CW\*(C`IO::AIO::splice\*(C'\fR above for details.
.SH "EVENT LOOP INTEGRATION"
.IX Header "EVENT LOOP INTEGRATION"
It is recommended to use AnyEvent::AIO to integrate \s-1IO::AIO\s0
automatically into many event loops:
.PP
.Vb 2
\& # AnyEvent integration (EV, Event, Glib, Tk, POE, urxvt, pureperl...)
\& use AnyEvent::AIO;
.Ve
.PP
You can also integrate \s-1IO::AIO\s0 manually into many event loops, here are
some examples of how to do this:
.PP
.Vb 2
\& # EV integration
\& my $aio_w = EV::io IO::AIO::poll_fileno, EV::READ, \e&IO::AIO::poll_cb;
\&
\& # Event integration
\& Event\->io (fd => IO::AIO::poll_fileno,
\&            poll => \*(Aqr\*(Aq,
\&            cb => \e&IO::AIO::poll_cb);
\&
\& # Glib/Gtk2 integration
\& add_watch Glib::IO IO::AIO::poll_fileno,
\&           in => sub { IO::AIO::poll_cb; 1 };
\&
\& # Tk integration
\& Tk::Event::IO\->fileevent (IO::AIO::poll_fileno, "",
\&                           readable => \e&IO::AIO::poll_cb);
\&
\& # Danga::Socket integration
\& Danga::Socket\->AddOtherFds (IO::AIO::poll_fileno =>
\&                             \e&IO::AIO::poll_cb);
.Ve
.SS "\s-1FORK\s0 \s-1BEHAVIOUR\s0"
.IX Subsection "FORK BEHAVIOUR"
Usage of pthreads in a program changes the semantics of fork
considerably. Specifically, only async-safe functions can be called after
fork. Perl doesn't know about this, so in general, you cannot call fork
with defined behaviour in perl if pthreads are involved. \s-1IO::AIO\s0 uses
pthreads, so this applies, but many other extensions and (for inexplicable
reasons) perl itself often is linked against pthreads, so this limitation
applies to quite a lot of perls.
.PP
This module no longer tries to fight your \s-1OS\s0, or \s-1POSIX\s0. That means \s-1IO::AIO\s0
only works in the process that loaded it. Forking is fully supported, but
using \s-1IO::AIO\s0 in the child is not.
.PP
You might get around by not \fIusing\fR \s-1IO::AIO\s0 before (or after)
forking. You could also try to call the IO::AIO::reinit function in the
child:
.IP "IO::AIO::reinit" 4
.IX Item "IO::AIO::reinit"
Abandons all current requests and I/O threads and simply reinitialises all
data structures. This is not an operation supported by any standards, but
happens to work on GNU/Linux and some newer \s-1BSD\s0 systems.
.Sp
The only reasonable use for this function is to call it after forking, if
\&\f(CW\*(C`IO::AIO\*(C'\fR was used in the parent. Calling it while \s-1IO::AIO\s0 is active in
the process will result in undefined behaviour. Calling it at any time
will also result in any undefined (by \s-1POSIX\s0) behaviour.
.SS "\s-1MEMORY\s0 \s-1USAGE\s0"
.IX Subsection "MEMORY USAGE"
Per-request usage:
.PP
Each aio request uses \- depending on your architecture \- around 100\-200
bytes of memory. In addition, stat requests need a stat buffer (possibly
a few hundred bytes), readdir requires a result buffer and so on. Perl
scalars and other data passed into aio requests will also be locked and
will consume memory till the request has entered the done state.
.PP
This is not awfully much, so queuing lots of requests is not usually a
problem.
.PP
Per-thread usage:
.PP
In the execution phase, some aio requests require more memory for
temporary buffers, and each thread requires a stack and other data
structures (usually around 16k\-128k, depending on the \s-1OS\s0).
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
Known bugs will be fixed in the next release.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AnyEvent::AIO for easy integration into event loops, Coro::AIO for a
more natural syntax.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 2
\& Marc Lehmann <schmorp@schmorp.de>
\& http://home.schmorp.de/
.Ve
