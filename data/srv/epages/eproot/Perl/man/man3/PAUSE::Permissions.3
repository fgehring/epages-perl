.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PAUSE::Permissions 3"
.TH PAUSE::Permissions 3 "2017-05-15" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PAUSE::Permissions \- interface to PAUSE's module permissions file (06perms.txt)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use PAUSE::Permissions 0.08;
\&  
\&  my $pp = PAUSE::Permissions\->new(max_age => \*(Aq1 day\*(Aq);
\&  my $mp = $pp\->module_permissions(\*(AqHTTP::Client\*(Aq);
\&  
\&  my $owner    = $mp\->owner;
\&  my @comaints = $mp\->co_maintainers;
\&
\&  my $iterator = $pp\->module_iterator();
\&  while (my $mp = $iterator\->next_module) {
\&    print "module = ", $mp\->name, "\en";
\&    print "  owner = ", $mp\->owner // \*(Aqnone\*(Aq, "\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PAUSE::Permissions provides an interface to the \f(CW\*(C`06perms.txt\*(C'\fR file produced by
the Perl Authors Upload Server (\s-1PAUSE\s0).
The file records who has what permissions for every module on \s-1CPAN\s0.
The format and interpretation of this file
are covered in \*(L"The 06perms.txt file\*(R" below.
.PP
By default, the module will mirror \f(CW\*(C`06perms.txt\*(C'\fR from \s-1CPAN\s0,
using HTTP::Tiny to request it and store it locally
What gets cached locally is actually a transformed version of 06perms.txt
for easier processing.
.PP
By default it will get the file from <http://www.cpan.org>, but you can
pass an alternate \s-1URI\s0 to the constructor:
.PP
.Vb 2
\&  $perms_uri = "http://$CPAN_MIRROR/modules/06perms.txt";
\&  $pp = PAUSE::Permissions\->new(uri => $perms_uri);
.Ve
.PP
If you've already got a copy lying around, you can tell the module to use that:
.PP
.Vb 1
\&  $pp = PAUSE::Permissions\->new( path => \*(Aq/tmp/my06perms.txt\*(Aq );
.Ve
.PP
Note that the file you provide this way must be in the post-processed
format, and not a raw copy of \f(CW\*(C`06perms.txt\*(C'\fR.
.PP
Having created an instance of \f(CW\*(C`PAUSE::Permissions\*(C'\fR,
you can then call the \f(CW\*(C`module_permissions\*(C'\fR method
to get the permissions for a particular module.
The \s-1SYNOPSIS\s0 gives the basic usage.
.PP
\&\fBNote\fR: you should make sure you're using version 0.08 or later.
\&\s-1PAUSE\s0 now treats package names case insensitively with respect to
permissions, so this module does now as well.
.SS "Getting permissions for multiple modules"
.IX Subsection "Getting permissions for multiple modules"
Sometimes you might want to use the \f(CW\*(C`module_permissions()\*(C'\fR method
to get permissions for multiple modules, for example if you've built
up a list of modules from elsewhere. If you're doing this, then you
should set the \f(CW\*(C`preload\*(C'\fR attribute to a true value:
.PP
.Vb 1
\& use PAUSE::Permissions 0.12;
\&
\& my $pp = PAUSE::Permissions\->new(preload => 1);
\& foreach my $module_name (@long_list_of_modules) {
\&    my $mp = $pp\->module_permissions($module_name);
\&    # do something with $mp (instance of PAUSE::Permissions::Module)
\& }
.Ve
.PP
With the \f(CW\*(C`preload\*(C'\fR option enabled, the permissions data for \fIall\fR
modules will be pre-loaded into memory, making the above code much
quicker, trading that off against the memory used.
.PP
This attribute was introduced in version 0.12, so you should
specify the minimum version when \f(CW\*(C`use\*(C'\fR'ing \f(CW\*(C`PAUSE::Permission\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
There are only four methods you need to know:
the constructor (\f(CW\*(C`new\*(C'\fR),
getting an iterator over individual entries (\f(CW\*(C`entry_iterator\*(C'\fR),
getting an iterator over modules (\f(CW\*(C`module_iterator\*(C'\fR),
and \f(CW\*(C`module_permissions()\*(C'\fR.
.SS "new"
.IX Subsection "new"
The constructor takes a hash of options:
.IP "\(bu" 4
\&\fBcache_path\fR: the full path to the location where you'd like
\&\f(CW\*(C`PAUSE::Permissions\*(C'\fR to cache the transformed version of 06perms.txt.
.IP "\(bu" 4
\&\fBpath\fR: your own local copy of the file, to use instead of the
version in the \f(CW\*(C`cache_path\*(C'\fR.
Note that this must be in the post-processed format for the local cache,
and not the original raw format of \f(CW\*(C`06perms.txt\*(C'\fR.
.Sp
The constructor will \f(CW\*(C`die()\*(C'\fR if the file doesn't exist, or isn't readable.
.IP "\(bu" 4
\&\fBurl\fR: the \s-1URL\s0 for 06perms.txt;
defaults to <http://www.cpan.org/modules/06perms.txt>
.IP "\(bu" 4
\&\fBmax_age\fR: the expiration time for cached data, once \f(CW\*(C`06perms.txt\*(C'\fR has been grabbed.
The age can be specified using any format supported by Time::Duration::Parse,
such '1 day', '2 minutes and 30 seconds', or '02:30:00'.
.IP "\(bu" 4
\&\fBpreload\fR: load all module permissions data into memory,
to speed up repeated calls to \f(CW\*(C`module_permissions()\*(C'\fR.
This currently (0.12 onwards) doesn't currently affect any
other methods, though it might in a future release.
.PP
So you might use the following,
to get \f(CW\*(C`06perms.txt\*(C'\fR from your 'local' \s-1CPAN\s0 mirror and store it somewhere
of your choosing:
.PP
.Vb 4
\&  $pp = PAUSE::Permissions\->new(
\&                uri     => \*(Aqhttp://cpan.inode.at/modules/06perms.txt\*(Aq,
\&                cachdir => \*(Aq/tmp/pause\*(Aq,
\&            );
.Ve
.SS "module_iterator"
.IX Subsection "module_iterator"
This is a method that returns an instance of PAUSE::Permissions::ModuleIterator,
which provides a simple mechanism for iterating over the whole permissions file,
module by module:
.PP
.Vb 2
\&  $pp       = PAUSE::Permissions\->new();
\&  $iterator = $pp\->module_iterator();
\&  
\&  while (my $module = $iterator\->next_module) {
\&    print "module    = ", $module\->name,           "\en";
\&    print "owner     = ", $module\->owner,          "\en";
\&    print "co\-maints = ", $module\->co_maintainers, "\en";
\&  }
.Ve
.PP
The \f(CW\*(C`next_module()\*(C'\fR method returns either an instance of PAUSE::Permissions::Module,
or \f(CW\*(C`undef\*(C'\fR when the end of the file is reached.
.SS "entry_iterator"
.IX Subsection "entry_iterator"
This is a method that returns an instance of PAUSE::Permissions::EntryIterator,
which provides a simple mechanism for iterating over the whole permissions file,
line by line:
.PP
.Vb 7
\&  $pp       = PAUSE::Permissions\->new();
\&  $iterator = $pp\->entry_iterator();
\&  while (my $entry = $iterator\->next) {
\&    print "module = ", $entry\->module,     "\en";
\&    print "user   = ", $entry\->user,       "\en";
\&    print "perm   = ", $entry\->permission, "\en";
\&  }
.Ve
.PP
The \f(CW\*(C`module\*(C'\fR method returns a module name;
\&\f(CW\*(C`user\*(C'\fR returns the \s-1PAUSE\s0 id of a \s-1PAUSE\s0 user;
\&\f(CW\*(C`perm\*(C'\fR is one of the three permission identifiers ('m', 'f', or 'c').
.SS "module_permissions"
.IX Subsection "module_permissions"
The \f(CW\*(C`module_permissions\*(C'\fR method takes a single module name,
and returns an instance of PAUSE::Permissions::Module:
.PP
.Vb 1
\&  $mp = $pp\->module_permissions( $module_name );
.Ve
.PP
Refer to the documentation for PAUSE::Permissions::Module,
but the key methods are:
.IP "\(bu" 4
\&\f(CW\*(C`owner()\*(C'\fR
returns the \s-1PAUSE\s0 id of the owner (see \*(L"The 06perms.txt file\*(R" below),
or \f(CW\*(C`undef\*(C'\fR if there isn't a defined owner.
.IP "\(bu" 4
\&\f(CW\*(C`co_maintainers()\*(C'\fR
returns a list of \s-1PAUSE\s0 ids, or an empty list if the module has no co-maintainers.
.PP
\&\f(CW\*(C`module_permissions()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR
if the module wasn't found in the permissions list.
If you've only just registered your new module,
or only just uploaded the first release,
then it might not have made it into the file yet.
.SS "can_upload"
.IX Subsection "can_upload"
This method takes a \s-1PAUSE\s0 id and a module name, and returns true (specifically \f(CW1\fR)
if the specified user has permission to upload the specified module,
otherwise false (0).
.PP
.Vb 5
\& use PAUSE::Permissions 0.13;
\& my $pp = PAUSE::Permissions\->new(preload => 1);
\& if ($pp\->can_upload(\*(AqNEILB\*(Aq, \*(AqFoo::Bar\*(Aq)) {
\&     # User can upload package
\& }
.Ve
.PP
Having permission to upload a module means that either
(a) the module appears in 06perms.txt and the specified user is one of the entries, or
(b) the module doesn't appear, so we assume it's not on \s-1CPAN\s0.
.PP
There are some things you should be aware of, when interpreting this:
.IP "\(bu" 4
the username is handled case insensitively.
.IP "\(bu" 4
the module name is handled case-insensitively.
.IP "\(bu" 4
if the module is not in \f(CW\*(C`06perms.txt\*(C'\fR then this returns true,
but there is a delay between permissions being assigned by \s-1PAUSE\s0 and their
appearing in \f(CW\*(C`06perms.txt\*(C'\fR. Also, if you're running with a long \f(CW\*(C`max_age\*(C'\fR
parameter, it might be a while before you see the change anyway.
.IP "\(bu" 4
a user might theoretically have permission to upload a module,
but a specific upload might fail if the distribution doesn't have an
appropriately named \fImain module\fR. If you're not familiar with that restriction,
read this blog post <http://www.dagolden.com/index.php/2414/this-distribution-name-can-only-be-used-by-users-with-permission/>.
.PP
Note: this method was introduced in version 0.13, so you should specify
this as a minimum version number if you're using the method.
.SS "has_permission_for"
.IX Subsection "has_permission_for"
This method takes an author's \s-1PAUSE\s0 id and an optional string which specifies what type of permission
you're interested in. It will return an array ref with all package names for which the
author has the specified permission.
.PP
The following example takes a \s-1PAUSE\s0 id \f(CW\*(C`NEILB\*(C'\fR and determines all modules that \s-1NEILB\s0
can upload:
.PP
.Vb 7
\& use PAUSE::Permissions 0.14;
\& my $pp = PAUSE::Permissions\->new(preload => 1);
\& my $ref = $pp\->has_permission_for(\*(AqNEILB\*(Aq, \*(Aqupload\*(Aq);
\& print "NEILB has upload permission on:\en";
\& foreach my $module_name (@$ref) {
\&    print "  $module_name\en";
\& }
.Ve
.PP
There are three different permission types you can request:
.IP "\(bu" 4
\&'upload' \- ability to upload, which means co-maint or owner.
.IP "\(bu" 4
\&'owner' \- author is the owner of the package.
.IP "\(bu" 4
\&'comaint' \- author is comaint of the package but not owner.
.PP
The package names are returned in case-insensitive alphabetic order.
.PP
Note: this method was introduced in version 0.14, so you should specify
this as a minimum version number if you're using the method.
.SH "The 06perms.txt file"
.IX Header "The 06perms.txt file"
You can find the file on \s-1CPAN:\s0
.Sp
.RS 4
<http://www.cpan.org/modules/06perms.txt>
.RE
.PP
As of October 2012 this file is 8.4M in size.
.PP
The file starts with a header, followed by one blank line, then the body.
The body contains one line per module per user:
.PP
.Vb 3
\&  Config::Properties,CMANLEY,c
\&  Config::Properties,RANDY,f
\&  Config::Properties,SALVA,m
.Ve
.PP
Each line has three values, separated by commas:
.IP "\(bu" 4
The name of a module.
.IP "\(bu" 4
A \s-1PAUSE\s0 user id, which by convention is always given in upper case.
.IP "\(bu" 4
A single character that specifies what permissions the user has with
respect to the module. See below.
.PP
Note that this file lists \fImodules\fR, not distributions.
Every module in a \s-1CPAN\s0 distribution will be listed separately in this file.
Modules are listed in alphabetical order, and for a given module,
the \s-1PAUSE\s0 ids are listed in alphabetical order.
.PP
There are three characters that can appear in the permissions column:
.IP "\(bu" 4
\&\fB\f(CB\*(Aqm\*(Aq\fB\fR identifies the user as the registered \fImaintainer\fR of the module.
A module can only ever have zero or one user listed with the 'm' permission.
For more details on registering a module,
see 04pause.html <http://www.cpan.org/modules/04pause.html#namespace>.
.IP "\(bu" 4
\&\fB\f(CB\*(Aqf\*(Aq\fB\fR identifies the user as the \fIfirst\fR person to upload the module to \s-1CPAN\s0.
You don't have to register a module before uploading it, and ownership
in this case is first-come-first-served.
A module can only ever have zero or one user listed with the 'f' permission.
.IP "\(bu" 4
\&\fB\f(CB\*(Aqc\*(Aq\fB\fR identifies the user as a \fIco-maintainer\fR of the module.
A module can have any number of co-maintainers.
.PP
If you first upload a module, you'll get an 'f' against you in the file.
If you subsequently register the module, you'll get an 'm' against you.
Internally \s-1PAUSE\s0 will have you recorded with both an 'm' and an 'f',
but \f(CW\*(C`06perms.txt\*(C'\fR only lists the highest precedence permission for each user.
.SS "What do the permissions mean?"
.IX Subsection "What do the permissions mean?"
.IP "\(bu" 4
Various places refer to the 'owner' of the module.
This will be either the 'm' or 'f' permission, with 'm' taking precedence.
If a module has both an 'm' and an 'f' user listed, then the 'm' user
is considered the owner, and the 'f' user isn't.
If a module has a user with 'f' listed, but no 'm', then the 'f' user is
considered the owner.
.IP "\(bu" 4
If a module is listed in \f(CW\*(C`06perms.txt\*(C'\fR,
then only the people listed (m, f, or c)
are allowed to upload (new) versions of the module.
If anyone else uploads a version of the module,
then the offending \fIdistribution\fR will not be indexed:
it will appear in the uploader's directory on \s-1CPAN\s0,
but won't be indexed under the module.
.IP "\(bu" 4
Only the owner for a module can grant co-maintainer status for a module.
I.e. if you have the 'm' permission, you can always do it.
If you have the 'f' permission, you can only do it if no-one else has
the 'm' permission.
You can grant co-maintainer status using the \s-1PAUSE\s0 web interface.
.IP "\(bu" 4
Regardless of your permissions, you can only remove things from \s-1CPAN\s0 that
you uploaded. If you're the owner, you can't delete a version uploaded
by a co-maintainer. If you weren't happy with it, you could revoke their
co-maintainer status and then upload a superseding version. But we'd
recommend you talk to them (first).
.IP "\(bu" 4
If you upload a distribution containing a number of previously unseen modules,
and haven't pre-registered them,
then you'll get an 'f' permission for all of the modules.
Let's say you upload a second release of the distribution,
which doesn't include one of the modules,
and then delete the first release from \s-1CPAN\s0 (via the \s-1PAUSE\s0 web interface).
After some time the module will no longer be on \s-1CPAN\s0,
but you'll still have the 'f' permission in 06perms.txt.
You can free up the namespace using the \s-1PAUSE\s0 interface (\*(L"Change Permissions\*(R").
.IP "\(bu" 4
If your first upload of a module is a
Developer Release <http://www.cpan.org/modules/04pause.html#developerreleases>,
then you won't get permissions for the module.
You don't get permissions for a module until you've uploaded a non-developer
release containing the module,
that was accepted for indexing.
.IP "\(bu" 4
If you take over <http://www.cpan.org/modules/04pause.html#takeover> maintenance
of a module, then you'll generally be given the permissions of the previous maintainer.
So if the previous maintainer had 'm', then you'll get 'm', and (s)he will be
downgraded to 'c'.
If the previous maintainer had 'f', then you'll get 'f', and the previous owner
will be downgraded to 'c'.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
App::PAUSE::CheckPerms checks whether all modules in (your)
\&\s-1CPAN\s0 distributions have the same permissions.
.PP
\&\f(CW\*(C`tmpdir()\*(C'\fR in File::Spec::Functions is used to get a local directory for
caching 06perms.txt.
.PP
HTTP::Tiny is used to mirror 06perms.txt from \s-1CPAN\s0.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Request the file gzip'd, if we've got an appropriate module that can be used
to gunzip it.
.IP "\(bu" 4
At construct time we currently mirror the file;
should do this lazily, triggering it the first time you want a module's perms.
.IP "\(bu" 4
Every time you ask for a module, I scan the file from the start, then close it
once I've got the details for the requested module. Would be a lot more efficient
to keep the file open and start the search from there, as the file is sorted.
A binary chop on the file would be much more efficient as well.
.IP "\(bu" 4
A command-line script.
.SH "REPOSITORY"
.IX Header "REPOSITORY"
https://github.com/neilbowers/PAUSE\-Permissions <https://github.com/neilbowers/PAUSE-Permissions>
.SH "AUTHOR"
.IX Header "AUTHOR"
Neil Bowers <neilb@cpan.org>
.PP
Thanks to Andreas Ko\*:nig, for patiently answering many questions
on how this stuff all works.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012\-2013 by Neil Bowers <neilb@cpan.org>.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
