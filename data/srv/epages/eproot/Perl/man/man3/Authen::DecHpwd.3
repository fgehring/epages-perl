.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::DecHpwd 3"
.TH Authen::DecHpwd 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::DecHpwd \- DEC VMS password hashing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        use Authen::DecHpwd qw(
\&                UAI_C_AD_II UAI_C_PURDY UAI_C_PURDY_V UAI_C_PURDY_S
\&                lgi_hpwd
\&        );
\&
\&        $hash = lgi_hpwd("JRANDOM", "PASSWORD", UAI_C_PURDY_S, 1234);
\&
\&        use Authen::DecHpwd qw(vms_username vms_password);
\&
\&        $username = vms_username($username);
\&        $password = vms_password($password);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements the \f(CW\*(C`SYS$HASH_PASSWORD\*(C'\fR password hashing function
from \s-1VMS\s0 (also known as \f(CW\*(C`LGI$HPWD\*(C'\fR), and some associated \s-1VMS\s0 username
and password handling functions.
.PP
The password hashing function is implemented in \s-1XS\s0, with a hideously
slow pure Perl backup version for systems that can't handle \s-1XS\s0.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\s-1UAI_C_AD_II\s0" 4
.IX Item "UAI_C_AD_II"
.PD 0
.IP "\s-1UAI_C_PURDY\s0" 4
.IX Item "UAI_C_PURDY"
.IP "\s-1UAI_C_PURDY_V\s0" 4
.IX Item "UAI_C_PURDY_V"
.IP "\s-1UAI_C_PURDY_S\s0" 4
.IX Item "UAI_C_PURDY_S"
.PD
These constants are used to identify the four password hashing algorithms
used by \s-1VMS\s0.  They are the \f(CW\*(C`UAI$C_\*(C'\fR constants in \s-1VMS\s0.
.Sp
\&\f(CW\*(C`UAI_C_AD_II\*(C'\fR refers to a 32\-bit \s-1CRC\s0 algorithm.  The \s-1CRC\s0 polynomial used
is the \s-1IEEE\s0 \s-1CRC\-32\s0 polynomial, as used in Ethernet, and in this context
is known as \*(L"AUTODIN-II\*(R".  The hash is merely the \s-1CRC\s0 of the password.
.Sp
\&\f(CW\*(C`UAI_C_PURDY\*(C'\fR, \f(CW\*(C`UAI_C_PURDY_V\*(C'\fR, and \f(CW\*(C`UAI_C_PURDY_S\*(C'\fR refer to successive
refinements of an algorithm based on Purdy polynomials.  All of these
algorithms use the salt and username parameters as salt, use the whole
password, and return an eight-byte (64\-bit) hash.  The main part
of the algorithm, the Purdy polynomial, is identical in all three.
They differ in the pre-hashing, particularly in the treatment of the
username parameter.
.Sp
In \f(CW\*(C`UAI_C_PURDY\*(C'\fR the username is truncated or space-padded to 12 characters
before being hashed in.  \f(CW\*(C`UAI_C_PURDY_V\*(C'\fR accepts a variable-length username.
\&\f(CW\*(C`UAI_C_PURDY_S\*(C'\fR accepts a variable-length username and also includes the
password length in the hash.  \f(CW\*(C`UAI_C_PURDY_S\*(C'\fR also does some extra bit
rotations when hashing in the username and password strings, in order
to avoid aliasing.
.IP "lgi_hpwd(\s-1USERNAME\s0, \s-1PASSWORD\s0, \s-1ALGORITHM\s0, \s-1SALT\s0)" 4
.IX Item "lgi_hpwd(USERNAME, PASSWORD, ALGORITHM, SALT)"
This is the \f(CW\*(C`SYS$HASH_PASSWORD\*(C'\fR function from \s-1VMS\s0 (also known as
\&\f(CW\*(C`LGI$HPWD\*(C'\fR), but with the parameters in a different order.  It hashes
the \s-1PASSWORD\s0 string in a manner determined by the other parameters,
and returns the hash as a string of bytes.
.Sp
\&\s-1ALGORITHM\s0 determines which hashing algorithm will be used.  It must
be the value of one of the algorithm constants supplied by this module
(see above).
.Sp
\&\s-1SALT\s0 must be an integer in the range [0, 2^16).  It modifies the hashing
so that the same password does not always produce the same hash.
.Sp
\&\s-1USERNAME\s0 is a string that is used as more salt.  In \s-1VMS\s0 it is the username
of the account to which the password controls access.
.Sp
\&\s-1VMS\s0 usernames and passwords are constrained in character set and
length, and are case-insensitive.  This function does not enforce
these restrictions, nor perform canonicalisation.  If restrictions
and canonicalisation are desired then they must be applied separately.
The functions \f(CW\*(C`vms_username\*(C'\fR and \f(CW\*(C`vms_password\*(C'\fR described below may
be useful.
.IP "vms_username(\s-1USERNAME\s0)" 4
.IX Item "vms_username(USERNAME)"
Checks whether the \s-1USERNAME\s0 string matches \s-1VMS\s0 username syntax, and
canonicalises it.  \s-1VMS\s0 username syntax is 1 to 31 characters from
case-insensitive alphanumerics, "\fB_\fR\*(L", and \*(R"\fB$\fR".  If the string has
correct username syntax then the username is returned in canonical form
(uppercase).  If the string is not a username then \f(CW\*(C`undef\*(C'\fR is returned.
.IP "vms_password(\s-1PASSWORD\s0)" 4
.IX Item "vms_password(PASSWORD)"
Checks whether the \s-1PASSWORD\s0 string is an acceptable \s-1VMS\s0 password,
and canonicalises it.  \s-1VMS\s0 password syntax is 1 to 32 characters from
case-insensitive alphanumerics, "\fB_\fR\*(L", and \*(R"\fB$\fR".  If the string is
an acceptable password then the password is returned in canonical form
(uppercase).  If the string is not an acceptable password then \f(CW\*(C`undef\*(C'\fR
is returned.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
VMS::User
.SH "AUTHOR"
.IX Header "AUTHOR"
The original C implementation of \f(CW\*(C`LGI$HPWD\*(C'\fR was written by Shawn Clifford.
The code has since been developed by Davide Casale, Mario Ambrogetti,
Terence Lee, Jean-loup Gailly, Solar Designer, and Andrew Main (Zefram).
.PP
Mike McCauley <mikem@open.com.au> created the first version of
\&\f(CW\*(C`Authen::DecHpwd\*(C'\fR, establishing the Perl interface.  This was based on
Shawn Clifford's code without the later developments.
.PP
Andrew Main (Zefram) <zefram@fysh.org> created a new \f(CW\*(C`Authen::DecHpwd\*(C'\fR
based on the more developed C code presently used, and added ancillary
functions.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002 Jean-loup Gailly <http://gailly.net>
.PP
Based in part on code from John the Ripper, Copyright (C) 1996\-2002
Solar Designer
.PP
Copyright (C) 2006, 2007, 2009, 2010, 2011
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.
