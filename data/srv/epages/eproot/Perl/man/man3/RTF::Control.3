.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RTF::Control 3"
.TH RTF::Control 3 "2004-03-30" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RTF::Control \- Application of RTF::Parser for document conversion
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Application of RTF::Parser for document conversion
.SH "OVERVIEW"
.IX Header "OVERVIEW"
RTF::Control is a sublass of RTF::Parser. RTF::Control can be seen as
a helper module for people wanting to write their own document convertors \-
RTF::HTML::Convertor and RTF::TEXT::Convertor both subclass it.
.PP
I am the new maintainer of this module. My aim is to keep the interface
identical to the old interface while cleaning up, documenting, and testing
the internals. There are things in the interface I'm unhappy with, and things
I like \- however, I'm maintaining rather than developing the module, so, the
interface is mostly frozen.
.SH "HOW IT ALL WORKS"
.IX Header "HOW IT ALL WORKS"
For starters, go and look at the source of RTF::TEXT::Convertor
.PP
Except for \fBRTF::Parser subs\fR, the following is a list of variables
exported by RTF::Control that you're expected to tinker with in your
own subclass.
.SS "RTF::Parser subs"
.IX Subsection "RTF::Parser subs"
If you read the docs of RTF::Parser you'll see that you can redefine some
subs there \- RTF::Control has its own definitions for all of these, but you
might want to over-ride \f(CW\*(C`symbol()\*(C'\fR, \f(CW\*(C`text()\*(C'\fR, and \f(CW\*(C`char()\*(C'\fR. We'll look
at what the defaults of each of these do, and what you need to do if you
want to override any of them a little further down.
.ie n .SS "%symbol"
.el .SS "\f(CW%symbol\fP"
.IX Subsection "%symbol"
This hash is actually merged into \f(CW%do_on_control\fR, with the value wrapped in
a subroutine that effectively says \f(CW\*(C`print shift\*(C'\fR. You can put any control
words that should map directly to a certain output in here \- \f(CW\*(C`\etab\*(C'\fR, for
example could be \f(CW\*(C`$symbol{\*(Aqtab\*(Aq} = "\et"\*(C'\fR.
.ie n .SS "%info"
.el .SS "\f(CW%info\fP"
.IX Subsection "%info"
This hash gets filled with document meta-data, as per the \s-1RTF\s0 specification.
.ie n .SS "%par_props"
.el .SS "\f(CW%par_props\fP"
.IX Subsection "%par_props"
Not really sure, but paragraph properties
.ie n .SS "%do_on_event %do_on_control"
.el .SS "\f(CW%do_on_event\fP \f(CW%do_on_control\fP"
.IX Subsection "%do_on_event %do_on_control"
\&\f(CW%do_on_control\fR tells us what to do when we meet a specific control word.
The values are coderefs. \f(CW%do_on_event\fR also holds coderefs, but these are
more abstract things to do, say when the stylesheet changes. \f(CW%do_on_event\fR
thingies tend to be called by \f(CW%do_on_control\fR thingies, as far as I can tell.
.ie n .SS "$style $newstyle"
.el .SS "\f(CW$style\fP \f(CW$newstyle\fP"
.IX Subsection "$style $newstyle"
Style is the current style, \f(CW$newstyle\fR is the one we're about to
change to if we're about to change...
.ie n .SS "$event"
.el .SS "\f(CW$event\fP"
.IX Subsection "$event"
Current event
.ie n .SS "$text"
.el .SS "\f(CW$text\fP"
.IX Subsection "$text"
Pending text
.SS "new"
.IX Subsection "new"
Returns an RTF::Control object. RTF::Control is a subclass of RTF::Parser.
Internally, we call RTF::Parser's \fInew()\fR method, and then we call an internal
method called \fI_configure()\fR, which takes care of options we were passed.
.PP
\&\s-1ADD\s0 \s-1STUFF\s0 \s-1ON\s0 \-output \s-1AND\s0 \-confdir
.SS "application_dir"
.IX Subsection "application_dir"
I'm leaving this method in because removing it will cause a backward-compatability
nightmare. This method returns the ( wait for it ) path that the .pm file corresponding
to the class that the object is contained, without a trailing semi-colon. Obviously
this is nasty in several ways. If you've set \f(CW\*(C`\-confdir\*(C'\fR in \f(CW\*(C`new()\*(C'\fR that will be
returned instead. You should definitely take that route if you're on an \s-1OS\s0 on which 
Perl can't use / as a directory seperator.
.SS "charmap_reader"
.IX Subsection "charmap_reader"
This nicely abstracts away using application_dir and so on. It's a method
call. It'll take the name of the class, and an argument for the module/file
it's looking for. This is likely to be 'ansi' or 'charmap'. This argument,
for historical reasons (ho ho ho) will have any _'s removed in the check for
a module name ... \f(CW\*(C` $self\-\*(C'\fRcharmap_reader('char_map') > will thus look for, for
example, \f(CW\*(C` RTF::TEXT::charmap \*(C'\fR to load. It'll return the data in the file as
an array of lines. This description sucks.
.SH "Stack manipulation"
.IX Header "Stack manipulation"
.SS "dump_stack"
.IX Subsection "dump_stack"
Serializes and prints the stack to \s-1STDERR\s0
.SS "output"
.IX Subsection "output"
Holder routine for the current thing to do with output text we're given.
It starts off as the same as \f(CW$string_output_sub\fR, which adds the string
to the element at the \f(CW\*(C`TOP\*(C'\fR of the output stack. However, the idea, I 
believe, is to allow that to be changed at will, using \f(CW\*(C`push_output\*(C'\fR.
.SS "push_output"
.IX Subsection "push_output"
Adds a blank element to the end of the stack. It will change (or
maintain) the function of \f(CW\*(C`output\*(C'\fR to be \f(CW$string_output_sub\fR,
unless you pass it the argument \f(CW \*(Aqnul\*(Aq \fR, in which case it will
set \f(CW\*(C`output\*(C'\fR to be \f(CW$nul_output_sub\fR.
.SS "pop_output"
.IX Subsection "pop_output"
Removes and returns the last element of the ouput stack
.SS "set_top_output_to"
.IX Subsection "set_top_output_to"
Only called at init time, is a method call not a function.
Sets the action of \f(CW\*(C`flush_top_output\*(C'\fR, depending on whether
you pass it a filehandle or string reference.
.SS "flush_top_output"
.IX Subsection "flush_top_output"
Output the top element of the stack in the way specified by the call
to \f(CW\*(C`set_top_output_to\*(C'\fR
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 30:" 4
.IX Item "Around line 30:"
Deleting unknown formatting code M<>
