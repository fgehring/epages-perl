.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parallel::Iterator 3"
.TH Parallel::Iterator 3 "2017-06-14" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parallel::Iterator \- Simple parallel execution
.SH "VERSION"
.IX Header "VERSION"
This document describes Parallel::Iterator version 1.00
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Parallel::Iterator qw( iterate );
\&
\&    # A very expensive way to double 100 numbers...
\&    
\&    my @nums = ( 1 .. 100 );
\&    
\&    my $iter = iterate( sub {
\&        my ( $id, $job ) = @_;
\&        return $job * 2;
\&    }, \e@nums );
\&    
\&    my @out = ();
\&    while ( my ( $index, $value ) = $iter\->() ) {
\&        $out[$index] = $value;
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`map\*(C'\fR function applies a user supplied transformation function to
each element in a list, returning a new list containing the
transformed elements.
.PP
This module provides a 'parallel map'. Multiple worker processes are
forked so that many instances of the transformation function may be
executed simultaneously.
.PP
For time consuming operations, particularly operations that spend most
of their time waiting for I/O, this is a big performance win. It also
provides a simple idiom to make effective use of multi \s-1CPU\s0 systems.
.PP
There is, however, a considerable overhead associated with forking, so
the example in the synopsis (doubling a list of numbers) is \fInot\fR a
sensible use of this module.
.SS "Example"
.IX Subsection "Example"
Imagine you have an array of URLs to fetch:
.PP
.Vb 6
\&    my @urls = qw(
\&        http://google.com/
\&        http://hexten.net/
\&        http://search.cpan.org/
\&        ... and lots more ...
\&    );
.Ve
.PP
Write a function that retrieves a \s-1URL\s0 and returns its contents or undef
if it can't be fetched:
.PP
.Vb 6
\&    sub fetch {
\&        my $url = shift;
\&        my $resp = $ua\->get($url);
\&        return unless $resp\->is_success;
\&        return $resp\->content;
\&    };
.Ve
.PP
Now write a function to synthesize a special kind of iterator:
.PP
.Vb 10
\&    sub list_iter {
\&        my @ar = @_;
\&        my $pos = 0;
\&        return sub {
\&            return if $pos >= @ar;
\&            my @r = ( $pos, $ar[$pos] );  # Note: returns ( index, value )
\&            $pos++;
\&            return @r;
\&        };
\&    }
.Ve
.PP
The returned iterator will return each element of the array in turn and
then undef. Actually it returns both the index \fIand\fR the value of each
element in the array. Because multiple instances of the transformation
function execute in parallel the results won't necessarily come back in
order. The array index will later allow us to put completed items in the
correct place in an output array.
.PP
Get an iterator for the list of URLs:
.PP
.Vb 1
\&    my $url_iter = list_iter( @urls );
.Ve
.PP
Then wrap it in another iterator which will return the transformed results:
.PP
.Vb 1
\&    my $page_iter = iterate( \e&fetch, $url_iter );
.Ve
.PP
Finally loop over the returned iterator storing results:
.PP
.Vb 4
\&    my @out = ( );
\&    while ( my ( $index, $value ) = $page_iter\->() ) {
\&        $out[$index] = $value;
\&    }
.Ve
.PP
Behind the scenes your program forked into ten (by default) instances of
itself and executed the page requests in parallel.
.SS "Simpler interfaces"
.IX Subsection "Simpler interfaces"
Having to construct an iterator is a pain so \f(CW\*(C`iterate\*(C'\fR is smart enough
to do that for you. Instead of passing an iterator just pass a reference
to the array:
.PP
.Vb 1
\&    my $page_iter = iterate( \e&fetch, \e@urls );
.Ve
.PP
If you pass a hash reference the iterator you get back will return key,
value pairs:
.PP
.Vb 1
\&    my $some_iter = iterate( \e&fetch, \e%some_hash );
.Ve
.PP
If the returned iterator is inconvenient you can get back a hash or
array instead:
.PP
.Vb 1
\&    my @done = iterate_as_array( \e&fetch, @urls );
\&
\&    my %done = iterate_as_hash( \e&worker, %jobs );
.Ve
.SS "How It Works"
.IX Subsection "How It Works"
The current process is forked once for each worker. Each forked child is
connected to the parent by a pair of pipes. The child's \s-1STDIN\s0, \s-1STDOUT\s0
and \s-1STDERR\s0 are unaffected.
.PP
Input values are serialised (using Storable) and passed to the workers.
Completed work items are serialised and returned.
.SS "Caveats"
.IX Subsection "Caveats"
Parallel::Iterator is designed to be simple to use \- but the underlying
forking of the main process can cause mystifying problems unless you
have an understanding of what is going on behind the scenes.
.PP
\fIWorker execution enviroment\fR
.IX Subsection "Worker execution enviroment"
.PP
All code apart from the worker subroutine executes in the parent process
as normal. The worker executes in a forked instance of the parent
process. That means that things like this won't work as expected:
.PP
.Vb 6
\&    my %tally = ();
\&    my @r = iterate_as_array( sub {
\&        my ($id, $name) = @_;
\&        $tally{$name}++;       # might not do what you think it does
\&        return reverse $name;
\&    }, @names );
\&
\&    # Now print out the tally...
\&    while ( my ( $name, $count ) = each %tally ) {
\&        printf("%5d : %s\en", $count, $name);
\&    }
.Ve
.PP
Because the worker is a closure it can see the \f(CW%tally\fR hash from its
enclosing scope; but because it's running in a forked clone of the parent
process it modifies its own copy of \f(CW%tally\fR rather than the copy for
the parent process.
.PP
That means that after the job terminates the \f(CW%tally\fR in the parent
process will be empty.
.PP
In general you should avoid side effects in your worker subroutines.
.PP
\fISerialization\fR
.IX Subsection "Serialization"
.PP
Values are serialised using Storable to pass to the worker subroutine
and results from the worker are again serialised before being passed
back. Be careful what your values refer to: everything has to be
serialised. If there's an indirect way to reach a large object graph
Storable will find it and performance will suffer.
.PP
To find out how large your serialised values are serialise one of them
and check its size:
.PP
.Vb 3
\&    use Storable qw( freeze );
\&    my $serialized = freeze $some_obj;
\&    print length($serialized), " bytes\en";
.Ve
.PP
In your tests you may wish to guard against the possibility of a change
to the structure of your values resulting in a sudden increase in
serialized size:
.PP
.Vb 1
\&    ok length(freeze $some_obj) < 1000, "Object too bulky?";
.Ve
.PP
See the documetation for Storable for other caveats.
.PP
\fIPerformance\fR
.IX Subsection "Performance"
.PP
Process forking is expensive. Only use Parallel::Iterator in cases where:
.IP "the worker waits for I/O" 4
.IX Item "the worker waits for I/O"
The case of fetching web pages is a good example of this. Fetching a
page with LWP::UserAgent may take as long as a few seconds but probably
consumes only a few milliseconds of processor time. Running many
requests in parallel is a huge win \- but be kind to the server you're
talking to: don't launch a lot of parallel requests unless it's your
server or you know it can handle the load.
.IP "the worker is \s-1CPU\s0 intensive and you have multiple cores / CPUs" 4
.IX Item "the worker is CPU intensive and you have multiple cores / CPUs"
If the worker is doing an expensive calculation you can parallelise that
across multiple \s-1CPU\s0 cores. Benchmark first though. There's a
considerable overhead associated with Parallel::Iterator; unless your
calculations are time consuming that overhead will dwarf whatever time
they take.
.SH "INTERFACE"
.IX Header "INTERFACE"
.ie n .SS """iterate( [ $options ], $worker, $iterator )"""
.el .SS "\f(CWiterate( [ $options ], $worker, $iterator )\fP"
.IX Subsection "iterate( [ $options ], $worker, $iterator )"
Get an iterator that applies the supplied transformation function to
each value returned by the input iterator.
.PP
Instead of an iterator you may pass an array or hash reference and
\&\f(CW\*(C`iterate\*(C'\fR will convert it internally into a suitable iterator.
.PP
If you are doing this you may wish to investigate \f(CW\*(C`iterate_as_hash\*(C'\fR and
\&\f(CW\*(C`iterate_as_array\*(C'\fR.
.PP
\fIOptions\fR
.IX Subsection "Options"
.PP
A reference to a hash of options may be supplied as the first argument.
The following options are supported:
.ie n .IP """workers""" 4
.el .IP "\f(CWworkers\fR" 4
.IX Item "workers"
The number of concurrent processes to launch. Set this to 0 to disable
forking. Defaults to 10 on systems that support fork and 0 (disable
forking) on those that do not.
.ie n .IP """nowarn""" 4
.el .IP "\f(CWnowarn\fR" 4
.IX Item "nowarn"
Normally \f(CW\*(C`iterate\*(C'\fR will issue a warning and fall back to single process
mode on systems on which fork is not available. This option supresses
that warning.
.ie n .IP """batch""" 4
.el .IP "\f(CWbatch\fR" 4
.IX Item "batch"
Ordinarily items are passed to the worker one at a time. If you are
processing a large number of items it may be more efficient to process
them in batches. Specify the batch size using this option.
.Sp
Batching is transparent from the caller's perspective. Internally it
modifies the iterators and worker (by wrapping them in additional
closures) so that they pack, process and unpack chunks of work.
.ie n .IP """adaptive""" 4
.el .IP "\f(CWadaptive\fR" 4
.IX Item "adaptive"
Extending the idea of batching a number of work items to amortize the
overhead of passing work to and from parallel workers you may also ask
\&\f(CW\*(C`iterate\*(C'\fR to heuristically determine the batch size by setting the
\&\f(CW\*(C`adaptive\*(C'\fR option to a numeric value.
.Sp
The batch size will be computed as
.Sp
.Vb 1
\&    <number of items seen> / <number of workers> / <adaptive>
.Ve
.Sp
A larger value for \f(CW\*(C`adaptive\*(C'\fR will reduce the rate at which the batch
size increases. Good values tend to be in the range 1 to 2.
.Sp
You can also specify lower and, optionally, upper bounds on the batch
size by passing an reference to an array containing ( lower bound,
growth ratio, upper bound ). The upper bound may be omitted.
.Sp
.Vb 3
\&    my $iter = iterate(
\&        { adaptive => [ 5, 2, 100 ] },
\&        $worker, \e@stuff );
.Ve
.ie n .IP """onerror""" 4
.el .IP "\f(CWonerror\fR" 4
.IX Item "onerror"
The action to take when an error is thrown in the iterator. Possible
values are 'die', 'warn' or a reference to a subroutine that will be
called with the index of the job that threw the exception and the value
of \f(CW$@\fR thrown.
.Sp
.Vb 8
\&    iterate( {
\&        onerror => sub {
\&            my ($id, $err) = @_;
\&            $self\->log( "Error for index $id: $err" );
\&        },
\&        $worker,
\&        \e@jobs
\&    );
.Ve
.Sp
The default is 'die'.
.ie n .SS """iterate_as_array"""
.el .SS "\f(CWiterate_as_array\fP"
.IX Subsection "iterate_as_array"
As \f(CW\*(C`iterate\*(C'\fR but instead of returning an iterator returns an array
containing the collected output from the iterator. In a scalar context
returns a reference to the same array.
.PP
For this to work properly the input iterator must return (index, value)
pairs. This allows the results to be placed in the correct slots in the
output array. The simplest way to do this is to pass an array reference
as the input iterator:
.PP
.Vb 1
\&    my @output = iterate_as_array( \e&some_handler, \e@input );
.Ve
.ie n .SS """iterate_as_hash"""
.el .SS "\f(CWiterate_as_hash\fP"
.IX Subsection "iterate_as_hash"
As \f(CW\*(C`iterate\*(C'\fR but instead of returning an iterator returns a hash
containing the collected output from the iterator. In a scalar context
returns a reference to the same hash.
.PP
For this to work properly the input iterator must return (key, value)
pairs. This allows the results to be placed in the correct slots in the
output hash. The simplest way to do this is to pass a hash reference as
the input iterator:
.PP
.Vb 1
\&    my %output = iterate_as_hash( \e&some_handler, \e%input );
.Ve
.SH "CONFIGURATION AND ENVIRONMENT"
.IX Header "CONFIGURATION AND ENVIRONMENT"
Parallel::Iterator requires no configuration files or environment variables.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
None.
.SH "INCOMPATIBILITIES"
.IX Header "INCOMPATIBILITIES"
None reported.
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.PP
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-parallel\-iterator@rt.cpan.org\*(C'\fR, or through the web interface at
<http://rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Armstrong  \f(CW\*(C`<andy@hexten.net>\*(C'\fR
.SH "THANKS"
.IX Header "THANKS"
Aristotle Pagaltzis for the \s-1END\s0 handling suggestion and patch.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2007, Andy Armstrong \f(CW\*(C`<andy@hexten.net>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0
\&\s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0
\&\s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0
\&\s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0
\&\s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0
\&\s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0
\&\s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0
\&\s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.
.PP
\&\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0
\&\s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0
\&\s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0
\&\s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0,
\&\s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0
\&\s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0
\&\s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A
\&\s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0
\&\s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0
\&\s-1SUCH\s0 \s-1DAMAGES\s0.
