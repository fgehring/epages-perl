.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::Schema::BuiltInTypes 3"
.TH XML::Compile::Schema::BuiltInTypes 3 "2016-09-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::Schema::BuiltInTypes \- Define handling of built\-in data\-types
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& XML::Compile::Schema::BuiltInTypes
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # Not for end\-users
\& use XML::Compile::Schema::BuiltInTypes qw/%builtin_types/;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Different schema specifications specify different available types,
but there is a lot over overlap.  The XML::Compile::Schema::Specs
module defines the availability, but here the types are implemented.
.PP
This implementation certainly does not try to be minimal in size:
following the letter of the restriction rules and inheritance structure
defined by the W3C schema specification would be too slow.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "Real functions"
.IX Subsection "Real functions"
.IP "\fBbuiltin_type_info\fR($type)" 4
.IX Item "builtin_type_info($type)"
Returns the configuration for \f(CW$type\fR, which is a \s-1HASH\s0.  Be aware that
the information in this \s-1HASH\s0 will change over time without too much
notice.  Implement regression-tests in this if you use it!
.SS "The Types"
.IX Subsection "The Types"
The functions named in this section are all used at compile-time
by the translator.  At that moment, they will be placed in the
kind-of opcode tree which will process the data at run-time.
You \fBcannot call\fR these functions yourself.
.PP
XML::Compile will automatically format the value for you.  For instance,
a float supplied to a field defined as type Integer will be converted
to an integer. Data supplied to a field of type base64Binary will be
encoded as Base64 for you: you shouldn't do the conversion yourself,
you'll get double encoding!
.PP
\fIAny\fR
.IX Subsection "Any"
.IP "\fBanyAtomicType\fR()" 4
.IX Item "anyAtomicType()"
.PD 0
.IP "\fBanySimpleType\fR()" 4
.IX Item "anySimpleType()"
.IP "\fBanyType\fR()" 4
.IX Item "anyType()"
.PD
Both any*Type built-ins can contain any kind of data.  Perl decides how
to represent the passed values.
.IP "\fBerror\fR()" 4
.IX Item "error()"
.PP
\fIUngrouped types\fR
.IX Subsection "Ungrouped types"
.IP "\fBboolean\fR()" 4
.IX Item "boolean()"
Contains \f(CW\*(C`true\*(C'\fR, \f(CW\*(C`false\*(C'\fR, \f(CW1\fR (is true), or \f(CW0\fR (is false).
When the writer sees a value equal to 'true' or 'false', those are
used.  Otherwise, the trueth value is evaluated into '0' or '1'.
.Sp
The reader will return '0' (also when the \s-1XML\s0 contains the string
\&'false', to simplify the Perl code) or '1'.
.IP "\fBpattern\fR()" 4
.IX Item "pattern()"
.PP
\fIBig Integers\fR
.IX Subsection "Big Integers"
.PP
Schema's define integer types which are derived from the \f(CW\*(C`decimal\*(C'\fR
type.  These values can grow enormously large, and therefore can only be
handled correctly using Math::BigInt.  When the translator is
built with the \f(CW\*(C`sloppy_integers\*(C'\fR option, this will simplify (speed-up)
the produced code considerably: all integers then shall be between
\&\-2G and +2G.
.IP "\fBinteger\fR()" 4
.IX Item "integer()"
An integer with an undertermined (but possibly large) number of
digits.
.IP "\fBlong\fR()" 4
.IX Item "long()"
A little bit shorter than an integer, but still up-to 19 digits.
.IP "\fBnegativeInteger\fR()" 4
.IX Item "negativeInteger()"
.PD 0
.IP "\fBnonNegativeInteger\fR()" 4
.IX Item "nonNegativeInteger()"
.IP "\fBnonPositiveInteger\fR()" 4
.IX Item "nonPositiveInteger()"
.IP "\fBpositiveInteger\fR()" 4
.IX Item "positiveInteger()"
.IP "\fBunsignedInt\fR()" 4
.IX Item "unsignedInt()"
.PD
Just too long to fit in Perl's ints.
.IP "\fBunsignedLong\fR()" 4
.IX Item "unsignedLong()"
Value up-to 20 digits.
.PP
\fIIntegers\fR
.IX Subsection "Integers"
.IP "\fBbyte\fR()" 4
.IX Item "byte()"
Signed 8\-bits value.
.IP "\fBint\fR()" 4
.IX Item "int()"
.PD 0
.IP "\fBshort\fR()" 4
.IX Item "short()"
.PD
Signed 16\-bits value.
.IP "\fBunsignedByte\fR()" 4
.IX Item "unsignedByte()"
Unsigned 8\-bits value.
.IP "\fBunsignedShort\fR()" 4
.IX Item "unsignedShort()"
unsigned 16\-bits value.
.PP
\fIFloating-point\fR
.IX Subsection "Floating-point"
.IP "\fBdecimal\fR()" 4
.IX Item "decimal()"
Decimals are painful: they can be very large, much larger than Perl's
internal floats.  Therefore, we need to use Math::BigFloat which are
slow but nearly seamlessly invisible in the application.
.IP "\fBdouble\fR()" 4
.IX Item "double()"
A floating-point value \*(L"m x 2**e\*(R", where m is an integer whose absolute
value is less than 253, and e is an integer between X1074 and 971, inclusive.
.Sp
The implementation does not limited the double in size, but maps it onto an
precisionDecimal (Math::BigFloat) unless \f(CW\*(C`sloppy_float\*(C'\fR is set.
.IP "\fBfloat\fR()" 4
.IX Item "float()"
A small floating-point value \*(L"m x 2**e\*(R" where m is an integer whose absolute
value is less than 224, and e is an integer between X149 and 104, inclusive.
.Sp
The implementation does not limited the float in size, but maps it onto an
precisionDecimal (Math::BigFloat) unless \f(CW\*(C`sloppy_float\*(C'\fR is set.
.IP "\fBprecisionDecimal\fR()" 4
.IX Item "precisionDecimal()"
Floating point value that closely corresponds to the floating-point
decimal datatypes described by \s-1IEEE/ANSI\-754\s0.
.PP
\fIEncoding\fR
.IX Subsection "Encoding"
.IP "\fBbase64Binary\fR()" 4
.IX Item "base64Binary()"
In the hash, it will be kept as binary data.  In \s-1XML\s0, it will be
base64 encoded.
.IP "\fBhexBinary\fR()" 4
.IX Item "hexBinary()"
In the hash, it will be kept as binary data.  In \s-1XML\s0, it will be
hex encoded, two hex digits per byte.
.PP
\fIDates\fR
.IX Subsection "Dates"
.IP "\fBdate\fR()" 4
.IX Item "date()"
A day, represented in localtime as \f(CW\*(C`YYYY\-MM\-DD\*(C'\fR or \f(CW\*(C`YYYY\-MM\-DD[\-+]HH:mm\*(C'\fR.
When a decimal value is passed, it is interpreted as \f(CW\*(C`time\*(C'\fR value in \s-1UTC\s0,
and will be formatted as required.  When reading, the date string will
not be parsed.
.IP "\fBdateTime\fR()" 4
.IX Item "dateTime()"
A moment, represented as \*(L"date T time tz?\*(R", where date is \f(CW\*(C`YYYY\-MM\-DD\*(C'\fR,
time is \f(CW\*(C`HH:MM:SS\*(C'\fR, and the time-zone tz is either \f(CW\*(C`\-HH:mm\*(C'\fR, \f(CW\*(C`+HH:mm\*(C'\fR,
or \f(CW\*(C`Z\*(C'\fR for \s-1UTC\s0.  The time-zone is optional, but can better be used
because the default is not defined in the standard. For that reason,
the \f(CW\*(C`dateTimeStamp\*(C'\fR got introduced, which requires the timezone.
.Sp
When a decimal value is passed, it is interpreted as \f(CW\*(C`time\*(C'\fR value in \s-1UTC\s0,
and will be formatted as required.  This will not work when the dateTime
extended type has facet \f(CW\*(C`explicitTimeZome="prohibited"\*(C'\fR.
.Sp
When reading, the date string will not be parsed.  Parsing timestamps
is quite expensive, therefore not preformed automatically.   You may try
Time::Local in combination with Date::Parse, or Time::Piece::ISO.
Be very careful with the timezone settings in your program, which effects
\&\f(CW\*(C`mktime\*(C'\fR which is used by these implementations.  Best to run your
application in \s-1GMT/UTC/UCT/Z\s0.
.IP "\fBdateTimeStamp\fR()" 4
.IX Item "dateTimeStamp()"
Like \f(CW\*(C`dateTime\*(C'\fR, but with required timezone which means that it is
better defined. All other handling is the same.
.IP "\fBgDay\fR()" 4
.IX Item "gDay()"
Format \f(CW\*(C`\-\-\-12\*(C'\fR or \f(CW\*(C`\-\-\-12+09:00\*(C'\fR (12 days, optional time-zone)
.IP "\fBgMonth\fR()" 4
.IX Item "gMonth()"
Format \f(CW\*(C`\-\-09\*(C'\fR or \f(CW\*(C`\-\-09+07:00\*(C'\fR (9 months, optional time-zone)
.IP "\fBgMonthDay\fR()" 4
.IX Item "gMonthDay()"
Format \f(CW\*(C`\-\-09\-12\*(C'\fR or \f(CW\*(C`\-\-09\-12+07:00\*(C'\fR (9 months 12 days, optional time-zone)
.IP "\fBgYear\fR()" 4
.IX Item "gYear()"
Format \f(CW2006\fR or \f(CW\*(C`2006+07:00\*(C'\fR (year 2006, optional time-zone)
.IP "\fBgYearMonth\fR()" 4
.IX Item "gYearMonth()"
Format \f(CW\*(C`2006\-11\*(C'\fR or \f(CW\*(C`2006\-11+07:00\*(C'\fR (november 2006, optional time-zone)
.IP "\fBtime\fR()" 4
.IX Item "time()"
An moment in time, as can happen every day.
.PP
\fIDuration\fR
.IX Subsection "Duration"
.PP
See \fIXML::Compile::Util::duration2secs()\fR to convert duration stamps
into seconds.
.IP "\fBdayTimeDuration\fR()" 4
.IX Item "dayTimeDuration()"
Format \f(CW\*(C`\-PnDTnHnMnS\*(C'\fR, where optional starting \f(CW\*(C`\-\*(C'\fR means negative.
The \f(CW\*(C`P\*(C'\fR is obligatory, and the \f(CW\*(C`T\*(C'\fR indicates start of a time part.
All other \f(CW\*(C`n[DHMS]\*(C'\fR are optional.
.IP "\fBduration\fR()" 4
.IX Item "duration()"
Format \f(CW\*(C`\-PnYnMnDTnHnMnS\*(C'\fR, where optional starting \f(CW\*(C`\-\*(C'\fR means negative.
The \f(CW\*(C`P\*(C'\fR is obligatory, and the \f(CW\*(C`T\*(C'\fR indicates start of a time part.
All other \f(CW\*(C`n[YMDHMS]\*(C'\fR are optional.
.IP "\fByearMonthDuration\fR()" 4
.IX Item "yearMonthDuration()"
Format \f(CW\*(C`\-PnYnMn\*(C'\fR, where optional starting \f(CW\*(C`\-\*(C'\fR means negative.
The \f(CW\*(C`P\*(C'\fR is obligatory, the \f(CW\*(C`n[YM]\*(C'\fR are optional.
.PP
\fIStrings\fR
.IX Subsection "Strings"
.IP "\fB\s-1ID\s0\fR(, \s-1IDREF\s0, \s-1IDREFS\s0)" 4
.IX Item "ID(, IDREF, IDREFS)"
A label, reference to a label, or set of references.
.Sp
\&\s-1PARTIAL\s0 \s-1IMPLEMENTATION:\s0 the validity of used characters is not checked.
.IP "\fBNCName\fR(, \s-1ENTITY\s0, \s-1ENTITIES\s0)" 4
.IX Item "NCName(, ENTITY, ENTITIES)"
A name which contains no colons (a non-colonized name).
.IP "\fBName\fR()" 4
.IX Item "Name()"
.PD 0
.IP "\fBlanguage\fR()" 4
.IX Item "language()"
.PD
An \s-1RFC3066\s0 language indicator.
.IP "\fBnormalizedString\fR()" 4
.IX Item "normalizedString()"
String where all sequence of white-spaces (including new-lines) are
interpreted as one blank.  Blanks at beginning and the end of the
string are ignored.
.IP "\fBstring\fR()" 4
.IX Item "string()"
(Usually utf8) string.
.IP "\fBtoken\fR(, \s-1NMTOKEN\s0, \s-1NMTOKENS\s0)" 4
.IX Item "token(, NMTOKEN, NMTOKENS)"
.PP
\fI\s-1URI\s0\fR
.IX Subsection "URI"
.IP "\fB\s-1NOTATION\s0\fR()" 4
.IX Item "NOTATION()"
\&\s-1NOT\s0 \s-1IMPLEMENTED\s0, so treated as string.
.IP "\fBQName\fR()" 4
.IX Item "QName()"
A qualified type name: a type name with optional prefix.  The prefix notation
\&\f(CW\*(C`prefix:type\*(C'\fR will be translated into the \f(CW\*(C`{$ns}type\*(C'\fR notation.
.Sp
For writers, this translation can only happen when the \f(CW$ns\fR is also
in use on some other place in the message: the name-space declaration
can not be added at run-time.  In other cases, you will get a run-time
error.  Play with XML::Compile::Schema::compile(prefixes),
predefining evenything what may be used, setting the \f(CW\*(C`used\*(C'\fR count to \f(CW1\fR.
.IP "\fBanyURI\fR()" 4
.IX Item "anyURI()"
You may pass a string or, for instance, an \s-1URI\s0 object which will be
stringified into an \s-1URI\s0.  When read, the data will not automatically
be translated into an \s-1URI\s0 object: it may not be used that way.
.PP
\fIonly in 1999 and 2000/10 schemas\fR
.IX Subsection "only in 1999 and 2000/10 schemas"
.IP "\fBbinary\fR()" 4
.IX Item "binary()"
Perl strings can contain any byte, also nul-strings, so can
contain any sequence of bits.  Limited to byte length.
.IP "\fBtimeDuration\fR()" 4
.IX Item "timeDuration()"
\&'Old' name for \fIduration()\fR.
.IP "\fBuriReference\fR()" 4
.IX Item "uriReference()"
Probably the same rules as \fIanyURI()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile distribution version 1.54,
built on September 19, 2016. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2006\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
