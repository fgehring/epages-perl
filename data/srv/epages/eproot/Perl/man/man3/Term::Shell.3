.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Term::Shell 3"
.TH Term::Shell 3 "2007-02-23" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Term::Shell \- A simple command\-line shell framework.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package MyShell;
\&    use base qw(Term::Shell);
\&
\&    sub run_command1  { print "command 1!\en"; }
\&    sub smry_command1 { "what does command1 do?" }
\&    sub help_command1 {
\&        <<\*(AqEND\*(Aq;
\&    Help on \*(Aqcommand1\*(Aq, whatever that may be...
\&    END
\&    }
\&
\&    sub run_command2 { print "command 2!\en"; }
\&
\&    package main;
\&    my $shell = MyShell\->new;
\&    $shell\->cmdloop;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::Shell lets you write simple command-line shells. All the boring details
like command-line parsing, terminal handling, and tab completion are handled
for you.
.PP
The base class comes with two commands pre-defined: exit and help.
.PP
To write a shell with an \f(CW\*(C`exec\*(C'\fR command, do something like this:
.PP
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell); # or manually edit @MyShell::ISA.
\&
\&   sub run_exec {
\&       my ($o, $cmd, @args) = @_;
\&       if ($cmd ne $0) {
\&           print "I\*(Aqm sorry you\*(Aqre leaving us...\en";
\&       }
\&       exec $cmd, @args;
\&       exit 1;
\&   }
.Ve
.PP
When Term::Shell needs to handle the \f(CW\*(C`exec\*(C'\fR command, it will invoke this
method. That's all there is to it! You write handlers, and Term::Shell handles
the gory details.
.SH "Using Term::Shell Shells"
.IX Header "Using Term::Shell Shells"
How do you bring your shell to life? Assuming the package \f(CW\*(C`MyShell\*(C'\fR contains
your actions, just do this:
.PP
.Vb 2
\&   use MyShell;
\&   my $shell = MyShell\->new;
\&
\&   # Setup code here (if you wish)
\&
\&   # Invoke the shell
\&   $shell\->cmdloop;
\&
\&   # Cleanup code here (if you wish)
.Ve
.PP
Most people put the setup code in the shell itself, so you can usually get
away with this:
.PP
.Vb 2
\&   use MyShell;
\&   MyShell\->new\->cmdloop;
.Ve
.PP
It's that simple! All the actions and command handlers go in \f(CW\*(C`MyShell.pm\*(C'\fR,
and your main program is simple. In fact, it's so simple that some people like
to write both the actions and the invocation in the same file:
.PP
.Vb 2
\&   package main;
\&   MyShell\->new\->cmdloop;
\&
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   # Actions here
.Ve
.PP
Adding commands to your shell is just as easy, if not easier.
.SH "Adding Commands to Your Shell"
.IX Header "Adding Commands to Your Shell"
For every command \f(CW\*(C`foo\*(C'\fR, Term::Shell needs a method called \f(CW\*(C`run_foo()\*(C'\fR,
where 'foo' is what the user will type in. The method will be called with the
Term::Shell object as the first parameter, followed by any arguments the user
typed after the command.
.PP
Several prefixes other than \f(CW\*(C`run_\*(C'\fR are supported; each prefix tells
Term::Shell to call that handler under different circumstances. The following
list enumerates all the \*(L"special\*(R" prefixes. Term::Shell will ignore any method
that doesn't start with a prefix listed here.
.IP "1." 4
\&\fIrun_foo()\fR
.Sp
Adds the command \f(CW\*(C`foo\*(C'\fR to the list of supported commands. The method's return
value is saved by Term::Shell, but is not used.
.Sp
The method is called with the Term::Shell object as its first argument,
followed by any arguments the user typed in.
.Sp
Special case: if you provide a method \f(CW\*(C`run_()\*(C'\fR, Term::Shell will call it
whenever the user enters a blank line. A blank line is anything which matches
the regular expression \f(CW\*(C`/^\es*$/\*(C'\fR.
.IP "2." 4
\&\fIhelp_foo()\fR
.Sp
Adds the command \f(CW\*(C`foo\*(C'\fR to the list of help topics. This means the user may
enter 'help foo' and get a help screen. It should return a single string to be
displayed to the user.
.Sp
The method is called with the Term::Shell object as its first argument,
followed by any arguments the user typed in after 'help foo'. You can
implement hierarchical help documents by using the arguments.
.Sp
If you do not provide a \f(CW\*(C`help_foo()\*(C'\fR method, typing 'help foo' produces an
error message.
.IP "3." 4
\&\fIsmry_foo()\fR
.Sp
Should return a one-line summary of \f(CW\*(C`foo\*(C'\fR, to be displayed in the help screen.
.Sp
This method is called with the Term::Shell object as its first argument, and
no other arguments.
.Sp
If you do not provide a \f(CW\*(C`smry_foo()\*(C'\fR method, then the string 'undocumented'
is used instead.
.IP "4." 4
\&\fIcomp_foo()\fR
.Sp
Provides custom tab-completion for \f(CW\*(C`foo\*(C'\fR. That means if the user types 'foo '
and then hits <\s-1TAB\s0>, this method will be called. It should return an array
reference containing a list of possible completions.
.Sp
This method is called with the Term::Shell object as its first argument,
followed by the three arguments:
.RS 4
.IP "1." 4
\&\f(CW$word\fR
.Sp
The word the user is trying to complete.
.IP "2." 4
\&\f(CW$line\fR
.Sp
The line as typed by the user so far.
.IP "3." 4
\&\f(CW$start\fR
.Sp
The offset into \f(CW$line\fR where \f(CW$word\fR starts.
.RE
.RS 4
.Sp
If you do not provide \f(CW\*(C`comp_foo()\*(C'\fR, Term::Shell will always return no
completions for \f(CW\*(C`foo\*(C'\fR.
.Sp
Special case: if you provide \f(CW\*(C`comp_()\*(C'\fR, Term::Shell will call it when the
user is trying to complete the name of a command. Term::Shell provides a
default \f(CW\*(C`comp_()\*(C'\fR method, which completes the actions that you have written
handlers for. If you want to provide tab-completion for commands that do not
have handlers, override \f(CW\*(C`comp_()\*(C'\fR.
.RE
.IP "5." 4
\&\fIalias_foo()\fR
.Sp
Returns a list of aliases for \f(CW\*(C`foo\*(C'\fR. When one of the aliases is used instead
of \f(CW\*(C`foo\*(C'\fR, the corresponding handler for \f(CW\*(C`foo\*(C'\fR is called.
.IP "6." 4
\&\fIcatch_run()\fR
.Sp
\&\fIcatch_help()\fR
.Sp
\&\fIcatch_comp()\fR
.Sp
\&\fIcatch_smry()\fR
.Sp
Called when an undefined action is entered by the user. Normally when the
user enters an unrecognized command, Term::Shell will print an error message
and continue.
.Sp
This method is called with the Term::Shell object, the command typed by the
user, and then the arguments which would normally be passed to the real
handler.
.Sp
The \f(CW\*(C`catch_\*(C'\fR methods may do anything the original function would have done.
If you want, you can implement all the commands in it, but that means you're
doing more work than you have to. Be lazy.
.SS "When you want something done right..."
.IX Subsection "When you want something done right..."
You sometimes have to do it yourself. Introducing \fIadd_handlers()\fR. Naturally,
it adds a handler to the list of defined handlers in the shell.
.PP
Term::Shell can't always find the commands you want to implement by searching
the inheritance tree. Having an \s-1\fIAUTOLOAD\s0()\fR method, for instance, will break
this system. In that situation, you may wish to tell Term::Shell about the
extra commands available using \fIadd_handlers()\fR:
.PP
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   sub AUTOLOAD {
\&       if ($AUTOLOAD =~ /::run_fuzz$/) {
\&           # code for \*(Aqfuzz\*(Aq command
\&       }
\&       elsif ($AUTOLOAD =~ /::run_foozle$/) {
\&           # code for \*(Aqfoozle\*(Aq command
\&       }
\&   }
\&
\&   sub init {
\&       my $o = shift;
\&       $o\->add_handlers("run_fuzz", "run_foozle");
\&   }
.Ve
.PP
There are other ways to do this. You could write a \f(CW\*(C`catch_run\*(C'\fR routine and do
the same thing from there. You'd have to override \f(CW\*(C`comp_\*(C'\fR so that it would
complete on \*(L"foozle\*(R" and \*(L"fuzz\*(R". The advantage to this method is that it adds
the methods to the list of commands, so they show up in the help menu \fIand\fR
you get completion for free.
.SH "Removing Commands from Your Shell"
.IX Header "Removing Commands from Your Shell"
You're probably thinking \*(L"just don't write them\*(R". But remember, you can
inherit from another shell class, and that parent may define commands you want
to disable. Term::Shell provides a simple method to make itself forget about
commands it already knows about:
.IP "1." 4
\&\fIremove_commands()\fR
.Sp
Removes all handlers associated with the given command (or list of commands).
.Sp
For example, Term::Shell comes with two commands (\f(CW\*(C`exit\*(C'\fR and \f(CW\*(C`help\*(C'\fR)
implemented with seven handlers:
.RS 4
.IP "1." 4
\&\fIsmry_exit()\fR
.IP "2." 4
\&\fIhelp_exit()\fR
.IP "3." 4
\&\fIrun_exit()\fR
.IP "4." 4
\&\fIsmry_help()\fR
.IP "5." 4
\&\fIhelp_help()\fR
.IP "6." 4
\&\fIcomp_help()\fR
.IP "7." 4
\&\fIrun_help()\fR
.RE
.RS 4
.Sp
If you want to create a shell that doesn't implement the \f(CW\*(C`help\*(C'\fR command,
your code might look something like this example:
.Sp
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   sub init {
\&       my $o = shift;
\&       $o\->remove_commands("help");
\&   }
\&
\&   # ... define more handlers here ...
.Ve
.RE
.IP "2." 4
\&\fIremove_handlers()\fR
.Sp
Removes the given handler (or handlers) from the list of defined commands. You
have to specify a full handler name, including the 'run_' prefix. You can
obviously specify any of the other prefixes too.
.Sp
If you wanted to remove the help for the \f(CW\*(C`exit\*(C'\fR command, but preserve the
command itself, your code might look something like this:
.Sp
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   sub init {
\&       my $o = shift;
\&       $o\->remove_handlers("help_exit");
\&   }
\&
\&   # ... define more handlers here ...
.Ve
.SS "Cover Your Tracks"
.IX Subsection "Cover Your Tracks"
If you do remove built in commands, you should be careful not to let
Term::Shell print references to them. Messages like this are guaranteed to
confuse people who use your shell:
.PP
.Vb 2
\&   shell> help
\&   Unknown command \*(Aqhelp\*(Aq; type \*(Aqhelp\*(Aq for a list of commands.
.Ve
.PP
Here's the innocuous looking code:
.PP
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   sub init {
\&       my $o = shift;
\&       $o\->remove_commands("help");
\&   }
\&
\&   MyShell\->new\->cmdloop;
.Ve
.PP
The problem is that Term::Shell has to print an error message, and by default
it tells the user to use the \f(CW\*(C`help\*(C'\fR command to see what's available. If you
remove the \f(CW\*(C`help\*(C'\fR command, you still have to clean up after yourself and tell
Term::Shell to change its error messages:
.IP "1." 4
\&\fImsg_unknown_cmd()\fR
.Sp
Called when the user has entered an unrecognized command, and no action was
available to satisfy it. It receives the object and the command typed by the
user as its arguments. It should return an error message; by default, it is
defined thusly:
.Sp
.Vb 6
\&   sub msg_unknown_cmd {
\&       my ($o, $cmd) = @_;
\&       <<END;
\&   Unknown command \*(Aq$cmd\*(Aq; type \*(Aqhelp\*(Aq for a list of commands.
\&   END
\&   }
.Ve
.IP "2." 4
\&\fImsg_ambiguous_cmd()\fR
.Sp
Called when the user has entered a command for which more than handler exists.
(For example, if both \*(L"quit\*(R" and \*(L"query\*(R" are commands, then \*(L"qu\*(R" is an
ambiguous command, because it could be either.) It receives the object, the
command, and the possible commands which could complete it. It should return
an error message; by default it is defined thusly:
.Sp
.Vb 8
\&   sub msg_ambiguous_cmd {
\&       my ($o, $cmd, @c) = @_;
\&       local $" = "\en\et";
\&       <<END;
\&   Ambiguous command \*(Aq$cmd\*(Aq: possible commands:
\&           @c
\&   END
\&   }
.Ve
.SH "The Term::Shell API"
.IX Header "The Term::Shell API"
Shell classes can use any of the methods in this list. Any other methods in
Term::Shell may change.
.IP "1." 4
\&\fInew()\fR
.Sp
Creates a new Term::Shell object. It currently does not use its arguments. The
arguments are saved in '$o\->{\s-1API\s0}{args}', in case you want to use them later.
.Sp
.Vb 1
\&   my $sh = Term::Shell\->new(@arbitrary_args);
.Ve
.IP "2." 4
\&\fIcmd()\fR
.Sp
.Vb 1
\&   cmd($txt);
.Ve
.Sp
Invokes \f(CW$txt\fR as if it had been typed in at the prompt.
.Sp
.Vb 1
\&   $sh\->cmd("echo 1 2 3");
.Ve
.IP "3." 4
\&\fIcmdloop()\fR
.Sp
\&\fImainloop()\fR
.Sp
Repeatedly prompts the user, reads a line, parses it, and invokes a handler.
Uses \f(CW\*(C`cmd()\*(C'\fR internally.
.Sp
.Vb 1
\&   MyShell\->new\->cmdloop;
.Ve
.Sp
\&\fImainloop()\fR is a synonym for \fIcmdloop()\fR, provided for backwards compatibility.
Earlier (unreleased) versions of Term::Shell have only provided \fImainloop()\fR.
All documentation and examples use \fIcmdloop()\fR instead.
.IP "4." 4
\&\fIinit()\fR
.Sp
\&\fIfini()\fR
.Sp
Do any initialization or cleanup you need at shell creation (\fIinit()\fR) and
destruction (\fIfini()\fR) by defining these methods.
.Sp
No parameters are passed.
.IP "5." 4
\&\fIpreloop()\fR
.Sp
\&\fIpostloop()\fR
.Sp
Do any initialization or cleanup you need at shell startup (\fIpreloop()\fR) and
shutdown (\fIpostloop()\fR) by defining these methods.
.Sp
No parameters are passed.
.IP "6." 4
\&\fIprecmd()\fR
.Sp
\&\fIpostcmd()\fR
.Sp
Do any initialization or cleanup before and after calling each handler.
.Sp
The parameters are:
.RS 4
.IP "1." 4
\&\f(CW$handler\fR
.Sp
A reference to the name of the handler that is about to be executed.
.Sp
Passed by reference so you can control which handler will be called.
.IP "2." 4
\&\f(CW$cmd\fR
.Sp
A reference to the command as the user typed it.
.Sp
Passed by reference so you can set the command. (If the handler is a \*(L"catch_\*(R"
command, it can be fooled into thinking the user typed some other command, for
example.)
.IP "3." 4
\&\f(CW$args\fR
.Sp
The arguments as typed by the user. This is passed as an array reference so
that you can manipulate the arguments received by the handler.
.RE
.RS 4
.Sp
.Vb 5
\&   sub precmd {
\&       my $o = shift;
\&       my ($handler, $cmd, @args) = @_;
\&       # ...
\&   }
.Ve
.RE
.IP "7." 4
\&\fIstoploop()\fR
.Sp
Sets a flag in the Term::Shell object that breaks out of \fIcmdloop()\fR. Note that
\&\fIcmdloop()\fR resets this flag each time you call it, so code like this will work:
.Sp
.Vb 3
\&   my $sh = MyShell\->new;
\&   $sh\->cmdloop;        # an interactive session
\&   $sh\->cmdloop;        # prompts the user again
.Ve
.Sp
Term::Shell's built-in \fIrun_exit()\fR command just calls \fIstoploop()\fR.
.IP "8." 4
\&\fIidle()\fR
.Sp
If you set \f(CW\*(C`check_idle\*(C'\fR to a non-zero number (see \*(L"The Term::Shell Object\*(R")
then this method is called every \f(CW\*(C`check_idle\*(C'\fR seconds. The \fIidle()\fR method
defined in Term::Shell does nothing \*(-- it exists only to be redefined in
subclasses.
.Sp
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   sub init {
\&       my $o = shift;
\&       $o\->{API}{check_idle} = 0.1;     # 10/s
\&   }
\&
\&   sub idle {
\&       print "Idle!\en";
\&   }
.Ve
.IP "9." 4
\&\fIprompt_str()\fR
.Sp
Returns a string to be used as the prompt. \fIprompt_str()\fR is called just before
calling the \fIreadline()\fR method of Term::ReadLine. If you do not override this
method, the string `shell> ' is used.
.Sp
.Vb 2
\&   package MyShell;
\&   use base qw(Term::Shell);
\&
\&   sub prompt_str { "search> " }
.Ve
.IP "10." 4
\&\fIprompt()\fR
.Sp
Term::Shell provides this method for convenience. It's common for a handler to
ask the user for more information. This method makes it easy to provide the
user with a different prompt and custom completions provided by you.
.Sp
The \fIprompt()\fR method takes the following parameters:
.RS 4
.IP "1." 4
\&\f(CW$prompt\fR
.Sp
The prompt to display to the user. This can be any string you want.
.IP "2." 4
\&\f(CW$default\fR
.Sp
The default value to provide. If the user enters a blank line (all whitespace
characters) then the this value will be returned.
.Sp
Note: unlike ExtUtils::MakeMaker's \fIprompt()\fR, Term::Shell's \fIprompt()\fR does not
modify \f(CW$prompt\fR to indicate the \f(CW$default\fR response. You have to do that
yourself.
.IP "3." 4
\&\f(CW$completions\fR
.Sp
An optional list of completion values. When the user hits <\s-1TAB\s0>, Term::Shell
prints the completions which match what they've typed so far. Term::Shell does
not enforce that the user's response is one of these values.
.IP "4." 4
\&\f(CW$casei\fR
.Sp
An optional boolean value which indicates whether the completions should be
matched case-insensitively or not. A true value indicates that \f(CW\*(C`FoO\*(C'\fR and
\&\f(CW\*(C`foo\*(C'\fR should be considered the same.
.RE
.RS 4
.Sp
\&\fIprompt()\fR returns the unparsed line to give you maximum flexibility. If you
need the line parsed, use the \fIline_parsed()\fR method on the return value.
.RE
.IP "11." 4
\&\fIcmd_prefix()\fR
.Sp
\&\fIcmd_suffix()\fR
.Sp
These methods should return a prefix and suffix for commands, respectively.
For instance, an \s-1IRC\s0 client will have a prefix of \f(CW\*(C`/\*(C'\fR. Most shells have an
empty prefix and suffix.
.IP "12." 4
\&\fIpage()\fR
.Sp
.Vb 1
\&   page($txt)
.Ve
.Sp
Prints \f(CW$txt\fR through a pager, prompting the user to press a key for the next
screen full of text.
.IP "13." 4
\&\fIline()\fR
.Sp
\&\fIline_parsed()\fR
.Sp
Although \f(CW\*(C`run_foo()\*(C'\fR is called with the parsed arguments from the
command-line, you may wish to see the raw command-line. This is available
through the \fIline()\fR method. If you want to retrieve the parsed line again, use
\&\fIline_parsed()\fR.
.Sp
\&\fIline_parsed()\fR accepts an optional string parameter: the line to parse. If you
have your own line to parse, you can pass it to \fIline_parsed()\fR and get back a
list of arguments. This is useful inside completion methods, since you don't
get a parsed list there.
.IP "14." 4
\&\fIrun()\fR
.Sp
If you want to run another handler from within a handler, and you have
pre-parsed arguments, use \fIrun()\fR instead of \fIcmd()\fR. \fIcmd()\fR parses its parameter,
whereas \fIrun()\fR takes each element as a separate parameter.
.Sp
It needs the name of the action to run and any arguments to pass to the
handler.
.Sp
Term::Shell uses this method internally to invoke command handlers.
.IP "15." 4
\&\fIhelp()\fR
.Sp
If you want to get the raw text of a help message, use \fIhelp()\fR. It needs the
name of the help topic and any arguments to pass to the handler.
.Sp
Term::Shell uses this method internally to invoke help handlers.
.IP "16." 4
\&\fIsummary()\fR
.Sp
If you want to get the summary text of an action, use \fIsummary()\fR. It needs the
name of the action.
.Sp
Term::Shell uses this method internally to display the help page.
.IP "17." 4
\&\fIpossible_actions()\fR
.Sp
You will probably want this method in \fIcomp_foo()\fR. \fIpossible_actions()\fR takes a
word and a list, and returns a list of possible matches. Term::Shell uses this
method internally to decide which handler to run when the user enters a
command.
.Sp
There are several arguments, but you probably won't use them all in the simple
cases:
.RS 4
.IP "1." 4
\&\f(CW$needle\fR
.Sp
The (possible incomplete) word to try to match against the list of actions
(the haystack).
.IP "2." 4
\&\f(CW$type\fR
.Sp
The type with which to prefix \f(CW$action\fR. This is useful when completing a
real action \*(-- you have to specify whether you want it to look for \*(L"run_\*(R" or
\&\*(L"help_\*(R" or something else. If you leave it blank, it will use \f(CW$action\fR
without prefixing it.
.IP "3." 4
\&\f(CW$strip\fR
.Sp
If you pass in a true value here, \fIpossible_actions()\fR will remove an initial
\&\f(CW$type\fR from the beginning of each result before returning the results. This
is useful if you want to know what the possible \*(L"run_\*(R" commands are, but you
don't want to have the \*(L"run_\*(R" in the final result.
.Sp
If you do not specify this argument, it uses '0' (the default is not to strip
the results).
.IP "4." 4
\&\f(CW$haystack\fR
.Sp
You can pass in a reference to a list of strings here. Each string will be
compared with \f(CW$needle\fR.
.Sp
If you do not specify this argument, it uses the list of handlers. This is how
Term::Shell matches commands typed in by the user with command handlers
written by you.
.RE
.RS 4
.RE
.IP "18." 4
\&\fIprint_pairs()\fR
.Sp
This overloaded beast is used whenever Term::Shell wants to print a set of
keys and values. It handles wrapping long values, indenting the whole thing,
inserting the separator between the key and value, and all the rest.
.Sp
There are lots of parameters, but most of them are optional:
.RS 4
.IP "1." 4
\&\f(CW$keys\fR
.Sp
A reference to a list of keys to print.
.IP "2." 4
\&\f(CW$values\fR
.Sp
A reference to a list of values to print.
.IP "3." 4
\&\f(CW$sep\fR
.Sp
The string used to separate the keys and values. If omitted, ': ' is used.
.IP "4." 4
\&\f(CW$left\fR
.Sp
The justification to be used to line up the keys. If true, the keys will be
left-justified. If false or omitted, the keys will be right-justified.
.IP "5." 4
\&\f(CW$ind\fR
.Sp
A string used to indent the whole paragraph. Internally, \fIprint_pairs()\fR uses
\&\fIlength()\fR, so you shouldn't use tabs in the indent string. If omitted, the
empty string is used (no indent).
.IP "6." 4
\&\f(CW$len\fR
.Sp
An integer which describes the minimum length of the keys. Normally,
\&\fIprint_pairs()\fR calculates the longest key and assigns the column width to be
as wide as the longest key plus the separator. You can force the column width
to be larger using \f(CW$len\fR. If omitted, 0 is used.
.IP "7." 4
\&\f(CW$wrap\fR
.Sp
A boolean which indicates whether the value should be text-wrapped using
Text::Autoformat. Text is only ever wrapped if it contains at least one space.
If omitted, 0 is used.
.IP "8." 4
\&\f(CW$cols\fR
.Sp
An integer describing the number of columns available on the current terminal.
Normally 78 is used, or the environment variable \s-1COLUMNS\s0, but you can override
the number here to simulate a right-indent.
.RE
.RS 4
.RE
.IP "19." 4
\&\fIterm()\fR
.Sp
Returns the underlying \f(CW\*(C`Term::ReadLine\*(C'\fR object used to interact with the
user. You can do powerful things with this object; in particular, you will
cripple Term::Shell's completion scheme if you change the completion callback
function.
.IP "20." 4
\&\fIprocess_esc()\fR
.Sp
This method may be overridden to provide shell-like escaping of backslashes
inside quoted strings. It accepts two parameters:
.RS 4
.IP "1." 4
\&\f(CW$c\fR
.Sp
The character which was escaped by a backslash.
.IP "2." 4
\&\f(CW$quote\fR
.Sp
The quote character used to delimit this string. Either \f(CW\*(C`"\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR.
.RE
.RS 4
.Sp
This method should return the string which should replace the backslash and
the escaped character.
.Sp
By default, \fIprocess_esc()\fR uses escaping rules similar to Perl's single-quoted
string:
.IP "1." 4
Escaped backslashes return backslashes. The string \f(CW"123\e\e456"\fR returns
\&\f(CW\*(C`123\e456\*(C'\fR.
.IP "2." 4
Escaped quote characters return the quote character (to allow quote characters
in strings). The string \f(CW"abc\e"def"\fR returns \f(CW\*(C`abc"def\*(C'\fR.
.IP "3." 4
All other backslashes are returned verbatim. The string \f(CW"123\e456"\fR returns
\&\f(CW\*(C`123\e456\*(C'\fR.
.RE
.RS 4
.Sp
Term::Shell's quote characters cannot be overridden, unless you override
\&\fIline_parsed()\fR: they are \f(CW\*(C`"\*(C'\fR or \f(CW\*(C`\*(Aq\*(C'\fR. This may change in a future version of
Term::Shell.
.RE
.IP "21." 4
\&\fIadd_handlers()\fR
.Sp
See \*(L"Adding Commands to Your Shell\*(R" for information on \fIadd_handlers()\fR.
.IP "22." 4
\&\fIremove_commands()\fR
.Sp
\&\fIremove_handlers()\fR
.Sp
See \*(L"Removing Commands from Your Shell\*(R" for information on \fIremove_handlers()\fR.
.SH "The Term::Shell Object"
.IX Header "The Term::Shell Object"
Term::Shell creates a hash based Perl object. The object contains information
like what handlers it found, the underlying Term::ReadLine object, and any
arguments passed to the constructor.
.PP
This hash is broken into several subhashes. The only two subhashes that a
Shell should ever use are \f(CW$o\fR\->{\s-1API\s0} and \f(CW$o\fR\->{\s-1SHELL\s0}. The first one contains
all the information that Term::Shell has gathered for you. The second one is a
private area where your Shell can freely store data that it might need later
on.
.PP
This section will describe all the Term::Shell object \*(L"\s-1API\s0\*(R" attributes:
.SS "The args Attribute"
.IX Subsection "The args Attribute"
This an array reference containing any arguments passed to the Term::Shell
constructor.
.SS "The case_ignore Attribute"
.IX Subsection "The case_ignore Attribute"
This boolean controls whether commands should be matched without regard to
case. If this is true, then typing \f(CW\*(C`FoO\*(C'\fR will have the same effect as typing
\&\f(CW\*(C`foo\*(C'\fR.
.PP
Defaults to true on MSWin32, and false on other platforms.
.SS "The class Attribute"
.IX Subsection "The class Attribute"
The class of the object. This is probably the package containing the
definition of your shell, but if someone subclasses \fIyour\fR shell, it's their
class.
.SS "The command Attribute"
.IX Subsection "The command Attribute"
Whenever Term::Shell invokes an action, it stores information about the action
in the \f(CW\*(C`command\*(C'\fR attribute. Information about the last \*(L"run\*(R" action to be
invoked is stored in \f(CW$o\fR\->{\s-1API\s0}{command}{run}. The information itself is stored
in a subhash containing these fields:
.IP "name" 4
.IX Item "name"
The name of the command, as typed by the user.
.IP "found" 4
.IX Item "found"
The a boolean value indicating whether a handler could be found.
.IP "handler" 4
.IX Item "handler"
The full name of the handler, if found.
.PP
Note that this facility only stores information about the \fIlast\fR action to be
executed. It's good enough for retrieving the information about the last
handler which ran, but not for much else.
.PP
The following example shows a case where \f(CW\*(C`run_foo()\*(C'\fR calls \f(CW\*(C`run_add()\*(C'\fR, and
prints its return value (in this case, 42).
.PP
.Vb 5
\&   sub run_foo {
\&       my $o = shift;
\&       my $sum = $o\->run("add", 21, 21);
\&       print "21 + 21 = ", $sum, "\en";
\&   }
\&
\&   sub run_add {
\&       my $o = shift;
\&       my $sum = 0;
\&       $sum += $_ for @_;
\&       print "add(): sum = $sum\en";
\&       return $sum;
\&   }
.Ve
.PP
At the end of \fIrun_foo()\fR, \f(CW$o\fR\->{\s-1API\s0}{command}{run}{handler} contains the string
\&\f(CW"run_add"\fR.
.SS "The match_uniq Attribute"
.IX Subsection "The match_uniq Attribute"
This boolean controls whether the user can type in only enough of the command
to make it unambiguous. If true, then if the shell has the commands \f(CW\*(C`foo\*(C'\fR and
\&\f(CW\*(C`bar\*(C'\fR defined, the user can type \f(CW\*(C`f\*(C'\fR to run \f(CW\*(C`foo\*(C'\fR, and \f(CW\*(C`b\*(C'\fR to run \f(CW\*(C`bar\*(C'\fR.
.PP
Defaults to true.
.SS "The readline Attribute"
.IX Subsection "The readline Attribute"
Which Term::ReadLine module is being used. Currently, this is always one of
\&\f(CW\*(C`Term::ReadLine::Stub\*(C'\fR, \f(CW\*(C`Term::ReadLine::Perl\*(C'\fR, or \f(CW\*(C`Term::ReadLine::Gnu\*(C'\fR.
.SS "The script Attribute"
.IX Subsection "The script Attribute"
The name of the script that invoked your shell.
.SS "The version Attribute"
.IX Subsection "The version Attribute"
The version of Term::Shell you are running under.
.SH "BUGS AND DEFICIENCIES"
.IX Header "BUGS AND DEFICIENCIES"
There are bound to be some bugs lurking about.
.PP
If you find bugs, please send them to \f(CW\*(C`NEILW@cpan.org\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For more information about the underlying ReadLine module, see
Term::ReadLine. You may also want to look at Term::ReadLine::Gnu and
Term::ReadLine::Perl.
.PP
For more information about the underlying formatter used by \fIprint_pairs()\fR, see
Text::Autoformat.
.PP
The \s-1API\s0 for Term::Shell was inspired by (gasp!) a Python package called
\&\f(CW\*(C`cmd\*(C'\fR. For more information about this package, please look in the Python
Library Reference, either in your Python distribution or at
http://www.python.org/doc/current/lib/module\-cmd.html
.SH "AUTHOR"
.IX Header "AUTHOR"
Neil Watkiss (NEILW@cpan.org)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001, Neil Watkiss. All Rights Reserved.
.PP
All Rights Reserved. This module is free software. It may be used,
redistributed and/or modified under the same terms as Perl itself.
.PP
See http://www.perl.com/perl/misc/Artistic.html
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 211:" 4
.IX Item "Around line 211:"
You forgot a '=back' before '=head2'
.IP "Around line 244:" 4
.IX Item "Around line 244:"
=back without =over
