.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sybase 3"
.TH Sybase 3 "2011-04-25" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBD::Sybase \- Sybase database driver for the DBI module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use DBI;
\&
\&    $dbh = DBI\->connect("dbi:Sybase:", $user, $passwd);
\&
\&    # See the DBI module documentation for full details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBD::Sybase is a Perl module which works with the \s-1DBI\s0 module to provide
access to Sybase databases.
.SH "Connecting to Sybase"
.IX Header "Connecting to Sybase"
.SS "The interfaces file"
.IX Subsection "The interfaces file"
The DBD::Sybase module is built on top of the Sybase \fIOpen Client Client 
Library\fR \s-1API\s0. This library makes use of the Sybase \fIinterfaces\fR file
(\fIsql.ini\fR on Win32 machines) to make a link between a logical
server name (e.g. \s-1SYBASE\s0) and the physical machine / port number that
the server is running on. The OpenClient library uses the environment
variable \fB\s-1SYBASE\s0\fR to find the location of the \fIinterfaces\fR file,
as well as other files that it needs (such as locale files). The \fB\s-1SYBASE\s0\fR
environment is the path to the Sybase installation (eg '/usr/local/sybase').
If you need to set it in your scripts, then you \fImust\fR set it in a
\&\f(CW\*(C`BEGIN{}\*(C'\fR block:
.PP
.Vb 3
\&   BEGIN {
\&       $ENV{SYBASE} = \*(Aq/opt/sybase/11.0.2\*(Aq;
\&   }
\&
\&   my $dbh = DBI\->connect(\*(Aqdbi:Sybase:\*(Aq, $user, $passwd);
.Ve
.SS "Specifying the server name"
.IX Subsection "Specifying the server name"
The server that DBD::Sybase connects to defaults to \fI\s-1SYBASE\s0\fR, but
can be specified in two ways.
.PP
You can set the \fI\s-1DSQUERY\s0\fR environement variable:
.PP
.Vb 2
\&    $ENV{DSQUERY} = "ENGINEERING";
\&    $dbh = DBI\->connect(\*(Aqdbi:Sybase:\*(Aq, $user, $passwd);
.Ve
.PP
Or you can pass the server name in the first argument to \fIconnect()\fR:
.PP
.Vb 1
\&    $dbh = DBI\->connect("dbi:Sybase:server=ENGINEERING", $user, $passwd);
.Ve
.SS "Specifying other connection specific parameters"
.IX Subsection "Specifying other connection specific parameters"
It is sometimes necessary (or beneficial) to specify other connection
properties. Currently the following are supported:
.IP "server" 4
.IX Item "server"
Specify the server that we should connect to.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:server=BILLING",
\&                         $user, $passwd);
.Ve
.Sp
The default server is \fI\s-1SYBASE\s0\fR, or the value of the \fI\f(CI$DSQUERY\fI\fR environment
variable, if it is set.
.IP "host =item port" 4
.IX Item "host =item port"
If you built DBD::Sybase with OpenClient 12.5.1 or later, then you can
use the \fIhost\fR and \fIport\fR values to define the server you want to
connect to. This will by-pass the server name lookup in the interfaces file.
This is useful in the case where the server hasn't been entered in the 
interfaces file.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:host=db1.domain.com;port=4100",
\&                         $user, $passwd);
.Ve
.IP "maxConnect" 4
.IX Item "maxConnect"
By default DBD::Sybase (and the underlying OpenClient libraries) is limited
to openening 25 simultaneous connections to one or more database servers.
If you need more than 25 connections at the same time, you can use the
\&\fImaxConnect\fR option to increase this number.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:maxConnect=100",
\&                         $user, $passwd);
.Ve
.IP "database" 4
.IX Item "database"
Specify the database that should be made the default database.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:database=sybsystemprocs",
\&                         $user, $passwd);
.Ve
.Sp
This is equivalent to
.Sp
.Vb 2
\&    $dbh = DBI\->connect(\*(Aqdbi:Sybase:\*(Aq, $user, $passwd);
\&    $dbh\->do("use sybsystemprocs");
.Ve
.IP "charset" 4
.IX Item "charset"
Specify the character set that the client uses.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:charset=iso_1",
\&                         $user, $passwd);
.Ve
.IP "language" 4
.IX Item "language"
Specify the language that the client uses.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:language=us_english",
\&                         $user, $passwd);
.Ve
.Sp
Note that the language has to have been installed on the server (via
langinstall or sp_addlanguage) for this to work. If the language is not
installed the session will default to the default language of the 
server.
.IP "packetSize" 4
.IX Item "packetSize"
Specify the network packet size that the connection should use. Using a
larger packet size can increase performance for certain types of queries.
See the Sybase documentation on how to enable this feature on the server.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:packetSize=8192",
\&                         $user, $passwd);
.Ve
.IP "interfaces" 4
.IX Item "interfaces"
Specify the location of an alternate \fIinterfaces\fR file:
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:interfaces=/usr/local/sybase/interfaces",
\&                         $user, $passwd);
.Ve
.IP "loginTimeout" 4
.IX Item "loginTimeout"
Specify the number of seconds that \s-1DBI\-\s0>\fIconnect()\fR will wait for a 
response from the Sybase server. If the server fails to respond before the
specified number of seconds the \s-1DBI\-\s0>\fIconnect()\fR call fails with a timeout
error. The default value is 60 seconds, which is usually enough, but on a busy
server it is sometimes necessary to increase this value:
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:loginTimeout=240", # wait up to 4 minutes
\&                         $user, $passwd);
.Ve
.IP "timeout" 4
.IX Item "timeout"
Specify the number of seconds after which any Open Client calls will timeout
the connection and mark it as dead. Once a timeout error has been received
on a connection it should be closed and re-opened for further processing.
.Sp
Setting this value to 0 or a negative number will result in an unlimited
timeout value. See also the Open Client documentation on \s-1CS_TIMEOUT\s0.
.Sp
.Vb 2
\&     $dbh = DBI\->connect("dbi:Sybase:timeout=240", # wait up to 4 minutes
\&                         $user, $passwd);
.Ve
.IP "scriptName" 4
.IX Item "scriptName"
Specify the name for this connection that will be displayed in sp_who
(ie in the sysprocesses table in the \fIprogram_name\fR column).
.Sp
.Vb 1
\&    $dbh=DBI\->connect("dbi:Sybase:scriptName=myScript", $user, $password);
.Ve
.IP "hostname" 4
.IX Item "hostname"
Specify the hostname that will be displayed by sp_who (and will be stored
in the hostname column of sysprocesses)..
.Sp
.Vb 1
\&    $dbh=DBI\->connect("dbi:Sybase:hostname=kiruna", $user, $password);
.Ve
.IP "tdsLevel" 4
.IX Item "tdsLevel"
Specify the \s-1TDS\s0 protocol level to use when connecting to the server.
Valid values are \s-1CS_TDS_40\s0, \s-1CS_TDS_42\s0, \s-1CS_TDS_46\s0, \s-1CS_TDS_495\s0 and \s-1CS_TDS_50\s0.
In general this is automatically negotiated between the client and the 
server, but in certain cases this may need to be forced to a lower level
by the client.
.Sp
.Vb 1
\&    $dbh=DBI\->connect("dbi:Sybase:tdsLevel=CS_TDS_42", $user, $password);
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR: Setting the tdsLevel below \s-1CS_TDS_495\s0 will disable a number of
features, ?\-style placeholders and \s-1CHAINED\s0 non-AutoCommit mode, in particular.
.IP "encryptPassword" 4
.IX Item "encryptPassword"
Specify the use of the client password encryption supported by CT-Lib.
Specify a value of 1 to use encrypted passwords.
.Sp
.Vb 1
\&    $dbh=DBI\->connect("dbi:Sybase:encryptPassword=1", $user, $password);
.Ve
.IP "kerberos" 4
.IX Item "kerberos"
Note: Requires OpenClient 11.1.1 or later.
.Sp
Sybase and OpenClient can use Kerberos to perform network-based login.
If you use Kerberos for authentication you can use this feature and pass
a kerberos serverprincipal using the \f(CW\*(C`kerberos=value\*(C'\fR parameter:
.Sp
.Vb 1
\&    $dbh = DBI\->connect("dbi:Sybase:kerberos=$serverprincipal", \*(Aq\*(Aq, \*(Aq\*(Aq);
.Ve
.Sp
In addition, if you have a system for retrieving Kerberos serverprincipals at
run-time you can tell DBD::Sybase to call a perl subroutine to get
the serverprincipal from \fIconnect()\fR:
.Sp
.Vb 5
\&    sub sybGetPrinc {
\&        my $srv = shift;
\&        return the serverprincipal...
\&    }
\&    $dbh = DBI\->connect(\*(Aqdbi:Sybase:server=troll\*(Aq, \*(Aq\*(Aq, \*(Aq\*(Aq, { syb_kerberos_serverprincipal => \e&sybGetPrinc });
.Ve
.Sp
The subroutine will be called with one argument (the server that we will
connect to, using the normal Sybase behavior of checking the \s-1DSQUERY\s0
environment variable if no server is specified in the \fIconnect()\fR) and is
expected to return a string (the Kerberos serverprincipal) to the caller.
.IP "sslCAFile" 4
.IX Item "sslCAFile"
Specify the location of an alternate \fItrusted.txt\fR file for \s-1SSL\s0
connection negotiation:
.Sp
.Vb 1
\&  $dbh\->DBI\->connect("dbi:Sybase:sslCAFile=/usr/local/sybase/trusted.txt.ENGINEERING", $user, $password);
.Ve
.IP "bulkLogin" 4
.IX Item "bulkLogin"
Set this to 1 if the connection is going to be used for a bulk-load
operation (see \fIExperimental Bulk-Load functionality\fR elsewhere in this
document.)
.Sp
.Vb 1
\&  $dbh\->DBI\->connect("dbi:Sybase:bulkLogin=1", $user, $password);
.Ve
.IP "serverType" 4
.IX Item "serverType"
Tell DBD::Sybase what the server type is. Defaults to \s-1ASE\s0. Setting it to 
something else will prevent certain actions (such as setting options, 
fetching the \s-1ASE\s0 version via @@version, etc.) and avoid spurious errors.
.IP "tds_keepalive" 4
.IX Item "tds_keepalive"
Set this to 1 to tell OpenClient to enable the \s-1KEEP_ALIVE\s0 attribute on the 
connection. Default 1.
.PP
These different parameters (as well as the server name) can be strung
together by separating each entry with a semi-colon:
.PP
.Vb 2
\&    $dbh = DBI\->connect("dbi:Sybase:server=ENGINEERING;packetSize=8192;language=us_english;charset=iso_1",
\&                        $user, $pwd);
.Ve
.SH "Handling Multiple Result Sets"
.IX Header "Handling Multiple Result Sets"
Sybase's Transact \s-1SQL\s0 has the ability to return multiple result sets
from a single \s-1SQL\s0 statement. For example the query:
.PP
.Vb 5
\&    select b.title, b.author, s.amount
\&      from books b, sales s
\&     where s.authorID = b.authorID
\&     order by b.author, b.title
\&    compute sum(s.amount) by b.author
.Ve
.PP
which lists sales by author and title and also computes the total sales
by author returns two types of rows. The \s-1DBI\s0 spec doesn't really 
handle this situation, nor the more hairy
.PP
.Vb 1
\&    exec my_proc @p1=\*(Aqthis\*(Aq, @p2=\*(Aqthat\*(Aq, @p3 out
.Ve
.PP
where \f(CW\*(C`my_proc\*(C'\fR could return any number of result sets (ie it could
perform an unknown number of \f(CW\*(C`select\*(C'\fR statements.
.PP
I've decided to handle this by returning an empty row at the end
of each result set, and by setting a special Sybase attribute in \f(CW$sth\fR
which you can check to see if there is more data to be fetched. The 
attribute is \fBsyb_more_results\fR which you should check to see if you
need to re-start the \f(CW\*(C`fetch()\*(C'\fR loop.
.PP
To make sure all results are fetched, the basic \f(CW\*(C`fetch\*(C'\fR loop can be 
written like this:
.PP
.Vb 4
\&     {
\&         while($d = $sth\->fetch) {
\&            ... do something with the data
\&         }
\&
\&         redo if $sth\->{syb_more_results};
\&     }
.Ve
.PP
You can get the type of the current result set with 
\&\f(CW$sth\fR\->{syb_result_type}. This returns a numerical value, as defined in 
\&\f(CW$SYBASE\fR/$SYBASE_OCS/include/cspublic.h:
.PP
.Vb 6
\&        #define CS_ROW_RESULT           (CS_INT)4040
\&        #define CS_CURSOR_RESULT        (CS_INT)4041
\&        #define CS_PARAM_RESULT         (CS_INT)4042
\&        #define CS_STATUS_RESULT        (CS_INT)4043
\&        #define CS_MSG_RESULT           (CS_INT)4044
\&        #define CS_COMPUTE_RESULT       (CS_INT)4045
.Ve
.PP
In particular, the return status of a stored procedure is returned
as \s-1CS_STATUS_RESULT\s0 (4043), and is normally the last result set that is 
returned in a stored proc execution, but see the \fBsyb_do_proc_status\fR 
attribute for an alternative way of handling this result type. See \fBExecuting 
Stored Procedures\fR elsewhere in this document for more information.
.PP
If you add a
.PP
.Vb 1
\&    use DBD::Sybase;
.Ve
.PP
to your script then you can use the symbolic values (CS_xxx_RESULT) 
instead of the numeric values in your programs, which should make them 
easier to read.
.PP
See also the \f(CW\*(C`$sth\-\*(C'\fRsyb_output_params> call to handle stored procedures 
that \fBonly\fR return \fB\s-1OUTPUT\s0\fR parameters.
.ie n .SH "$sth\->\fIexecute()\fP failure mode behavior"
.el .SH "\f(CW$sth\fP\->\fIexecute()\fP failure mode behavior"
.IX Header "$sth->execute() failure mode behavior"
DBD::Sybase has the ability to handle multi-statement \s-1SQL\s0 commands
in a single batch. For example, you could insert several rows in 
a single batch like this:
.PP
.Vb 7
\&   $sth = $dbh\->prepare("
\&   insert foo(one, two, three) values(1, 2, 3)
\&   insert foo(one, two, three) values(4, 5, 6)
\&   insert foo(one, two, three) values(10, 11, 12)
\&   insert foo(one, two, three) values(11, 12, 13)
\&   ");
\&   $sth\->execute;
.Ve
.PP
If any one of the above inserts fails for any reason then \f(CW$sth\fR\->execute
will return \f(CW\*(C`undef\*(C'\fR, \fB\s-1HOWEVER\s0\fR the inserts that didn't fail will still
be in the database, unless \f(CW\*(C`AutoCommit\*(C'\fR is off.
.PP
It's also possible to write a statement like this:
.PP
.Vb 6
\&   $sth = $dbh\->prepare("
\&   insert foo(one, two, three) values(1, 2, 3)
\&   select * from bar
\&   insert foo(one, two, three) values(10, 11, 12)
\&   ");
\&   $sth\->execute;
.Ve
.PP
If the second \f(CW\*(C`insert\*(C'\fR is the one that fails, then \f(CW$sth\fR\->execute will
\&\fB\s-1NOT\s0\fR return \f(CW\*(C`undef\*(C'\fR. The error will get flagged after the rows
from \f(CW\*(C`bar\*(C'\fR have been fetched.
.PP
I know that this is not as intuitive as it could be, but I am
constrained by the Sybase \s-1API\s0 here.
.PP
As an aside, I know that the example above doesn't really make sense, 
but I need to illustrate this particular sequence... You can also see the 
t/fail.t test script which shows this particular behavior.
.SH "Sybase Specific Attributes"
.IX Header "Sybase Specific Attributes"
There are a number of handle  attributes that are specific to this driver.
These attributes all start with \fBsyb_\fR so as to not clash with any
normal \s-1DBI\s0 attributes.
.SS "Database Handle Attributes"
.IX Subsection "Database Handle Attributes"
The following Sybase specific attributes can be set at the Database handle
level:
.IP "syb_show_sql (bool)" 4
.IX Item "syb_show_sql (bool)"
If set then the current statement is included in the string returned by 
\&\f(CW$dbh\fR\->errstr.
.IP "syb_show_eed (bool)" 4
.IX Item "syb_show_eed (bool)"
If set, then extended error information is included in the string returned 
by \f(CW$dbh\fR\->errstr. Extended error information include the index causing a
duplicate insert to fail, for example.
.IP "syb_err_handler (subroutine ref)" 4
.IX Item "syb_err_handler (subroutine ref)"
This attribute is used to set an ad-hoc error handler callback (ie a
perl subroutine) that gets called before the normal error handler does
it's job.  If this subroutine returns 0 then the error is
ignored. This is useful for handling \s-1PRINT\s0 statements in Transact-SQL,
for handling messages from the Backup Server, showplan output, dbcc
output, etc.
.Sp
The subroutine is called with nine parameters:
.Sp
.Vb 11
\&  o the Sybase error number
\&  o the severity
\&  o the state
\&  o the line number in the SQL batch
\&  o the server name (if available)
\&  o the stored procedure name (if available)
\&  o the message text
\&  o the current SQL command buffer
\&  o either of the strings "client" (for Client Library errors) or
\&    "server" (for server errors, such as SQL syntax errors, etc),
\&    allowing you to identify the error type.
.Ve
.Sp
As a contrived example, here is a port of the distinct error and
message handlers from the Sybase documentation:
.Sp
.Vb 1
\&  Example:
\&  
\&  sub err_handler {
\&      my($err, $sev, $state, $line, $server,
\&        $proc, $msg, $sql, $err_type) = @_;
\& 
\&      my @msg = ();
\&      if($err_type eq \*(Aqserver\*(Aq) {
\&         push @msg,
\&           (\*(Aq\*(Aq,
\&            \*(AqServer message\*(Aq,
\&            sprintf(\*(AqMessage number: %ld, Severity %ld, State %ld, Line %ld\*(Aq,
\&                    $err,$sev,$state,$line),
\&            (defined($server) ? "Server \*(Aq$server\*(Aq " : \*(Aq\*(Aq) .
\&            (defined($proc) ? "Procedure \*(Aq$proc\*(Aq" : \*(Aq\*(Aq),
\&            "Message String:$msg");
\&      } else {
\&         push @msg,
\&           (\*(Aq\*(Aq,
\&            \*(AqOpen Client Message:\*(Aq,
\&            sprintf(\*(AqMessage number: SEVERITY = (%ld) NUMBER = (%ld)\*(Aq,
\&                    $sev, $err),
\&            "Message String: $msg");
\&      }
\&      print STDERR join("\en",@msg);
\&      return 0; ## CS_SUCCEED
\&  }
.Ve
.Sp
In a simpler and more focused example, this error handler traps
showplan messages:
.Sp
.Vb 4
\&   %showplan_msgs = map { $_ => 1}  (3612 .. 3615, 6201 .. 6299, 10201 .. 10299);
\&   sub err_handler {
\&      my($err, $sev, $state, $line, $server,
\&        $proc, $msg, $sql, $err_type) = @_;
\&  
\&       if($showplan_msgs{$err}) { # it\*(Aqs a showplan message
\&         print SHOWPLAN "$err \- $msg\en";
\&         return 0;    # This is not an error
\&       }
\&       return 1;
\&   }
.Ve
.Sp
and this is how you would use it:
.Sp
.Vb 6
\&    $dbh = DBI\->connect(\*(Aqdbi:Sybase:server=troll\*(Aq, \*(Aqsa\*(Aq, \*(Aq\*(Aq);
\&    $dbh\->{syb_err_handler} = \e&err_handler;
\&    $dbh\->do("set showplan on");
\&    open(SHOWPLAN, ">>/var/tmp/showplan.log") || die "Can\*(Aqt open showplan log: $!";
\&    $dbh\->do("exec someproc");    # get the showplan trace for this proc.
\&    $dbh\->disconnect;
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR \- if you set the error handler in the \s-1DBI\-\s0>\fIconnect()\fR call like this
.Sp
.Vb 2
\&    $dbh = DBI\->connect(\*(Aqdbi:Sybase:server=troll\*(Aq, \*(Aqsa\*(Aq, \*(Aq\*(Aq, 
\&                    { syb_err_handler => \e&err_handler });
.Ve
.Sp
then the \fIerr_handler()\fR routine will get called if there is an error during
       the connect itself. This is \fBnew\fR behavior in DBD::Sybase 0.95.
.IP "syb_flush_finish (bool)" 4
.IX Item "syb_flush_finish (bool)"
If \f(CW$dbh\fR\->{syb_flush_finish} is set then \f(CW$dbh\fR\->finish will drain any
results remaining for the current command by actually fetching them.
The default behaviour is to issue a ct_cancel(\s-1CS_CANCEL_ALL\s0), but this
\&\fIappears\fR to cause connections to hang or to fail in certain cases
(although I've never witnessed this myself.)
.IP "syb_dynamic_supported (bool)" 4
.IX Item "syb_dynamic_supported (bool)"
This is a read-only attribute that returns \s-1TRUE\s0 if the dataserver
you are connected to supports ?\-style placeholders. Typically placeholders are
not supported when using DBD::Sybase to connect to a MS-SQL server.
.IP "syb_chained_txn (bool)" 4
.IX Item "syb_chained_txn (bool)"
If set then we use \s-1CHAINED\s0 transactions when AutoCommit is off. 
Otherwise we issue an explicit \s-1BEGIN\s0 \s-1TRAN\s0 as needed. The default is on
if it is supported by the server.
.Sp
This attribute should usually be used only during the \fIconnect()\fR call:
.Sp
.Vb 1
\&    $dbh = DBI\->connect(\*(Aqdbi:Sybase:\*(Aq, $user, $pwd, {syb_chained_txn => 1});
.Ve
.Sp
Using it at any other time with \fBAutoCommit\fR turned \fBoff\fR will 
\&\fBforce a commit\fR on the current handle.
.IP "syb_quoted_identifier (bool)" 4
.IX Item "syb_quoted_identifier (bool)"
If set, then identifiers that would normally clash with Sybase reserved
words can be quoted using \f(CW"identifier"\fR. In this case strings must
be quoted with the single quote.
.Sp
This attribute can only be set if the database handle is idle (no
active statement handle.)
.Sp
Default is for this attribute to be \fBoff\fR.
.IP "syb_rowcount (int)" 4
.IX Item "syb_rowcount (int)"
Setting this attribute to non\-0 will limit the number of rows returned by
a \fI\s-1SELECT\s0\fR, or affected by an \fI\s-1UPDATE\s0\fR or \fI\s-1DELETE\s0\fR statement to the
\&\fIrowcount\fR value. Setting it back to 0 clears the limit.
.Sp
This attribute can only be set if the database handle is idle.
.Sp
Default is for this attribute to be \fB0\fR.
.IP "syb_do_proc_status (bool)" 4
.IX Item "syb_do_proc_status (bool)"
Setting this attribute causes \f(CW$sth\fR\->\fIexecute()\fR to fetch the return status
of any executed stored procs in the \s-1SQL\s0 being executed. If the return
status is non\-0 then \f(CW$sth\fR\->\fIexecute()\fR will report that the operation 
failed.
.Sp
\&\fB\s-1NOTE\s0\fR The result status is \s-1NOT\s0 the first result set that
is fetched from a stored proc execution. If the procedure includes
\&\s-1SELECT\s0 statements then these will be fetched first, which means that 
\&\f(CW\*(C`$sth\-\*(C'\fRexecute> will \s-1NOT\s0 return a failure in that case as DBD::Sybase
won't have seen the result status yet at that point.
.Sp
The RaiseError will \s-1NOT\s0 be triggered by a non\-0 return status if 
there isn't an associated error message either generated by Sybase
(duplicate insert error, etc) or generated in the procedure via a T\-SQL
\&\f(CW\*(C`raiserror\*(C'\fR statement.
.Sp
Setting this attribute does \fB\s-1NOT\s0\fR affect existing \f(CW$sth\fR handles, only
those that are created after setting it. To change the behavior of 
an existing \f(CW$sth\fR handle use \f(CW$sth\fR\->{syb_do_proc_status}.
.Sp
The proc status is available in \f(CW$sth\fR\->{syb_proc_status} after all the
result sets in the procedure have been processed.
.Sp
The default is for this attribute to be \fBoff\fR.
.IP "syb_use_bin_0x" 4
.IX Item "syb_use_bin_0x"
If set, \s-1BINARY\s0 and \s-1VARBINARY\s0 values are prefixed with '0x'
in the result. The default is off.
.IP "syb_binary_images" 4
.IX Item "syb_binary_images"
If set, \s-1IMAGE\s0 data is returned in raw binary format. Otherwise the data is
converted to a long hex string. The default is off.
.IP "syb_oc_version (string)" 4
.IX Item "syb_oc_version (string)"
Returns the identification string of the version of Client Library that
this binary is currently using. This is a read-only attribute.
.Sp
For example:
.Sp
.Vb 2
\&    troll (7:59AM):348 > perl \-MDBI \-e \*(Aq$dbh = DBI\->connect("dbi:Sybase:", "sa"); print "$dbh\->{syb_oc_version}\en";\*(Aq 
\&    Sybase Client\-Library/11.1.1/P/Linux Intel/Linux 2.2.5 i586/1/OPT/Mon Jun  7 07:50:21 1999
.Ve
.Sp
This is very useful information to have when reporting a problem.
.IP "syb_server_version" 4
.IX Item "syb_server_version"
.PD 0
.IP "syb_server_version_string" 4
.IX Item "syb_server_version_string"
.PD
These two attributes return the Sybase server version, respectively
version string, and can be used to turn server-specific functionality
on or off.
.Sp
Example:
.Sp
.Vb 1
\&    print "$dbh\->{syb_server_version}\en$dbh\->{syb_server_version_string}\en";
.Ve
.Sp
prints
.Sp
.Vb 2
\&    12.5.2
\&    Adaptive Server Enterprise/12.5.2/EBF 12061 ESD#2/P/Linux Intel/Enterprise Linux/ase1252/1844/32\-bit/OPT/Wed Aug 11 21:36:26 2004
.Ve
.IP "syb_failed_db_fatal (bool)" 4
.IX Item "syb_failed_db_fatal (bool)"
If this is set, then a \fIconnect()\fR request where the \fIdatabase\fR
specified doesn't exist or is not accessible will fail. This needs
to be set in the attribute hash passed during the \s-1DBI\-\s0>\fIconnect()\fR call
to be effective.
.Sp
Default: off
.IP "syb_no_child_con (bool)" 4
.IX Item "syb_no_child_con (bool)"
If this attribute is set then DBD::Sybase will \fBnot\fR allow multiple
simultaneously active statement handles on one database handle (i.e.
multiple \f(CW$dbh\fR\->\fIprepare()\fR calls without completely processing the
results from any existing statement handle). This can be used
to debug situations where incorrect or unexpected results are
found due to the creation of a sub-connection where the connection
attributes (in particular the current database) are different.
.Sp
Default: off
.IP "syb_bind_empty_string_as_null (bool)" 4
.IX Item "syb_bind_empty_string_as_null (bool)"
If this attribute is set then an empty string (i.e. "") passed as
a parameter to an \f(CW$sth\fR\->\fIexecute()\fR call will be converted to a \s-1NULL\s0
value. If the attribute is not set then an empty string is converted to
a single space.
.Sp
Default: off
.IP "syb_cancel_request_on_error (bool)" 4
.IX Item "syb_cancel_request_on_error (bool)"
If this attribute is set then a failure in a multi-statement request
(for example, a stored procedure execution) will cause \f(CW$sth\fR\->\fIexecute()\fR
to return failure, and will cause any other results from this request to 
be discarded.
.Sp
The default value (\fBon\fR) changes the behavior that DBD::Sybase exhibited
up to version 0.94.
.Sp
Default: on
.IP "syb_date_fmt (string)" 4
.IX Item "syb_date_fmt (string)"
Defines the date/time conversion string when fetching data. See the 
entry for the \f(CW\*(C`syb_date_fmt()\*(C'\fR method elsewhere in this document for a
description of the available formats.
.IP "syb_has_blk (bool)" 4
.IX Item "syb_has_blk (bool)"
This read-only attribute is set to \s-1TRUE\s0 if the \s-1BLK\s0 \s-1API\s0 is available in
this version of DBD::Sybase.
.IP "syb_disconnect_in_child (bool)" 4
.IX Item "syb_disconnect_in_child (bool)"
Sybase client library allows using opened connections across a fork (i.e. the opened connection 
can be used in the child process). \s-1DBI\s0 by default will set flags such that this connection will 
be closed when the child process terminates. This is in most cases not what you want. \s-1DBI\s0 provides
the InactiveDestroy attribute to control this, but you have to set this attribute manually as it
defaults to False (i.e. when \s-1DESTROY\s0 is called for the handle the connection is closed).
The syb_disconnect_in_child attribute attempts to correct this \- the default is for this 
attribute to be False \- thereby inhibitting the closing of the connection(s) when 
the current process \s-1ID\s0 doesn't match the process \s-1ID\s0 that created the connection.
.Sp
Default: off
.IP "syb_enable_utf8 (bool)" 4
.IX Item "syb_enable_utf8 (bool)"
If this attribute is set then DBD::Sybase will convert \s-1UNIVARCHAR\s0, \s-1UNICHAR\s0,
and \s-1UNITEXT\s0 data to Perl's internal utf\-8 encoding when they are
retrieved. Updating a unicode column will cause Sybase to convert any incoming
data from utf\-8 to its internal utf\-16 encoding.
.Sp
Default: off
.SS "Statement Handle Attributes"
.IX Subsection "Statement Handle Attributes"
The following read-only attributes are available at the statement level:
.IP "syb_more_results (bool)" 4
.IX Item "syb_more_results (bool)"
See the discussion on handling multiple result sets above.
.IP "syb_result_type (int)" 4
.IX Item "syb_result_type (int)"
Returns the numeric result type of the current result set. Useful when 
executing stored procedurs to determine what type of information is
currently fetchable (normal select rows, output parameters, status results,
etc...).
.IP "syb_do_proc_status (bool)" 4
.IX Item "syb_do_proc_status (bool)"
See above (under Database Handle Attributes) for an explanation.
.IP "syb_proc_status (read-only)" 4
.IX Item "syb_proc_status (read-only)"
If syb_do_proc_status is set, then the return status of stored procedures will
be available via \f(CW$sth\fR\->{syb_proc_status}.
.IP "syb_no_bind_blob (bool)" 4
.IX Item "syb_no_bind_blob (bool)"
If set then any \s-1IMAGE\s0 or \s-1TEXT\s0 columns in a query are \fB\s-1NOT\s0\fR returned
when calling \f(CW$sth\fR\->fetch (or any variation).
.Sp
Instead, you would use
.Sp
.Vb 1
\&    $sth\->syb_ct_get_data($column, \e$data, $size);
.Ve
.Sp
to retrieve the \s-1IMAGE\s0 or \s-1TEXT\s0 data. If \f(CW$size\fR is 0 then the entire item is
fetched, otherwis  you can call this in a loop to fetch chunks of data:
.Sp
.Vb 5
\&    while(1) {
\&        $sth\->syb_ct_get_data($column, \e$data, 1024);
\&        last unless $data;
\&        print OUT $data;
\&    }
.Ve
.Sp
The fetched data is still subject to Sybase's \s-1TEXTSIZE\s0 option (see the
\&\s-1SET\s0 command in the Sybase reference manual). This can be manipulated with
\&\s-1DBI\s0's \fBLongReadLen\fR attribute, but \f(CW\*(C`$dbh\-\*(C'\fR{LongReadLen}> \fImust\fR be 
set before \f(CW$dbh\fR\->\fIprepare()\fR is called to take effect (this is a change
in 1.05 \- previously you could call it after the \fIprepare()\fR but 
before the \fIexecute()\fR). Note that LongReadLen
has no effect when using DBD::Sybase with an MS-SQL server.
.Sp
\&\fBNote\fR: The \s-1IMAGE\s0 or \s-1TEXT\s0 column that is to be fetched this way \fImust\fR 
be \fIlast\fR in the select list.
.Sp
See also the description of the \fIct_get_data()\fR \s-1API\s0 call in the Sybase
OpenClient manual, and the \*(L"Working with \s-1TEXT/IMAGE\s0 columns\*(R" section
elsewhere in this document.
.SH "Controlling DATETIME output formats"
.IX Header "Controlling DATETIME output formats"
By default DBD::Sybase will return \fI\s-1DATETIME\s0\fR and \fI\s-1SMALLDATETIME\s0\fR
columns in the \fINov 15 1998 11:13AM\fR format. This can be changed
via a private \fB\f(BIsyb_date_fmt()\fB\fR method.
.PP
The syntax is
.PP
.Vb 1
\&    $dbh\->syb_date_fmt($fmt);
.Ve
.PP
where \f(CW$fmt\fR is a string representing the format that you want to apply.
.PP
Note that this requires \s-1DBI\s0 1.37 or later.
.PP
The formats are based on Sybase's standard conversion routines. The following
subset of available formats has been implemented:
.IP "\s-1LONG\s0" 4
.IX Item "LONG"
Nov 15 1998 11:30:11:496AM
.IP "\s-1LONGMS\s0" 4
.IX Item "LONGMS"
New with \s-1ASE\s0 15.5 \- for bigtime/bigdatetime datatypes, includes microseconds:
.Sp
Apr  7 2010 10:40:33.532315PM
.IP "\s-1SHORT\s0" 4
.IX Item "SHORT"
Nov 15 1998 11:30AM
.IP "\s-1DMY4_YYYY\s0" 4
.IX Item "DMY4_YYYY"
15 Nov 1998
.IP "\s-1MDY1_YYYY\s0" 4
.IX Item "MDY1_YYYY"
11/15/1998
.IP "\s-1DMY1_YYYY\s0" 4
.IX Item "DMY1_YYYY"
15/11/1998
.IP "\s-1DMY2_YYYY\s0" 4
.IX Item "DMY2_YYYY"
15.11.1998
.IP "\s-1YMD3_YYYY\s0" 4
.IX Item "YMD3_YYYY"
19981115
.IP "\s-1HMS\s0" 4
.IX Item "HMS"
11:30:11
.IP "\s-1ISO\s0" 4
.IX Item "ISO"
2004\-08\-21 14:36:48.080
.IP "ISO_strict" 4
.IX Item "ISO_strict"
2004\-08\-21T14:36:48.080Z
.Sp
Note that Sybase has no concept of a timezone, so the trailing \*(L"Z\*(R" is
really not correct (assumes that the time is in \s-1UTC\s0). However, there
is no guarantee that the client and the server run in the same timezone,
so assuming the timezone of the client isn't really a valid option
either.
.SH "Retrieving OUTPUT parameters from stored procedures"
.IX Header "Retrieving OUTPUT parameters from stored procedures"
Sybase lets you pass define \fB\s-1OUTPUT\s0\fR parameters to stored procedures,
which are a little like parameters passed by reference in C (or perl.)
.PP
In Transact-SQL this is done like this
.PP
.Vb 3
\&   declare @id_value int, @id_name char(10)
\&   exec my_proc @name = \*(Aqa string\*(Aq, @number = 1234, @id = @id_value OUTPUT, @out_name = @id_name OUTPUT
\&   \-\- Now @id_value and @id_name are set to whatever \*(Aqmy_proc\*(Aq set @id and @out_name to
.Ve
.PP
So how can we get at \f(CW@param\fR using DBD::Sybase?
.PP
If your stored procedure \fBonly\fR returns \fB\s-1OUTPUT\s0\fR parameters, then you
can use this shorthand:
.PP
.Vb 3
\&    $sth = $dbh\->prepare(\*(Aq...\*(Aq);
\&    $sth\->execute;
\&    @results = $sth\->syb_output_params();
.Ve
.PP
This will return an array for all the \s-1OUTPUT\s0 parameters in the proc call,
and will ignore any other results. The array will be undefined if there are 
no \s-1OUTPUT\s0 params, or if the stored procedure failed for some reason.
.PP
The more generic way looks like this:
.PP
.Vb 10
\&   $sth = $dbh\->prepare("declare \e@id_value int, \e@id_name
\&      exec my_proc @name = \*(Aqa string\*(Aq, @number = 1234, @id = @id_value OUTPUT, @out_name = @id_name OUTPUT");
\&   $sth\->execute;
\&   {
\&      while($d = $sth\->fetch) {
\&         if($sth\->{syb_result_type} == 4042) { # it\*(Aqs a PARAM result
\&            $id_value = $d\->[0];
\&            $id_name  = $d\->[1];
\&         }
\&      }
\&
\&      redo if $sth\->{syb_more_results};
\&   }
.Ve
.PP
So the \s-1OUTPUT\s0 params are returned as one row in a special result set.
.ie n .SH "Multiple active statements on one $dbh"
.el .SH "Multiple active statements on one \f(CW$dbh\fP"
.IX Header "Multiple active statements on one $dbh"
It is possible to open multiple active statements on a single database 
handle. This is done by opening a new physical connection in \f(CW$dbh\fR\->\fIprepare()\fR
if there is already an active statement handle for this \f(CW$dbh\fR.
.PP
This feature has been implemented to improve compatibility with other
drivers, but should not be used if you are coding directly to the 
Sybase driver.
.PP
The \f(CW\*(C`syb_no_child_con\*(C'\fR attribute controls whether this feature is 
turned on. If it is \s-1FALSE\s0 (the default), then multiple statement handles are
supported. If it is \s-1TRUE\s0 then multiple statements on the same database
handle are disabled. Also see below for interaction with AutoCommit.
.PP
If AutoCommit is \fB\s-1OFF\s0\fR then multiple statement handles on a single \f(CW$dbh\fR
is \fB\s-1NOT\s0\fR supported. This is to avoid various deadlock problems that
can crop up in this situation, and because you will not get real transactional
integrity using multiple statement handles simultaneously as these in 
reality refer to different physical connections.
.SH "Working with IMAGE and TEXT columns"
.IX Header "Working with IMAGE and TEXT columns"
DBD::Sybase can store and retrieve \s-1IMAGE\s0 or \s-1TEXT\s0 data (aka \*(L"blob\*(R" data)
via standard \s-1SQL\s0 statements. The \fBLongReadLen\fR handle attribute controls
the maximum size of \s-1IMAGE\s0 or \s-1TEXT\s0 data being returned for each data 
element.
.PP
When using standard \s-1SQL\s0 the default for \s-1IMAGE\s0 data is to be converted
to a hex string, but you can use the \fIsyb_binary_images\fR handle attribute 
to change this behaviour. Alternatively you can use something like
.PP
.Vb 1
\&    $binary = pack("H*", $hex_string);
.Ve
.PP
to do the conversion.
.PP
\&\s-1IMAGE\s0 and \s-1TEXT\s0 datatypes can \fBnot\fR be passed as parameters using
?\-style placeholders, and placeholders can't refer to \s-1IMAGE\s0 or \s-1TEXT\s0 
columns (this is a limitation of the \s-1TDS\s0 protocol used by Sybase, not
a DBD::Sybase limitation.)
.PP
There is an alternative way to access and update \s-1IMAGE/TEXT\s0 data
using the natice OpenClient \s-1API\s0. This is done via \f(CW$h\fR\->\fIfunc()\fR calls,
and is, unfortunately, a little convoluted.
.SS "Handling \s-1IMAGE/TEXT\s0 data with \fIsyb_ct_get_data()\fP/\fIsyb_ct_send_data()\fP"
.IX Subsection "Handling IMAGE/TEXT data with syb_ct_get_data()/syb_ct_send_data()"
With \s-1DBI\s0 1.37 and later you can call all of these \fIct_xxx()\fR calls directly
as statement handle methods by prefixing them with syb_, so for example
.PP
.Vb 1
\&    $sth\->func($col, $dataref, $numbytes, \*(Aqct_fetch_data\*(Aq);
.Ve
.PP
becomes
.PP
.Vb 1
\&    $sth\->syb_ct_fetch_data($col, $dataref, $numbytes);
.Ve
.ie n .IP "$len = ct_fetch_data($col, $dataref, $numbytes)" 4
.el .IP "\f(CW$len\fR = ct_fetch_data($col, \f(CW$dataref\fR, \f(CW$numbytes\fR)" 4
.IX Item "$len = ct_fetch_data($col, $dataref, $numbytes)"
The \fIct_get_data()\fR call allows you to fetch \s-1IMAGE/TEXT\s0 data in
raw format, either in one piece or in chunks. To use this function
you must set the \fIsyb_no_bind_blob\fR statement handle to \fI\s-1TRUE\s0\fR.
.Sp
\&\fIct_get_data()\fR takes 3 parameters: The column number (starting at 1)
of the query, a scalar ref and a byte count. If the byte count is 0 
then we read as many bytes as possible.
.Sp
Note that the \s-1IMAGE/TEXT\s0 column \fBmust\fR be \fBlast\fR in the select list
for this to work.
.Sp
The call sequence is:
.Sp
.Vb 9
\&    $sth = $dbh\->prepare("select id, img from some_table where id = 1");
\&    $sth\->{syb_no_bind_blob} = 1;
\&    $sth\->execute;
\&    while($d = $sth\->fetchrow_arrayref) {
\&       # The data is in the second column
\&       $len = $sth\->syb_ct_get_data(2, \e$img, 0);
\&       # with DBI 1.33 and earlier, this would be
\&       # $len = $sth\->func(2, \e$img, 0, \*(Aqct_get_data\*(Aq);
\&    }
.Ve
.Sp
\&\fIct_get_data()\fR returns the number of bytes that were effectively fetched,
so that when fetching chunks you can do something like this:
.Sp
.Vb 5
\&   while(1) {
\&      $len = $sth\->syb_ct_get_data(2, $imgchunk, 1024);
\&      ... do something with the $imgchunk ...
\&      last if $len != 1024;
\&   }
.Ve
.Sp
To explain further: Sybase stores \s-1IMAGE/TEXT\s0 data separately from 
normal table data, in a chain of pagesize blocks (a Sybase database page
is defined at the server level, and can be 2k, 4k, 8k or 16k in size.) To update an \s-1IMAGE/TEXT\s0
column Sybase needs to find the head of this chain, which is known as
the \*(L"text pointer\*(R". As there is no \fIwhere\fR clause when the \fIct_send_data()\fR
\&\s-1API\s0 is used we need to retrieve the \fItext pointer\fR for the correct
data item first, which is done via the ct_data_info(\s-1CS_GET\s0) call. Subsequent
\&\fIct_send_data()\fR calls will then know which data item to update.
.ie n .IP "$status = ct_data_info($action, $column, $attr)" 4
.el .IP "\f(CW$status\fR = ct_data_info($action, \f(CW$column\fR, \f(CW$attr\fR)" 4
.IX Item "$status = ct_data_info($action, $column, $attr)"
\&\fIct_data_info()\fR is used to fetch or update the \s-1CS_IODESC\s0 structure
for the \s-1IMAGE/TEXT\s0 data item that you wish to update. \f(CW$action\fR should be
one of \*(L"\s-1CS_SET\s0\*(R" or \*(L"\s-1CS_GET\s0\*(R", \f(CW$column\fR is the column number of the
active select statement (ignored for a \s-1CS_SET\s0 operation) and \f(CW$attr\fR is
a hash ref used to set the values in the struct.
.Sp
\&\fIct_data_info()\fR must be first called with \s-1CS_GET\s0 to fetch the \s-1CS_IODESC\s0
structure for the \s-1IMAGE/TEXT\s0 data item that you wish to update. Then 
you must update the value of the \fItotal_txtlen\fR structure element
to the length (in bytes) of the \s-1IMAGE/TEXT\s0 data that you are going to
insert, and optionally set the \fIlog_on_update\fR to \fB\s-1TRUE\s0\fR to enable full 
logging of the operation.
.Sp
ct_data_info(\s-1CS_GET\s0) will \fIfail\fR if the \s-1IMAGE/TEXT\s0 data for which the 
\&\s-1CS_IODESC\s0 is being fetched is \s-1NULL\s0. If you have a \s-1NULL\s0 value that needs
updating you must first update it to some non-NULL value (for example
an empty string) using standard \s-1SQL\s0 before you can retrieve the \s-1CS_IODESC\s0
entry. This actually makes sense because as long as the data item is \s-1NULL\s0
there is \fBno\fR \fItext pointer\fR and no \s-1TEXT\s0 page chain for that item.
.Sp
See the \fIct_send_data()\fR entry below for an example.
.IP "\fIct_prepare_send()\fR" 4
.IX Item "ct_prepare_send()"
\&\fIct_prepare_send()\fR must be called to initialize a \s-1IMAGE/TEXT\s0 write operation.
See the \fIct_send_data()\fR entry below for an example.
.IP "\fIct_finish_send()\fR" 4
.IX Item "ct_finish_send()"
\&\fIct_finish_send()\fR is called to finish/commit an \s-1IMAGE/TEXT\s0 write operation.
See the \fIct_send_data()\fR entry below for an example.
.ie n .IP "ct_send_data($image, $bytes)" 4
.el .IP "ct_send_data($image, \f(CW$bytes\fR)" 4
.IX Item "ct_send_data($image, $bytes)"
Send \f(CW$bytes\fR bytes of \f(CW$image\fR to the database. The request must have been set
up via \fIct_prepare_send()\fR and \fIct_data_info()\fR for this to work. \fIct_send_data()\fR
returns \fB\s-1TRUE\s0\fR on success, and \fB\s-1FALSE\s0\fR on failure.
.Sp
In this example, we wish to update the data in the \fIimg\fR column
where the \fIid\fR column is 1. We assume that \s-1DBI\s0 is at version 1.37 or
later and use the direct method calls:
.Sp
.Vb 6
\&  # first we need to find the CS_IODESC data for the data
\&  $sth = $dbh\->prepare("select img from imgtable where id = 1");
\&  $sth\->execute;
\&  while($sth\->fetch) {    # don\*(Aqt care about the data!
\&      $sth\->syb_ct_data_info(\*(AqCS_GET\*(Aq, 1);
\&  }
\&
\&  # OK \- we have the CS_IODESC values, so do the update:
\&  $sth\->syb_ct_prepare_send();
\&  # Set the size of the new data item (that we are inserting), and make
\&  # the operation unlogged
\&  $sth\->syb_ct_data_info(\*(AqCS_SET\*(Aq, 1, {total_txtlen => length($image), log_on_update => 0});
\&  # now transfer the data (in a single chunk, this time)
\&  $sth\->syb_ct_send_data($image, length($image));
\&  # commit the operation
\&  $sth\->syb_ct_finish_send();
.Ve
.Sp
The \fIct_send_data()\fR call can also transfer the data in chunks, however you 
must know the total size of the image before you start the insert. For example:
.Sp
.Vb 8
\&  # update a database entry with a new version of a file:
\&  my $size = \-s $file;
\&  # first we need to find the CS_IODESC data for the data
\&  $sth = $dbh\->prepare("select img from imgtable where id = 1");
\&  $sth\->execute;
\&  while($sth\->fetch) {    # don\*(Aqt care about the data!
\&      $sth\->syb_ct_data_info(\*(AqCS_GET\*(Aq, 1);
\&  }
\&
\&  # OK \- we have the CS_IODESC values, so do the update:
\&  $sth\->syb_ct_prepare_send();
\&  # Set the size of the new data item (that we are inserting), and make
\&  # the operation unlogged
\&  $sth\->syb_ct_data_info(\*(AqCS_SET\*(Aq, 1, {total_txtlen => $size, log_on_update => 0});
\&
\&  # open the file, and store it in the db in 1024 byte chunks.
\&  open(IN, $file) || die "Can\*(Aqt open $file: $!";
\&  while($size) {
\&      $to_read = $size > 1024 ? 1024 : $size;
\&      $bytesread = read(IN, $buff, $to_read);
\&      $size \-= $bytesread;
\&
\&      $sth\->syb_ct_send_data($buff, $bytesread);
\&  }
\&  close(IN);
\&  # commit the operation
\&  $sth\->syb_ct_finish_send();
.Ve
.SH "AutoCommit, Transactions and Transact-SQL"
.IX Header "AutoCommit, Transactions and Transact-SQL"
When \f(CW$h\fR\->{AutoCommit} is \fIoff\fR all data modification \s-1SQL\s0 statements
that you issue (insert/update/delete) will only take effect if you
call \f(CW$dbh\fR\->commit.
.PP
DBD::Sybase implements this via two distinct methods, depending on 
the setting of the \f(CW$h\fR\->{syb_chained_txn} attribute and the version of the
server that is being accessed.
.PP
If \f(CW$h\fR\->{syb_chained_txn} is \fIoff\fR, then the DBD::Sybase driver
will send a \fB\s-1BEGIN\s0 \s-1TRAN\s0\fR before the first \f(CW$dbh\fR\->\fIprepare()\fR, and
after each call to \f(CW$dbh\fR\->\fIcommit()\fR or \f(CW$dbh\fR\->\fIrollback()\fR. This works
fine, but will cause any \s-1SQL\s0 that contains any \fI\s-1CREATE\s0 \s-1TABLE\s0\fR
(or other \s-1DDL\s0) statements to fail. These \fI\s-1CREATE\s0 \s-1TABLE\s0\fR statements can be
burried in a stored procedure somewhere (for example,
\&\f(CW\*(C`sp_helprotect\*(C'\fR creates two temp tables when it is run). 
You \fIcan\fR get around this limit by setting the \f(CW\*(C`ddl in tran\*(C'\fR option
(at the database level, via \f(CW\*(C`sp_dboption\*(C'\fR.) You should be aware that
this can have serious effects on performance as this causes locks to
be held on certain system tables for the duration of the transaction.
.PP
If \f(CW$h\fR\->{syb_chained_txn} is \fIon\fR, then DBD::Sybase sets the
\&\fI\s-1CHAINED\s0\fR option, which tells Sybase not to commit anything automatically.
Again, you will need to call \f(CW$dbh\fR\->\fIcommit()\fR to make any changes to the data
permanent.
.ie n .SH "Behavior of $dbh\->last_insert_id"
.el .SH "Behavior of \f(CW$dbh\fP\->last_insert_id"
.IX Header "Behavior of $dbh->last_insert_id"
This version of DBD::Sybase includes support for the \fIlast_insert_id()\fR call,
with the following caveats:
.PP
The \fIlast_insert_id()\fR call is simply a wrapper around a \*(L"select @@identity\*(R"
query. To be successful (i.e. to return the correct value) this must
be executed on the same connection as the \s-1INSERT\s0 that generated the
new \s-1IDENTITY\s0 value. Therefore the statement handle that was used to
perform the insert \fBmust\fR have been closed/freed before \fIlast_insert_id()\fR
can be called. Otherwise \fIlast_insert_id()\fR will be forced to open a different
connection to perform the query, and will return an invalid value (usually
in this case it will return 0).
.PP
\&\fIlast_insert_id()\fR ignores any parameters passed to it, and will \s-1NOT\s0 return
the last @@identity value generated in the case where placeholders were used,
or where the insert was encapsulated in a stored procedure.
.ie n .SH "Using ? Placeholders & bind parameters to $sth\->execute"
.el .SH "Using ? Placeholders & bind parameters to \f(CW$sth\fP\->execute"
.IX Header "Using ? Placeholders & bind parameters to $sth->execute"
DBD::Sybase supports the use of ? placeholders in \s-1SQL\s0 statements as long
as the underlying library and database engine supports it. It does 
this by using what Sybase calls \fIDynamic \s-1SQL\s0\fR. The ? placeholders allow
you to write something like:
.PP
.Vb 1
\&        $sth = $dbh\->prepare("select * from employee where empno = ?");
\&
\&        # Retrieve rows from employee where empno == 1024:
\&        $sth\->execute(1024);
\&        while($data = $sth\->fetch) {
\&            print "@$data\en";
\&        }
\&
\&       # Now get rows where empno = 2000:
\&        
\&        $sth\->execute(2000);
\&        while($data = $sth\->fetch) {
\&            print "@$data\en";
\&        }
.Ve
.PP
When you use ? placeholders Sybase goes and creates a temporary stored 
procedure that corresponds to your \s-1SQL\s0 statement. You then pass variables
to \f(CW$sth\fR\->execute or \f(CW$dbh\fR\->do, which get inserted in the query, and any rows
are returned.
.PP
DBD::Sybase uses the underlying Sybase \s-1API\s0 calls to handle ?\-style 
placeholders. For select/insert/update/delete statements DBD::Sybase
calls the \fIct_dynamic()\fR family of Client Library functions, which gives
DBD::Sybase data type information for each parameter to the query.
.PP
You can only use ?\-style placeholders for statements that return a single
result set, and the ? placeholders can only appear in a 
\&\fB\s-1WHERE\s0\fR clause, in the \fB\s-1SET\s0\fR clause of an \fB\s-1UPDATE\s0\fR statement, or in the
\&\fB\s-1VALUES\s0\fR list of an \fB\s-1INSERT\s0\fR statement.
.PP
The \s-1DBI\s0 docs mention the following regarding \s-1NULL\s0 values and placeholders:
.Sp
.Vb 6
\&       Binding an \`undef\*(Aq (NULL) to the placeholder will not
\&       select rows which have a NULL \`product_code\*(Aq! Refer to the
\&       SQL manual for your database engine or any SQL book for
\&       the reasons for this.  To explicitly select NULLs you have
\&       to say "\`WHERE product_code IS NULL\*(Aq" and to make that
\&       general you have to say:
\&
\&         ... WHERE (product_code = ? OR (? IS NULL AND product_code IS NULL))
\&
\&       and bind the same value to both placeholders.
.Ve
.PP
This will \fInot\fR work with a Sybase database server. If you attempt the 
above construct you will get the following error:
.Sp
.RS 4
The datatype of a parameter marker used in the dynamic prepare statement could not be resolved.
.RE
.PP
The specific problem here is that when using ? placeholders the \fIprepare()\fR
operation is sent to the database server for parameter resoltion. This extracts
the datatypes for each of the placeholders. Unfortunately the \f(CW\*(C`? is null\*(C'\fR
construct doesn't tie the ? placeholder with an existing table column, so
the database server can't find the data type. As this entire operation happens
inside the Sybase libraries there is no easy way for DBD::Sybase to work around
it.
.PP
Note that Sybase will normally handle the \f(CW\*(C`foo = NULL\*(C'\fR construct the same way
that other systems handle \f(CW\*(C`foo is NULL\*(C'\fR, so the convoluted construct that
is described above is not necessary to obtain the correct results when
querying a Sybase database.
.PP
The underlying \s-1API\s0 does not support ?\-style placeholders for stored 
procedures, but see the section on titled \fBStored Procedures and Placeholders\fR
elsewhere in this document.
.PP
?\-style placeholders can \fB\s-1NOT\s0\fR be used to pass \s-1TEXT\s0 or \s-1IMAGE\s0 data
items to the server. This is a limitation of the \s-1TDS\s0 protocol, not of
DBD::Sybase.
.PP
There is also a performance issue: OpenClient creates stored procedures in
tempdb for each \fIprepare()\fR call that includes ? placeholders. Creating
these objects requires updating system tables in the tempdb database, and
can therefore create a performance hotspot if a lot of \fIprepare()\fR statements
from multiple clients are executed simultaneously. This problem
has been corrected for Sybase 11.9.x and later servers, as they create
\&\*(L"lightweight\*(R" temporary stored procs which are held in the server memory
cache and don't affect the system tables at all.
.PP
In general however I find that if your application is going to run 
against Sybase it is better to write ad-hoc
stored procedures rather than use the ? placeholders in embedded \s-1SQL\s0.
.PP
Out of curiosity I did some simple timings to see what the overhead
of doing a prepare with ? placehoders is vs. a straight \s-1SQL\s0 prepare and
vs. a stored procedure prepare. Against an 11.0.3.3 server (linux) the
placeholder prepare is significantly slower, and you need to do ~30
\&\fIexecute()\fR calls on the prepared statement to make up for the overhead.
Against a 12.0 server (solaris) however the situation was very different,
with placeholder \fIprepare()\fR calls \fIslightly\fR faster than straight \s-1SQL\s0
\&\fIprepare()\fR. This is something that I \fIreally\fR don't understand, but
the numbers were pretty clear.
.PP
In all cases stored proc \fIprepare()\fR calls were \fIclearly\fR faster, and 
consistently so.
.PP
This test did not try to gauge concurrency issues, however.
.PP
It is not possible to retrieve the last \fI\s-1IDENTITY\s0\fR value
after an insert done with ?\-style placeholders. This is a Sybase
limitation/bug, not a DBD::Sybase problem. For example, assuming table
\&\fIfoo\fR has an identity column:
.PP
.Vb 4
\&  $dbh\->do("insert foo(col1, col2) values(?, ?)", undef, "string1", "string2");
\&  $sth = $dbh\->prepare(\*(Aqselect @@identity\*(Aq) 
\&    || die "Can\*(Aqt prepare the SQL statement: $DBI::errstr";
\&  $sth\->execute || die "Can\*(Aqt execute the SQL statement: $DBI::errstr";
\&
\&  #Get the data back.
\&  while (my $row = $sth\->fetchrow_arrayref()) {
\&    print "IDENTITY value = $row\->[0]\en";
\&  }
.Ve
.PP
will always return an identity value of 0, which is obviously incorrect.
This behaviour is due to the fact that the handling of ?\-style placeholders
is implemented using temporary stored procedures in Sybase, and the value
of \f(CW@@identity\fR is reset when the stored procedure has executed. Using an 
explicit stored procedure to do the insert and trying to retrieve
\&\f(CW@@identity\fR after it has executed results in the same behaviour.
.PP
Please see the discussion on Dynamic \s-1SQL\s0 in the 
OpenClient C Programmer's Guide for details. The guide is available on-line
at http://sybooks.sybase.com/
.SH "Calling Stored Procedures"
.IX Header "Calling Stored Procedures"
DBD::Sybase handles stored procedures in the same way as any other
Transact-SQL statement. The only real difference is that Sybase stored 
procedures always return an extra result set with the \fIreturn status\fR
from the proc which corresponds to the \fIreturn\fR statement in the stored
procedure code. This result set with a single row is always returned last
and has a result type of \s-1CS_STATUS_RESULT\s0 (4043).
.PP
By default this result set is returned like any other, but you can ask 
DBD::Sybase to process it under the covers via the \f(CW$h\fR\->{syb_do_proc_status}
attribute. If this attribute is set then DBD::Sybase will process the 
\&\s-1CS_STATUS_RESULT\s0 result set itself, place the return status value in 
\&\f(CW$sth\fR\->{syb_proc_status}, and possibly raise an error if the result set 
is different from 0. Note that a non\-0 return status will \fB\s-1NOT\s0\fR cause 
\&\f(CW$sth\fR\->execute to return a failure code if the proc has at least one other 
result set that returned rows (reason: the rows are returned and fetched 
before the return status is seen).
.SS "Stored Procedures and Placeholders"
.IX Subsection "Stored Procedures and Placeholders"
DBD::Sybase has the ability to use ?\-style
placeholders as parameters to stored proc calls. The requirements are
that the stored procedure call be initiated with an \*(L"exec\*(R" and that it be
the only statement in the batch that is being \fIprepared()\fR:
.PP
For example, this prepares a stored proc call with named parameters:
.PP
.Vb 2
\&    my $sth = $dbh\->prepare("exec my_proc \e@p1 = ?, \e@p2 = ?");
\&    $sth\->execute(\*(Aqone\*(Aq, \*(Aqtwo\*(Aq);
.Ve
.PP
You can also use positional parameters:
.PP
.Vb 2
\&    my $sth = $dbh\->prepare("exec my_proc ?, ?");
\&    $sth\->execute(\*(Aqone\*(Aq, \*(Aqtwo\*(Aq);
.Ve
.PP
You may \fInot\fR mix positional and named parameter in the same prepare.
.PP
You \fIcan't\fR mix placeholder parameters and hard coded parameters. For example
.PP
.Vb 1
\&    $sth = $dbh\->prepare("exec my_proc \e@p1 = 1, \e@p2 = ?");
.Ve
.PP
will \fInot\fR work \- because the \f(CW@p1\fR parameter isn't parsed correctly
and won't be sent to the server.
.PP
You can specify \fI\s-1OUTPUT\s0\fR parameters in the usual way, but you can \fB\s-1NOT\s0\fR
use \fIbind_param_inout()\fR to get the output result \- instead you have to call
\&\fIfetch()\fR and/or \f(CW$sth\fR\->func('syb_output_params'):
.PP
.Vb 3
\&    my $sth = $dbh\->prepare("exec my_proc \e@p1 = ?, \e@p2 = ?, \e@p3 = ? OUTPUT ");
\&    $sth\->execute(\*(Aqone\*(Aq, \*(Aqtwo\*(Aq, \*(Aqthree\*(Aq);
\&    my (@data) = $sth\->syb_output_params();
.Ve
.PP
DBD::Sybase does not attempt to figure out the correct parameter type
for each parameter (it would be possible to do this for most cases, but
there are enough exceptions that I preferred to avoid the issue for the 
time being). DBD::Sybase defaults all the parameters to \s-1SQL_CHAR\s0, and
you have to use \fIbind_param()\fR with an explicit type value to set this to
something different. The type is then remembered, so you only need to 
use the explicit call once for each parameter:
.PP
.Vb 7
\&    my $sth = $dbh\->prepare("exec my_proc \e@p1 = ?, \e@p2 = ?");
\&    $sth\->bind_param(1, \*(Aqone\*(Aq, SQL_CHAR);
\&    $sth\->bind_param(2, 2.34, SQL_FLOAT);
\&    $sth\->execute;
\&    ....
\&    $sth\->execute(\*(Aqtwo\*(Aq, 3.456);
\&    etc...
.Ve
.PP
Note that once a type has been defined for a parameter you can't change
it.
.PP
When binding \s-1SQL_NUMERIC\s0 or \s-1SQL_DECIMAL\s0 data you may get fatal conversion
errors if the scale or the precision exceeds the size of the target
parameter definition.
.PP
For example, consider the following stored proc definition:
.PP
.Vb 1
\&    declare proc my_proc @p1 numeric(5,2) as...
.Ve
.PP
and the following prepare/execute snippet:
.PP
.Vb 2
\&    my $sth = $dbh\->prepare("exec my_proc \e@p1 = ?");
\&    $sth\->bind_param(1, 3.456, SQL_NUMERIC);
.Ve
.PP
This generates the following error:
.PP
DBD::Sybase::st execute failed: Server message number=241 severity=16 state=2 line=0 procedure=dbitest text=Scale error during implicit conversion of \s-1NUMERIC\s0 value '3.456' to a \s-1NUMERIC\s0 field.
.PP
You can tell Sybase (and DBD::Sybase) to ignore these sorts of errors by
setting the \fIarithabort\fR option:
.PP
.Vb 1
\&    $dbh\->do("set arithabort off");
.Ve
.PP
See the \fIset\fR command in the Sybase Adaptive Server Enterprise Reference 
Manual for more information on the set command and on the arithabort option.
.SH "Other Private Methods"
.IX Header "Other Private Methods"
.SS "DBD::Sybase private Database Handle Methods"
.IX Subsection "DBD::Sybase private Database Handle Methods"
.ie n .IP "$bool = $dbh\->syb_isdead" 4
.el .IP "\f(CW$bool\fR = \f(CW$dbh\fR\->syb_isdead" 4
.IX Item "$bool = $dbh->syb_isdead"
Tests the connection to see if the connection has been marked \s-1DEAD\s0 by OpenClient.
The connection can get marked DEADA\*^\ if an error occurs on the connection, or the connection fails.
.SS "DBD::Sybase private Statement Handle Methods"
.IX Subsection "DBD::Sybase private Statement Handle Methods"
.ie n .IP "@data = $sth\->syb_describe([$assoc])" 4
.el .IP "\f(CW@data\fR = \f(CW$sth\fR\->syb_describe([$assoc])" 4
.IX Item "@data = $sth->syb_describe([$assoc])"
Retrieves the description of each of the output columns of the current 
result set. Each element of the returned array is a reference
to a hash that describes the column. The following fields are set:
\&\s-1NAME\s0, \s-1TYPE\s0, \s-1SYBTYPE\s0, \s-1MAXLENGTH\s0, \s-1SCALE\s0, \s-1PRECISION\s0, \s-1STATUS\s0.
.Sp
You could use it like this:
.Sp
.Vb 6
\&   my $sth = $dbh\->prepare("select name, uid from sysusers");
\&   $sth\->execute;
\&   my @description = $sth\->syb_describe;
\&   print "$description[0]\->{NAME}\en";         # prints name
\&   print "$description[0]\->{MAXLENGTH}\en";    # prints 30
\&   ....
\&
\&   while(my $row = $sth\->fetch) {
\&      ....
\&   }
.Ve
.Sp
The \s-1STATUS\s0 field is a string which can be tested for the following
values: \s-1CS_CANBENULL\s0, \s-1CS_HIDDEN\s0, \s-1CS_IDENTITY\s0, \s-1CS_KEY\s0, \s-1CS_VERSION_KEY\s0, 
\&\s-1CS_TIMESTAMP\s0 and \s-1CS_UPDATABLE\s0. See table 3\-46 of the Open Client Client 
Library Reference Manual for a description of each of these values.
.Sp
The \s-1TYPE\s0 field is the data type that Sybase::CTlib converts the
column to when retrieving the data, so a \s-1DATETIME\s0 column will be
returned as a \s-1CS_CHAR_TYPE\s0 column.
.Sp
The \s-1SYBTYPE\s0 field is the real Sybase data type for this column.
.Sp
\&\fINote that the symbolic values of the CS_xxx symbols isn't available
yet in DBD::Sybase.\fR
.SH "Experimental Bulk-Load Functionality"
.IX Header "Experimental Bulk-Load Functionality"
\&\fB\s-1NOTE\s0\fR: This feature requires that the \fIlibblk.a\fR library be available
at build time. This is not always the case if the Sybase \s-1SDK\s0 isn't
installed. You can test the \f(CW$dbh\fR\->{syb_has_blk} attribute to
see if the \s-1BLK\s0 api calls are available in your copy of DBD::Sybase.
.PP
Starting with release 1.04.2 DBD::Sybase has the ability to use Sybase's
\&\s-1BLK\s0 (bulk-loading) \s-1API\s0 to perform fast data loads. Basic usage is as follows:
.PP
.Vb 1
\&  my $dbh = DBI\->connect(\*(Aqdbi:Sybase:server=MY_SERVER;bulkLogin=1\*(Aq, $user, $pwd);
\&
\&  $dbh\->begin_work;  # optional.
\&  my $sth = $dbh\->prepare("insert the_table values(?, ?, ?, ?, ?)",
\&                          {syb_bcp_attribs => { identity_flag => 0,
\&                                               identity_column => 0 }}});
\&  while(<DATA>) {
\&    chomp;
\&    my @row = split(/\e|/, $_);   # assume a pipe\-delimited file...
\&    $sth\->execute(@row);
\&  }
\&  $dbh\->commit;
\&  print "Sent ", $sth\->rows, " to the server\en";
\&  $sth\->finish;
.Ve
.PP
First, you need to specify the new \fIbulkLogin\fR attribute in the connection
string, which turns on the \s-1CS_BULK_LOGIN\s0 property for the connection. Without
this property the \s-1BLK\s0 api will not be functional.
.PP
You call \f(CW$dbh\fR\->\fIprepare()\fR with a regular \s-1INSERT\s0 statement and the 
special \fIsyb_bcp_attribs\fR attribute to turn on \s-1BLK\s0 handling of the data.
The \fIidentity_flag\fR sub-attribute can be set to 1 if your source data
includes the values for the target table's \s-1IDENTITY\s0 column. If the
target table has an \s-1IDENTITY\s0 column but you want the insert operation to
generate a new value for each row then leave \fIidentity_flag\fR at 0, but set
\&\fIidentity_col\fR to the column number of the identity column (it's usually
the first column in the table, but not always.)
.PP
The number of placeholders in the \s-1INSERT\s0 statement \fImust\fR correspond to
the number of columns in the table, and the input data \fImust\fR be in the
same order as the table's physical column order. Any column list in the
\&\s-1INSERT\s0 statement (i.e. \fIinsert table(a, b, c,...) values(...)\fR is ignored.
.PP
The value of AutoCommit is ignored for \s-1BLK\s0 operations \- rows are only 
commited when you call \f(CW$dbh\fR\->commit.
.PP
You can call \f(CW$dbh\fR\->rollback to cancel any uncommited rows, but this \fIalso\fR
cancels the rest of the \s-1BLK\s0 operation: any attempt to load rows to the
server after a call to \f(CW$dbh\fR\->\fIrollback()\fR will fail.
.PP
If a row fails to load due to a \s-1CLIENT\s0 side error (such as a data conversion
error) then \f(CW$sth\fR\->\fIexecute()\fR will return a failure (i.e. false) and
\&\f(CW$sth\fR\->errstr will have the reason for the error.
.PP
If a row fails on the \s-1SERVER\s0 side (for example due to a duplicate row
error) then the entire batch (i.e. between two \f(CW$dbh\fR\->\fIcommit()\fR calls) 
will fail. This is normal behavior for BLK/bcp.
.PP
The Bulk-Load \s-1API\s0 is very sensitive to data conversion issues, as all the
conversions are handled on the client side, and the row is pre-formatted
before being sent to the server. By default any conversion that is flagged
by Sybase's \fIcs_convert()\fR call will result in a failed row. Some of these
conversion errors are patently fatal (e.g. converting 'Feb 30 2001' to a
\&\s-1DATETIME\s0 value...), while others are debatable (e.g. converting 123.456 to
a \s-1NUMERIC\s0(6,2) which results in a loss of precision). The default behavior
of failing any row that has a conversion error in it can be modified by 
using a special error handler. Returning 0 from this handler
tells DBD::Sybase to fail this row, and returning 1 means that we still
want to try to send the row to the server (obviously Sybase's internal
code can still fail the row at that point.)
You set the handler like this:
.PP
.Vb 1
\&    DBD::Sybase::syb_set_cslib_cb(\e&handler);
.Ve
.PP
and a sample handler:
.PP
.Vb 2
\&   sub cslib_handler {
\&     my ($layer, $origin, $severity, $errno, $errmsg, $osmsg, $blkmsg) = @_;
\&     
\&     print "Layer: $layer, Origin: $origin, Severity: $severity, Error: $errno\en";
\&     print $msg;
\&     print $osmsg if($osmsg);
\&     print $blkmsg if $blkmsg;
\&
\&     return 1 if($errno == 36)
\&
\&     return 0;
\&   }
.Ve
.PP
Please see the t/xblk.t test script for some examples.
.PP
Reminder \- this is an \fIexperimental\fR implementation. It may change
in the future, and it could be buggy.
.SH "Using DBD::Sybase with MS-SQL"
.IX Header "Using DBD::Sybase with MS-SQL"
MS-SQL started out as Sybase 4.2, and there are still a lot of similarities
between Sybase and MS-SQL which makes it possible to use DBD::Sybase
to query a MS-SQL dataserver using either the Sybase OpenClient libraries
or the FreeTDS libraries (see http://www.freetds.org).
.PP
However, using the Sybase libraries to query an MS-SQL server has
certain limitations. In particular ?\-style placeholders are not 
supported (although support when using the FreeTDS libraries is
possible in a future release of the libraries), and certain \fBsyb_\fR 
attributes may not be supported.
.PP
Sybase defaults the \s-1TEXTSIZE\s0 attribute (aka \fBLongReadLen\fR) to
32k, but MS-SQL 7 doesn't seem to do that correctly, resulting in
very large memory requests when querying tables with \s-1TEXT/IMAGE\s0 
data columns. The work-around is to set \s-1TEXTSIZE\s0 to some decent value
via \f(CW$dbh\fR\->{LongReadLen} (if that works \- I haven't had any confirmation
that it does) or via \f(CW$dbh\fR\->do(\*(L"set textsize <somesize>\*(R");
.SH "nsql"
.IX Header "nsql"
The \fInsql()\fR call is a direct port of the function of the same name that
exists in Sybase::DBlib. From 1.08 it has been extended to offer new 
functionality.
.PP
Usage:
.PP
.Vb 1
\&   @data = $dbh\->func($sql, $type, $callback, $options, \*(Aqnsql\*(Aq);
.Ve
.PP
If the \s-1DBI\s0 version is 1.37 or later, then you can also call it this way:
.PP
.Vb 1
\&   @data = $dbh\->syb_nsql($sql, $type, $callback, $options);
.Ve
.PP
This executes the query in \f(CW$sql\fR, and returns all the data in \f(CW@data\fR. The 
\&\f(CW$type\fR parameter can be used to specify that each returned row be in array
form (i.e. \f(CW$type\fR passed as '\s-1ARRAY\s0', which is the default) or in hash form 
($type passed as '\s-1HASH\s0') with column names as keys.
.PP
If \f(CW$callback\fR is specified it is taken as a reference to a perl sub, and
each row returned by the query is passed to this subroutine \fIinstead\fR of
being returned by the routine (to allow processing of large result sets, 
for example).
.PP
If \f(CW$options\fR is specified and is a \s-1HASH\s0 ref, the following keys affect the
value returned by \fInsql()\fR:
.IP "oktypes => [...]" 4
.IX Item "oktypes => [...]"
This generalises \fIsyb_nsql_nostatus\fR (see below) by ignoring any result sets 
which are of a type not listed.
.IP "bytype => 0|1|'merge'" 4
.IX Item "bytype => 0|1|'merge'"
If this option is set to a true value, each result set will be returned as the
value of a hash, the key of which is the result type of this result set as defined
by the CS_*_TYPE values described above. If the special value 'merge' is used,
result sets of the same type will be catenated (as \fInsql()\fR does by default) into
a single array of results and the result of the \fInsql()\fR call will be a single hash
keyed by result type. Usage is better written \f(CW%data\fR = \f(CW$dbh\fR\->syb_nsql(...) in this
case.
.IP "arglist => [...]" 4
.IX Item "arglist => [...]"
This option provides support for placeholders in the \s-1SQL\s0 query passed to \fInsql()\fR.
Each time the \s-1SQL\s0 statement is executed the array value of this option will be
passed as the parameter list to the \fIexecute()\fR method.
.PP
Note that if \f(CW$callback\fR is omitted, a hash reference in that parameter position
will be interpreted as an option hash if no hash reference is found in the 
\&\f(CW$options\fR parameter position.
.PP
\&\f(CW\*(C`nsql\*(C'\fR also checks three special attributes to enable deadlock retry logic
(\fINote\fR none of these attributes have any effect anywhere else at the moment):
.IP "syb_deadlock_retry \fIcount\fR" 4
.IX Item "syb_deadlock_retry count"
Set this to a non\-0 value to enable deadlock detection and retry logic within
\&\fInsql()\fR. If a deadlock error is detected (error code 1205) then the entire
batch is re-submitted up to \fIsyb_deadlock_retry\fR times. Default is 0 (off).
.IP "syb_deadlock_sleep \fIseconds\fR" 4
.IX Item "syb_deadlock_sleep seconds"
Number of seconds to sleep between deadlock retries. Default is 60.
.IP "syb_deadlock_verbose (bool)" 4
.IX Item "syb_deadlock_verbose (bool)"
Enable verbose logging of deadlock retry logic. Default is off.
.IP "syb_nsql_nostatus (bool)" 4
.IX Item "syb_nsql_nostatus (bool)"
If true then stored procedure return status values (i.e. results of type
\&\s-1CS_STATUS_RESULT\s0) are ignored.
.PP
Deadlock detection will be added to the \f(CW$dbh\fR\->\fIdo()\fR method in a future
version of DBD::Sybase.
.SH "Multi-Threading"
.IX Header "Multi-Threading"
DBD::Sybase is thread-safe (i.e. can be used in a multi-threaded
perl application where more than one thread accesses the database
server) with the following restrictions:
.IP "\(bu" 4
perl version >= 5.8
.Sp
DBD::Sybase requires the use of \fIithreads\fR, available in the perl 5.8.0
release. It will not work with the older 5.005 threading model.
.IP "\(bu" 4
Sybase thread-safe libraries
.Sp
Sybase's Client Library comes in two flavors. DBD::Sybase must find the
thread-safe version of the libraries (ending in _r on Unix/linux). This 
means Open Client 11.1.1 or later. In particular this means that you can't
use the 10.0.4 libraries from the free 11.0.3.3 release on linux if you
want to use multi-threading.
.Sp
Note: when using perl >= 5.8 with the thread-safe libraries (libct_r.so, etc)
then signal handling is broken and any signal delivered to the perl process
will result in a segmentation fault. It is recommended in that case to 
link with the non-threadsafe libraries.
.IP "\(bu" 4
use DBD::Sybase
.Sp
You \fImust\fR include the \f(CW\*(C`use DBD::Sybase;\*(C'\fR line in your program. This
is needed because DBD::Sybase needs to do some setup \fIbefore\fR the first
thread is started.
.PP
You can check to see if your version of DBD::Sybase is thread-safe at
run-time by calling \fIDBD::Sybase::thread_enabled()\fR. This will return
\&\fItrue\fR if multi-threading is available.
.PP
See t/thread.t for a simple example.
.SH "BUGS"
.IX Header "BUGS"
You can run out of space in the tempdb database if you use a lot of
calls with bind variables (ie ?\-style placeholders) without closing the
connection and Sybase 11.5.x or older. This is because
Sybase creates stored procedures for each \fIprepare()\fR call. 
In 11.9.x and later Sybase will create \*(L"light-weight\*(R" stored procedures
which don't use up any space in the tempdb database.
.PP
The \fIprimary_key_info()\fR method will only return data for tables 
where a declarative \*(L"primary key\*(R" constraint was included when the table
was created.
.PP
I have a simple bug tracking database at http://www.peppler.org/bugdb/ .
You can use it to view known problems, or to report new ones.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0
.PP
Sybase OpenClient C manuals.
.PP
Sybase Transact \s-1SQL\s0 manuals.
.SH "AUTHOR"
.IX Header "AUTHOR"
DBD::Sybase by Michael Peppler
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The DBD::Sybase module is Copyright (c) 1996\-2007 Michael Peppler.
The DBD::Sybase module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Tim Bunce for \s-1DBI\s0, obviously!
.PP
See also \*(L"\s-1ACKNOWLEDGEMENTS\s0\*(R" in \s-1DBI\s0.
