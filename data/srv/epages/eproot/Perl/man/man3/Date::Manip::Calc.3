.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Calc 3"
.TH Date::Manip::Calc 3 "2011-06-03" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Calc \- describes date calculations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Two objects (both of which are either Date::Manip::Date or
Date::Manip::Delta objects) may be used to creates a third object
based on those two.
.PP
.Vb 4
\&   $delta  = $date\->calc($date2 [,$subtract] [,$mode]);
\&   $date2  = $date\->calc($delta [,$subtract]);
\&   $date2  = $delta\->calc($date1 [,$subtract]);
\&   $delta3 = $delta1\->calc($delta2 [,$subtract]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes date calculations. Date calculations involve
two types of Date::Manip objects: dates and deltas. These are described
in the Date::Manip::Date and Date::Manip::Delta manuals respectively.
.PP
Two objects (two dates, two deltas, or one of each) are used.  In all
cases, if a second object is not passed in, undef is returned.
.PP
There are 3 types of date calculations:
.IP "\fBDate-Date calculations\fR" 4
.IX Item "Date-Date calculations"
.Vb 1
\&   $delta  = $date\->calc($date2 [,$subtract] [,$mode]);
.Ve
.Sp
Two dates can be worked with and a delta will be produced which is
the amount of time between the two dates.
.Sp
\&\f(CW$date1\fR and \f(CW$date2\fR are Date::Manip::Date objects with valid dates.
The Date::Manip::Delta object returned is the amount of time between
them. If \f(CW$subtract\fR is not passed in (or is 0), the delta produced
is:
.Sp
.Vb 1
\&   DELTA = DATE2 \- DATE1
.Ve
.Sp
If \f(CW$subtract\fR is non-zero, the delta produced is:
.Sp
.Vb 1
\&   DELTA = DATE1 \- DATE2
.Ve
.Sp
The \f(CW$subtract\fR argument has special importance when doing approximate
calculations, and this is described below.
.Sp
If either date is invalid, a delta object will be returned which
has an error associated with it.
.Sp
The \f(CW$mode\fR argument describes the type of calculation and is described
below.
.IP "\fBDate-Delta calculations\fR" 4
.IX Item "Date-Delta calculations"
Date-delta calculations can be performed using either a Date::Manip::Date
or Date::Manip::Delta object as the primary object:
.Sp
.Vb 2
\&   $date2  = $date1\->calc($delta [,$subtract]);
\&   $date2  = $delta\->calc($date1 [,$subtract]);
.Ve
.Sp
A date and delta can be worked with to yield a date that is the
given amount of time before or after it.
.Sp
\&\f(CW$date1\fR and \f(CW$delta\fR are valid Date::Manip::Date and Date::Manip::Delta
objects respectively. A new Date::Manip::Date object is produced.
.Sp
Both of the calls above perform the same function and produce exactly the
same results.
.Sp
If \f(CW$subtract\fR is not passed in, or is 0, the resulting date is
formed as:
.Sp
.Vb 1
\&   DATE2 = DATE1 + DELTA
.Ve
.Sp
If \f(CW$subtract\fR is non-zero, the resulting date is:
.Sp
.Vb 1
\&   DATE2 = DATE1 \- DELTA
.Ve
.Sp
The \f(CW$subtract\fR argument has special importance when doing approximate
calculations, and this is described below.
.IP "\fBDelta-Delta calculations\fR" 4
.IX Item "Delta-Delta calculations"
Delta-delta calculations can be performed to add two amounts of time
together, or subtract them.
.Sp
.Vb 1
\&   $delta3 = $delta1\->calc($delta2 [,$subtract]);
.Ve
.Sp
If \f(CW$subtract\fR is not passed in, or is 0, the resulting delta formed
is:
.Sp
.Vb 1
\&   DELTA3 = DELTA1 + DELTA2
.Ve
.Sp
If \f(CW$subtract\fR is non-zero, then the resulting delta is:
.Sp
.Vb 1
\&   DELTA3 = DELTA1 \- DELTA2
.Ve
.Sp
\&\f(CW$delta1\fR and \f(CW$delta2\fR are valid Date::Manip::Delta objects, and a new
Date::Manip::Delta object is produced.
.PP
Date calculations handle the time zones properly. When calculating
the difference between two dates in different time zones, they will
first be converted to a common time zone. Also, when adding a delta
to a date, the resulting date will be in the same time zone as the
original date.
.PP
If either of the objects are invalid, the error condition is set in
the object for which the method is called, and undef is returned
instead of a new object.
.PP
For example, if the following is called:
.PP
.Vb 1
\&   $date2  = $date1\->calc($delta);
.Ve
.PP
and \f(CW$delta\fR does not include a valid delta, then \f(CW$date1\fR will have an
error condition set and \f(CW$date2\fR will be undef.
.SH "MODE"
.IX Header "MODE"
Date::Manip calculations can be divide into two different types:
business and non-business. Within those types are two sub categories:
exact and approximate. These are described here.
.IP "\fBBusiness and non-business calculations\fR" 4
.IX Item "Business and non-business calculations"
A business mode calculation is one where the length of the day is
determined by the length of the work day, and only business days
(i.e. days in which business is conducted) count. Holidays and
weekends are omitted. This is described in more detail below.
.Sp
A non-business mode calculation is the normal type of calculation
where no days are ignored, and all days are full length.
.IP "\fBExact and approximate calculations\fR" 4
.IX Item "Exact and approximate calculations"
An exact calculation is one in which all deltas involved (either the
delta produced by adding two dates or deltas together, or a delta that
is added to a date to produce a second date) is an exact delta. An
exact delta is described in the Date::Manip::Delta manual, but the
short explanation is that an exact delta tells exactly how much time
passed between two dates. Since there is no definite relationship
between months and days, an exact delta will only include values for
the day/hour/minute/second fields (the week field is also allowed in
non-business mode calculations). The inexact fields (year, month, and
week in the case of business mode) will be 0.
.Sp
An approximate delta is one which includes years and months (i.e.
fields for which an exact length are not known in general) but
which are used for human convenience.
.PP
In date-delta and delta-delta calculations, the mode of the
calculation will be determined automatically. In the case of date-date
calculations, the mode is supplied as an argument.
.IP "\fBMode in date-date calculations\fR" 4
.IX Item "Mode in date-date calculations"
When doing a date-date calculation, the following call is used:
.Sp
.Vb 1
\&   $delta = $date1\->calc($date2 [,$subtract] [,$mode]);
.Ve
.Sp
\&\f(CW$mode\fR defaults to \*(L"exact\*(R". The delta produced will be be either
a business or non-business delta, exact or approximate, as specified
by \f(CW$mode\fR.
.Sp
Currently, the four possible values that \f(CW$mode\fR can have are:
.Sp
.Vb 4
\&   exact    : an exact, non\-business mode calculation
\&   approx   : an approximate, non\-business mode calculation
\&   business : an exact, business mode calculation
\&   bapprox  : an approximate, business mode calculation
.Ve
.Sp
\&\s-1NOTE:\s0 When doing a \*(L"business\*(R" or \*(L"bapprox\*(R" calculation, both dates
must be in the same time zone or an error is produced.
.IP "\fBMode in date-delta calculations\fR" 4
.IX Item "Mode in date-delta calculations"
When doing calculations of a date and a delta:
.Sp
.Vb 2
\&   $date2 = $date1\->calc($delta [,$subtract]);
\&   $date2 = $delta\->calc($date1 [,$subtract]);
.Ve
.Sp
the mode is not passed in. It is determined exclusively by the
delta. If \f(CW$delta\fR is a business delta, A business mode calculation is
done. If \f(CW$delta\fR is a non-business delta, a non-business mode
calculation will be done. If \f(CW$delta\fR has a non-zero value for either
the year or month field, an approximate calculation will be done.
Otherwise, an exact calculation will be done.
.IP "\fBMode in delta-delta calculations\fR" 4
.IX Item "Mode in delta-delta calculations"
When doing calculations with two deltas:
.Sp
.Vb 1
\&   $delta3 = $delta1\->calc($delta2 [,$subtract]);
.Ve
.Sp
the mode is not passed in. It is determined by the two deltas.
.Sp
If both deltas are business mode, or both are non-business mode, a
new delta will be produced of the same type.
.Sp
It one of the deltas is a business mode and the other is not, the
resulting delta will have an error condition since there is no
direct correlation between the two types of deltas. Even though
it would be easy to add the two together, it would be impossible
to come up with a result that is meaningful.
.Sp
If both deltas are exact, the resulting delta is also exact. If
either or both of the deltas is approximate, the resulting delta
is also approximate. It is \s-1NOT\s0 treated as an error if one of the
deltas is exact and one is approximate.
.SH "BUSINESS MODE CONSIDERATIONS"
.IX Header "BUSINESS MODE CONSIDERATIONS"
In order to correctly do business mode calculations, a config file
should exist which contains the section defining holidays (otherwise,
weekends will be ignored, but all other days will be counted as
business days). This is documented below, and in the
Date::Manip::Config section of the documentation.  Some config
variables (namely WorkWeekBeg, WorkWeekEnd, WorkDayBeg, WorkDayEnd,
and WorkDay24Hr) defined the length of the work week and work day.
.PP
If the workday is defined as 08:00 to 18:00, a work week consisting of
Mon-Sat, and the standard (American) holidays, then from Tuesday at
12:00 to the following Monday at 14:00 is 5 days and 2 hours.  If the
\&\*(L"end\*(R" of the day is reached in a calculation, it automatically
switches to the next day.  So, Tuesday at 12:00 plus 6 hours is
Wednesday at 08:00 (provided Wed is not a holiday).  Also, a date that
is not during a workday automatically becomes the start of the next
workday.  So, Sunday 12:00 and Monday at 03:00 both automatically
becomes Monday at 08:00 (provided Monday is not a holiday).
.PP
Note that a business week is treated the same as an exact week
(i.e. from Tuesday to Tuesday, regardless of holidays).  Because this
means that the relationship between days and weeks is \s-1NOT\s0 unambiguous,
when an exact delta is produced from two dates, it will be in terms of
d/h/mn/s (i.e. no week field).
.PP
Also note that daylight saving time effects are ignored in business
mode calculations.
.PP
Anyone using business mode is going to notice a few quirks about it
which should be explained.  When I designed business mode, I had in
mind what a business which promises 1 business day turnaround really
means.
.PP
If you do a business calculation (with the workday set to 9:00\-17:00),
you will get the following:
.PP
.Vb 2
\&   Saturday at noon + 1 business day = Tuesday at 9:00
\&   Saturday at noon \- 1 business day = Friday at 9:00
.Ve
.PP
What does this mean?
.PP
As an example, say I use a business that works 9\-5 and they have a
drop box so I can drop things off over the weekend and they promise 1
business day turnaround.  If I drop something off Friday night,
Saturday, or Sunday, it doesn't matter.  They're going to get started
on it Monday morning.  It'll be 1 business day to finish the job, so
the earliest I can expect it to be done is around 17:00 Monday or 9:00
Tuesday morning.  Unfortunately, there is some ambiguity as to what
day 17:00 really falls on, similar to the ambiguity that occurs when
you ask what day midnight falls on.  Although it's not the only
answer, Date::Manip treats midnight as the beginning of a day rather
than the end of one.  In the same way, 17:00 is equivalent to 9:00 the
next day and any time the date calculations encounter 17:00, it
automatically switch to 9:00 the next day.  Although this introduces
some quirks, I think this is justified.  I also think that it is the
way most people think of it. If I drop something off first thing
Monday morning, I would expect to pick it up first thing Tuesday if
there is 1 business day turnaround.
.PP
Equivalently, if I want a job to be finished on Saturday (despite the fact
that I cannot pick it up since the business is closed), I have to drop it
off no later than Friday at 9:00.  That gives them a full business day to
finish it off.  Of course, I could just as easily drop it off at 17:00
Thursday, or any time between then and 9:00 Friday.  Again, it's a matter
of treating 17:00 as ambiguous.
.PP
So Saturday + 1 business day = Tuesday at 9:00 (which means anything
from Monday 17:00 to Tuesday 9:00), but Monday at 9:01 + 1 business
day = Tuesday at 9:01 which is unambiguous.
.SH "EXACT AND APPROXIMATE CALCULATIONS"
.IX Header "EXACT AND APPROXIMATE CALCULATIONS"
In many cases, it is somewhat ambiguous what amount of time a delta
actually refers to.  Although it is \s-1ALWAYS\s0 known how many months in a
year, hours in a day, etc., it is \s-1NOT\s0 known (in the general case) how
many days are in a month.  As a result, the part of the delta
containing month/year and the part with sec/min/hr/day must be treated
separately.  For example, \*(L"Mar 31, 12:00:00\*(R" plus a delta of \*(L"1 month
2 days\*(R" would yield \*(L"May 2 12:00:00\*(R".  The year/month is first handled
while keeping the same date.  Mar 31 plus one month is Apr 31 (but
since Apr only has 30 days, it becomes Apr 30).  Apr 30 + 2 days is
May 2.
.PP
Likewise, when calculating the delta between two dates, the delta may
take two different forms. The exact form is to use only the days,
hours, minutes, and seconds (weeks are also included, except in
business calculations) and expressing the delta exactly. In approximate
mode, the other fields (years and months; weeks in the case of business
calculations) are used to produce a more human format.
.PP
For example, the two dates \*(L"Mar 12 1995\*(R" and \*(L"Apr 13 1995\*(R" would have
an exact delta of \*(L"31 days\*(R" but in the approximate mode, it would be
returned as \*(L"1 month 1 day\*(R".  Also, \*(L"Mar 31\*(R" and \*(L"Apr 30\*(R" would have
deltas of \*(L"30 days\*(R" or \*(L"1 month\*(R" (since Apr 31 doesn't exist, it drops
down to Apr 30).  Approximate mode is a more human way of looking at
things (you'd say 1 month and 2 days more often then 33 days), but it
is less meaningful in terms of absolute time.
.PP
One other difference is that an exact delta is exactly the amount of
time that has passed, including all effects of daylight saving
time. Approximate deltas ignore the affects of daylight saving time.
So, for example, the approximate time between Jan 1 00:00:00 and Jun 1
00:00:00 in America/New_York is 0:5:0:0:0:0:0, but is exactly
0:0:21:4:23:0:0 .
.SH "SUBTRACTION"
.IX Header "SUBTRACTION"
In exact calculations, and in delta-delta calculations, the the
\&\f(CW$subtract\fR argument is easy to understand.  When working with an
approximate delta however (either when adding an approximate delta to
a date, or when taking two dates to get an approximate delta), there
is a degree of uncertainty in how the calculation is done, and the
\&\f(CW$subtract\fR argument is used to specify exactly how the approximate
delta is to be use. An example illustrates this quite well.
.PP
If you take the date Jan 4, 2000 and subtract a delta of \*(L"1 month 1
week\*(R" from it, you end up with Nov 27, 1999 (Jan 4, 2000 minus 1 month
is Dec 4, 1999; minus 1 week is Nov 27, 1999). But Nov 27, 1999 plus a
delta of \*(L"1 month 1 week\*(R" is Jan 3, 2000 (Nov 27, 1999 plus 1 month is
Dec 27, 1999; plus 1 week is Jan 3, 2000).
.PP
In other words the approximate delta (but \s-1NOT\s0 the exact delta) is different
depending on whether you move from earlier date to the later date, or vice
versa. And depending on what you are calculating, both are useful.
.PP
In order to resolve this, the \f(CW$subtract\fR argument can take on the values
0, 1, or 2, and have the following meaning.
.ie n .IP "\fB\fB$subtract\fB in approximate date-date calculations\fR" 4
.el .IP "\fB\f(CB$subtract\fB in approximate date-date calculations\fR" 4
.IX Item "$subtract in approximate date-date calculations"
In the call:
.Sp
.Vb 1
\&   $delta = $date1\->calc($date2,$subtract,"approx");
.Ve
.Sp
if \f(CW$subtract\fR is 0, the resulting delta can be added to \f(CW$date1\fR to get
\&\f(CW$date2\fR. Obviously \f(CW$delta\fR may still be negative (if \f(CW$date2\fR comes before
\&\f(CW$date1\fR).
.Sp
If \f(CW$subtract\fR is 1, the resulting delta can be subtracted from \f(CW$date1\fR
to get \f(CW$date2\fR (the deltas from these two are identical except for having
an opposite sign).
.Sp
If \f(CW$subtract\fR is 2, the resulting delta can be added to \f(CW$date2\fR to get
\&\f(CW$date1\fR. In other words, the following are identical:
.Sp
.Vb 2
\&   $delta = $date1\->calc($date2,2,"approx");
\&   $delta = $date2\->calc($date1,"approx");
.Ve
.ie n .IP "\fB\fB$subtract\fB in approximate date-delta calculations\fR" 4
.el .IP "\fB\f(CB$subtract\fB in approximate date-delta calculations\fR" 4
.IX Item "$subtract in approximate date-delta calculations"
In the call:
.Sp
.Vb 1
\&   $date2 = $date1\->calc($delta,$subtract);
.Ve
.Sp
If \f(CW$subtract\fR is 0, the resulting date is determined by adding \f(CW$delta\fR to \f(CW$date1\fR.
.Sp
If \f(CW$subtract\fR is 1, the resulting date is determined by subtracting \f(CW$delta\fR from
\&\f(CW$date1\fR.
.Sp
If \f(CW$subtract\fR is 2, the resulting date is the date which \f(CW$delta\fR can be added to
to get \f(CW$date1\fR. This is \s-1NOT\s0 available with business calculations (for them,
this is treated the same as \f(CW$subtract\fR=1).
.Sp
With business calculations, the \f(CW$subtract\fR=2 argument is ambiguous.
For example, the date 1997\-11\-26 17:00:00 plus a delta of \*(L"business 1
month 1 day\*(R" gives a date of 1998\-01\-05 08:00, and the date 1997\-11\-28
17:00:00 plus the same delta also gives the value of 1998\-01\-05 08:00.
Since there is no single date which the delta could be added to to
get \f(CW$date1\fR, this option cannot be implemented.
.SH "APPROXIMATE DATE/DATE CALCULATION"
.IX Header "APPROXIMATE DATE/DATE CALCULATION"
There are two different ways to look at the approximate delta between
two dates.
.PP
In Date::Manip 5.xx, the approximate delta between the two dates:
.PP
.Vb 2
\&   Jan 10 1996 noon
\&   Jan  7 1998 noon
.Ve
.PP
was +1:11:4:0:0:0:0 (or 1 year, 11 months, 4 weeks).  In calculating
this, the first date was adjusted as far as it could go towards the
second date without going past it with each unit starting with the
years and ending with the seconds.
.PP
This gave a strictly positive or negative delta, but it isn't
actually how most people would think of the delta.
.PP
As of Date::Manip 6.0, the delta is +2:0:\-0:3:0:0:0 (or 2 years minus
3 days). Although this leads to mixed-sign deltas, it is actually how
more people would think about the delta. It has the additional
advantage of being easier to calculate.
.PP
For non-business mode calculations, the year/month part of the
approximate delta will move a date from the year/month of the first
date into the year/month of the second date. The remainder of the
delta will adjust the days/hours/minutes/seconds as appropriate.
.PP
For approximate business mode calculations, the year and date will be
done approximately, and the remainder will be done exactly. There will
be no value for the weeks field in the delta produced.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer to the Date::Manip::Problems documentation for
information on submitting bug reports or questions to the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
