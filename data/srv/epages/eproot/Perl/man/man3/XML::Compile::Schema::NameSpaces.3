.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::Schema::NameSpaces 3"
.TH XML::Compile::Schema::NameSpaces 3 "2016-09-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::Schema::NameSpaces \- Connect name\-spaces from schemas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& # Used internally by XML::Compile::Schema
\& my $nss = XML::Compile::Schema::NameSpaces\->new;
\& $nss\->add($schema);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module keeps overview on a set of namespaces, collected from various
schema files.  Per \s-1XML\s0 namespace, it will collect a list of fragments
which contain definitions for the namespace, each fragment comes from a
different source.  These fragments are searched in reverse order when
an element or type is looked up (the last definitions overrule the
older definitions).
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBnew\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR(%options)" 4
.IX Item "$obj->new(%options)"
.SS "Accessors"
.IX Subsection "Accessors"
.PD 0
.ie n .IP "$obj\->\fBadd\fR( $schema, [$schemas] )" 4
.el .IP "\f(CW$obj\fR\->\fBadd\fR( \f(CW$schema\fR, [$schemas] )" 4
.IX Item "$obj->add( $schema, [$schemas] )"
.PD
Add XML::Compile::Schema::Instance objects to the internal
knowledge of this object.
.ie n .IP "$obj\->\fBallSchemas\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBallSchemas\fR()" 4
.IX Item "$obj->allSchemas()"
Returns a list of all known schema instances.
.ie n .IP "$obj\->\fBdoesExtend\fR($exttype, $basetype)" 4
.el .IP "\f(CW$obj\fR\->\fBdoesExtend\fR($exttype, \f(CW$basetype\fR)" 4
.IX Item "$obj->doesExtend($exttype, $basetype)"
Returns true when \f(CW$exttype\fR extends \f(CW$basetype\fR.
.ie n .IP "$obj\->\fBfind\fR($kind, $address|<$uri,$name>, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBfind\fR($kind, \f(CW$address\fR|<$uri,$name>, \f(CW%options\fR)" 4
.IX Item "$obj->find($kind, $address|<$uri,$name>, %options)"
Lookup the definition for the specified \f(CW$kind\fR of definition: the name
of a global element, global attribute, attributeGroup or model group.
The \f(CW$address\fR is constructed as \f(CW\*(C` {uri}name \*(C'\fR or as separate \f(CW$uri\fR and \f(CW$name\fR.
.Sp
.Vb 2
\& \-Option      \-\-Default
\&  include_used  <true>
.Ve
.RS 4
.IP "include_used => \s-1BOOLEAN\s0" 2
.IX Item "include_used => BOOLEAN"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBfindID\fR( $address|<$uri,$id> )" 4
.el .IP "\f(CW$obj\fR\->\fBfindID\fR( \f(CW$address\fR|<$uri,$id> )" 4
.IX Item "$obj->findID( $address|<$uri,$id> )"
.PD
Lookup the definition for the specified id, which is constructed as
\&\f(CW\*(C` uri#id \*(C'\fR or as separate \f(CW$uri\fR and \f(CW$id\fR.
.ie n .IP "$obj\->\fBfindSgMembers\fR($class, $type)" 4
.el .IP "\f(CW$obj\fR\->\fBfindSgMembers\fR($class, \f(CW$type\fR)" 4
.IX Item "$obj->findSgMembers($class, $type)"
Lookup the substitutionGroup alternatives for a specific element, which
is an \f(CW$type\fR (element full name) of form \f(CW\*(C` {uri}name \*(C'\fR or as separate
\&\s-1URI\s0 and \s-1NAME\s0.  Returned is an \s-1ARRAY\s0 of HASHes, each describing one type
(as returned by \fIfind()\fR)
.ie n .IP "$obj\->\fBfindTypeExtensions\fR($type)" 4
.el .IP "\f(CW$obj\fR\->\fBfindTypeExtensions\fR($type)" 4
.IX Item "$obj->findTypeExtensions($type)"
This method can be quite expensive, with large and nested schemas.
.ie n .IP "$obj\->\fBimportIndex\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBimportIndex\fR(%options)" 4
.IX Item "$obj->importIndex(%options)"
[1.41] Returns a \s-1HASH\s0 with namespaces which are declared in all currently
known schema's, pointing to ARRAYs of the locations where the import should
come from.
.Sp
In reality, the locations mentioned are often wrong. But when you think
you want to load all schema's dynamically at start-up (no, you do not
want it but it is a \s-1SOAP\s0 paradigma) then you get that info easily with
this method.
.ie n .IP "$obj\->\fBlist\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlist\fR()" 4
.IX Item "$obj->list()"
Returns the list of name-space URIs defined.
.ie n .IP "$obj\->\fBnamespace\fR($uri)" 4
.el .IP "\f(CW$obj\fR\->\fBnamespace\fR($uri)" 4
.IX Item "$obj->namespace($uri)"
Returns a list of XML::Compile::Schema::Instance objects which have
the \f(CW$uri\fR as target namespace.
.ie n .IP "$obj\->\fBprintIndex\fR( [$fh], %options )" 4
.el .IP "\f(CW$obj\fR\->\fBprintIndex\fR( [$fh], \f(CW%options\fR )" 4
.IX Item "$obj->printIndex( [$fh], %options )"
Show all definitions from all namespaces, for debugging purposes, by
default the selected.  Additional \f(CW%options\fR are passed to 
\&\fIXML::Compile::Schema::Instance::printIndex()\fR.
.Sp
.Vb 3
\& \-Option      \-\-Default
\&  include_used  <true>
\&  namespace     <ALL>
.Ve
.RS 4
.IP "include_used => \s-1BOOLEAN\s0" 2
.IX Item "include_used => BOOLEAN"
Show also the index from all the schema objects which are defined
to be usable as well; which were included via \fIuse()\fR.
.IP "namespace => URI|ARRAY\-of\-URI" 2
.IX Item "namespace => URI|ARRAY-of-URI"
Show only information about the indicate namespaces.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\& my $nss = $schema\->namespaces;
\& $nss\->printIndex(\e*MYFILE);
\& $nss\->printIndex(namespace => "my namespace");
\&
\& # types defined in the wsdl schema
\& use XML::Compile::SOAP::Util qw/WSDL11/;
\& $nss\->printIndex(\e*STDERR, namespace => WSDL11);
.Ve
.RE
.ie n .IP "$obj\->\fBschemas\fR($uri)" 4
.el .IP "\f(CW$obj\fR\->\fBschemas\fR($uri)" 4
.IX Item "$obj->schemas($uri)"
We need the name-space; when it is lacking then import must help, but that
must be called explicitly.
.ie n .IP "$obj\->\fBuse\fR($object)" 4
.el .IP "\f(CW$obj\fR\->\fBuse\fR($object)" 4
.IX Item "$obj->use($object)"
Use any other XML::Compile::Schema extension as fallback, if the
\&\fIfind()\fR does not succeed for the current object.  Searches for
definitions do not recurse into the used object.
.Sp
Returns the list of all used \s-1OBJECTS\s0.
This method implements \fIXML::Compile::Schema::useSchema()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile distribution version 1.54,
built on September 19, 2016. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2006\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
