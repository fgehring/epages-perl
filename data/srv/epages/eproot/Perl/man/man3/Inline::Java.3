.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Java 3"
.TH Java 3 "2009-05-01" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Inline::Java \- Write Perl classes in Java.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&   use Inline Java => <<\*(AqEND_OF_JAVA_CODE\*(Aq ;
\&      class Pod_alu {
\&         public Pod_alu(){
\&         }
\&
\&         public int add(int i, int j){
\&            return i + j ;
\&         }
\&
\&         public int subtract(int i, int j){
\&            return i \- j ;
\&         }
\&      }
\&   END_OF_JAVA_CODE
\&
\&   my $alu = new Pod_alu() ;
\&   print($alu\->add(9, 16) . "\en") ; # prints 25
\&   print($alu\->subtract(9, 16) . "\en") ; # prints \-7
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Inline::Java\*(C'\fR module allows you to put Java source code
directly \*(L"inline\*(R" in a Perl script or module. A Java compiler
is launched and the Java code is compiled. Then Perl asks the
Java classes what public methods have been defined. These classes
and methods are available to the Perl program as if they had been
written in Perl.
.PP
The process of interrogating the Java classes for public methods
occurs the first time you run your Java code. The namespace is
cached, and subsequent calls use the cached version.
.SH "USING THE Inline::Java MODULE"
.IX Header "USING THE Inline::Java MODULE"
\&\f(CW\*(C`Inline::Java\*(C'\fR is driven by fundamentally the same idea as other
\&\f(CW\*(C`Inline\*(C'\fR language modules, like \f(CW\*(C`Inline::C\*(C'\fR or \f(CW\*(C`Inline::CPP\*(C'\fR.
Because Java is both compiled and interpreted, the method of getting
your code is different, but overall, using \f(CW\*(C`Inline::Java\*(C'\fR is very similar
to any other \f(CW\*(C`Inline\*(C'\fR language module.
.PP
This section will explain the different ways to \f(CW\*(C`use\*(C'\fR Inline::Java.
For more details on \f(CW\*(C`Inline\*(C'\fR, see 'perldoc Inline'.
.PP
\&\fBBasic Usage\fR
.PP
The most basic form for using \f(CW\*(C`Inline::Java\*(C'\fR is:
.PP
.Vb 1
\&   use Inline Java => \*(AqJava source code\*(Aq ;
.Ve
.PP
Of course, you can use Perl's \*(L"here document\*(R" style of quoting to make
the code slightly easier to read:
.PP
.Vb 1
\&   use Inline Java => <<\*(AqEND\*(Aq;
\&
\&      Java source code goes here.
\&
\&   END
.Ve
.PP
The source code can also be specified as a filename, a subroutine
reference (sub routine should return source code), or an array
reference (array contains lines of source code). This information
is detailed in 'perldoc Inline'.
.PP
In order for \f(CW\*(C`Inline::Java\*(C'\fR to function properly, it needs to know
where to find a Java 2 \s-1SDK\s0 on your machine. This is done using one
of the following techniques:
.IP "1." 4
Set the J2SDK configuration option to the correct directory
.IP "2." 4
Set the \s-1PERL_INLINE_JAVA_J2SDK\s0 environment variable to the 
correct directory
.PP
If none of these are specified, \f(CW\*(C`Inline::Java\*(C'\fR will use the Java
2 \s-1SDK\s0 that was specified a install time (see below).
.SH "DEFAULT JAVA 2 SDK"
.IX Header "DEFAULT JAVA 2 SDK"
When \f(CW\*(C`Inline::Java\*(C'\fR was installed, the path to the Java 2 \s-1SDK\s0 that was
used was stored in a file called default_j2sdk.pl that resides with
the \f(CW\*(C`Inline::Java\*(C'\fR module. You can find this file by using the following
command:
.PP
.Vb 1
\&    % perl \-MInline::Java=j2sdk
.Ve
.PP
If you wish to permanently change the default Java 2 \s-1SDK\s0 that is used
by \f(CW\*(C`Inline::Java\*(C'\fR, edit this file and change the value found there.
If you wish use a different Java 2 \s-1SDK\s0 temporarily, see the J2SDK
configuration option described below.
.PP
Additionally, you can use the following command to get the list of directories
that you should put in you shared library path when using the \s-1JNI\s0 extension:
.PP
.Vb 1
\&    % perl \-MInline::Java=so_dirs
.Ve
.SH "CONFIGURATION OPTIONS"
.IX Header "CONFIGURATION OPTIONS"
There are a number of configuration options that dictate the
behavior of \f(CW\*(C`Inline::Java\*(C'\fR:
.IP "J2SDK" 4
.IX Item "J2SDK"
Specifies the path to your Java 2 \s-1SDK\s0.
.Sp
.Vb 1
\&   Ex: J2SDK => \*(Aq/my/java/2/sdk/path\*(Aq
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls
make use of the same \s-1JVM\s0.
.IP "\s-1PORT\s0" 4
.IX Item "PORT"
Specifies the port number for the server. Default is \-1 (next
available port number), default for \s-1SHARED_JVM\s0 mode is 7891.
.Sp
.Vb 1
\&   Ex: PORT => 4567
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls
make use of the same \s-1JVM\s0.
.IP "\s-1HOST\s0" 4
.IX Item "HOST"
Specifies the host on which the \s-1JVM\s0 server is running. This option
really only makes sense in \s-1SHARED_JVM\s0 mode when \s-1START_JVM\s0 is disabled.
.Sp
.Vb 1
\&   Ex: HOST => \*(Aqjvm.server.com\*(Aq
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls
make use of the same \s-1JVM\s0.
.IP "\s-1BIND\s0" 4
.IX Item "BIND"
Specifies the \s-1IP\s0 address on which the \s-1JVM\s0 server will be listening. By 
default the \s-1JVM\s0 server listens for connections on 'localhost' only.
.Sp
.Vb 2
\&   Ex: BIND => \*(Aq192.168.1.1\*(Aq
\&   Ex: BIND => \*(Aq0.0.0.0\*(Aq
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls
make use of the same \s-1JVM\s0.
.IP "\s-1STARTUP_DELAY\s0" 4
.IX Item "STARTUP_DELAY"
Specifies the maximum number of seconds that the Perl script
will try to connect to the Java server. In other this is the
delay that Perl gives to the Java server to start. Default 
is 15 seconds.
.Sp
.Vb 1
\&   Ex: STARTUP_DELAY => 20
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls
make use of the same \s-1JVM\s0.
.IP "\s-1CLASSPATH\s0" 4
.IX Item "CLASSPATH"
Adds the specified \s-1CLASSPATH\s0. This \s-1CLASSPATH\s0 will only be available
through the user classloader. To set the \s-1CLASSPATH\s0 globally (which is
most probably what you want to do anyways), use the \s-1CLASSPATH\s0 
environment variable.
.Sp
.Vb 1
\&   Ex: CLASSPATH => \*(Aq/my/other/java/classses\*(Aq
.Ve
.IP "\s-1JNI\s0" 4
.IX Item "JNI"
Toggles the execution mode. The default is to use the client/server
mode. To use the \s-1JNI\s0 extension (you must have built it at install 
time though. See \s-1README\s0 and \s-1README\s0.JNI for more information), set
\&\s-1JNI\s0 to 1.
.Sp
.Vb 1
\&   Ex: JNI => 1
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls 
make use of the same \s-1JVM\s0.
.IP "\s-1EXTRA_JAVA_ARGS\s0, \s-1EXTRA_JAVAC_ARGS\s0" 4
.IX Item "EXTRA_JAVA_ARGS, EXTRA_JAVAC_ARGS"
Specify extra command line parameters to be passed to, respectively,  
the \s-1JVM\s0 and the Java compiler. Use with caution as some options may 
alter normal \f(CW\*(C`Inline::Java\*(C'\fR behavior.
.Sp
.Vb 1
\&   Ex: EXTRA_JAVA_ARGS => \*(Aq\-Xmx96m\*(Aq
.Ve
.Sp
Note: \s-1EXTRA_JAVA_ARGS\s0 only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls 
make use of the same \s-1JVM\s0.
.IP "\s-1EMBEDDED_JNI\s0" 4
.IX Item "EMBEDDED_JNI"
Same as \s-1JNI\s0, except \f(CW\*(C`Inline::Java\*(C'\fR expects the \s-1JVM\s0 to already be
loaded and to have loaded the Perl interpreter that is running the
script. This is an advanced feature that should only be need in
very specific circumstances.
.Sp
.Vb 1
\&   Ex: EMBEDDED_JNI => 1
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls 
make use of the same \s-1JVM\s0. Also, the \s-1EMBEDDED_JNI\s0 option automatically
sets the \s-1JNI\s0 option.
.IP "\s-1SHARED_JVM\s0" 4
.IX Item "SHARED_JVM"
This mode enables mutiple processes to share the same \s-1JVM\s0. It was 
created mainly in order to be able to use \f(CW\*(C`Inline::Java\*(C'\fR under 
mod_perl.
.Sp
.Vb 1
\&   Ex: SHARED_JVM => 1
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls 
make use of the same \s-1JVM\s0.
.IP "\s-1START_JVM\s0" 4
.IX Item "START_JVM"
When used with \s-1SHARED_JVM\s0, tells \f(CW\*(C`Inline::Java\*(C'\fR that the \s-1JVM\s0 should
already be running and that it should not attempt to start a new
one. This option is useful in combination with command line interface
described in the \s-1BUGS\s0 \s-1AND\s0 \s-1DEFICIENCIES\s0 section. Default is 1.
.Sp
.Vb 1
\&   Ex: START_JVM => 0
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls 
make use of the same \s-1JVM\s0.
.IP "\s-1PRIVATE\s0" 4
.IX Item "PRIVATE"
In \s-1SHARED_JVM\s0 mode, makes every connection to the \s-1JVM\s0 use a different
classloader so that each connection is isolated from the others.
.Sp
.Vb 1
\&   Ex: PRIVATE => 1
.Ve
.Sp
Note: This configuration option only has an effect on the first
\&'use Inline Java' call inside a Perl script, since all other calls
make use of the same \s-1JVM\s0.
.IP "\s-1DEBUG\s0" 4
.IX Item "DEBUG"
Enables debugging info. Debugging now uses levels (1 through 5)
that (loosely) follow these definitions:
.Sp
.Vb 5
\&   1 = Major program steps
\&   2 = Object creation/destruction
\&   3 = Method/member accesses + packet dumps
\&   4 = Everything else
\&   5 = Data structure dumps
\&
\&   Ex: DEBUG => 2
.Ve
.IP "\s-1DEBUGGER\s0" 4
.IX Item "DEBUGGER"
Starts jdb, (the Java debugger) instead of the regular Java \s-1JVM\s0.
This option will also cause the Java code to be compiled using the
\&'\-g' switch for extra debugging information. \s-1EXTRA_JAVA_ARGS\s0 can
be used use to pass extra options to the debugger.
.Sp
.Vb 1
\&   Ex: DEBUGGER => 1
.Ve
.IP "\s-1WARN_METHOD_SELECT\s0" 4
.IX Item "WARN_METHOD_SELECT"
Throws a warning when \f(CW\*(C`Inline::Java\*(C'\fR has to 'choose' between 
different method signatures. The warning states the possible 
choices and the signature chosen.
.Sp
.Vb 1
\&   Ex: WARN_METHOD_SELECT => 1
.Ve
.IP "\s-1STUDY\s0" 4
.IX Item "STUDY"
Takes an array of Java classes that you wish to have 
\&\f(CW\*(C`Inline::Java\*(C'\fR learn about so that you can use them inside Perl.
.Sp
.Vb 1
\&   Ex: STUDY => [\*(Aqjava.lang.HashMap\*(Aq, \*(Aqmy.class\*(Aq]
.Ve
.IP "\s-1AUTOSTUDY\s0" 4
.IX Item "AUTOSTUDY"
Makes \f(CW\*(C`Inline::Java\*(C'\fR automatically study unknown classes it
encounters them.
.Sp
.Vb 1
\&   Ex: AUTOSTUDY => 1
.Ve
.IP "\s-1PACKAGE\s0" 4
.IX Item "PACKAGE"
Forces \f(CW\*(C`Inline::Java\*(C'\fR to bind the Java code under the specified
package instead of under the current (caller) package.
.Sp
.Vb 1
\&   Ex: PACKAGE => \*(Aqmain\*(Aq
.Ve
.IP "\s-1NATIVE_DOUBLES\s0" 4
.IX Item "NATIVE_DOUBLES"
Normally, \f(CW\*(C`Inline::Java\*(C'\fR stringifies floating point numbers when passing 
them between Perl and Java. In certain cases, this can lead to loss of
precision. When \s-1NATIVE_DOUBLES\s0 is set, \f(CW\*(C`Inline::Java\*(C'\fR will send the actual
double bytes in order to preserve precision. 
Note: This applies only to doubles, not floats.
Note: This option may not be portable and may not work properly on some
platforms.
.Sp
.Vb 1
\&   Ex: NATIVE_DOUBLES => 1
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
Every configuration option listed above, with the exception of \s-1STUDY\s0,
can be specified using an environment variable named using the 
following convention:
.PP
.Vb 1
\&   PERL_INLINE_JAVA_<option name>
.Ve
.PP
For example, your can specified the \s-1JNI\s0 option usng the 
\&\s-1PERL_INLINE_JAVA_JNI\s0 environment variable.
.PP
Note that environment variables take precedence over options specified
in the script itself.
.PP
Under Win32, you can also use set the \s-1PERL_INLINE_JAVA_COMMAND_COM\s0 
environment variable to a true value to indicate that you are using 
the command.com shell. However, \f(CW\*(C`Inline::Java\*(C'\fR should normally be 
able to determine this on its own.
.SH "CLASSES AND OBJECTS"
.IX Header "CLASSES AND OBJECTS"
Because Java is object oriented, any interface between Perl and Java
needs to support Java classes adequately.
.PP
Example:
.PP
.Vb 4
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      class Pod_1 {
\&         String data = "data" ;
\&         static String sdata = "static data" ;
\&
\&         public Pod_1(){
\&         }
\&
\&         public String get_data(){
\&            return data ;
\&         }
\&
\&         public static String get_static_data(){
\&            return sdata ;
\&         }
\&
\&         public void set_data(String d){
\&            data = d ;
\&         }
\&
\&         private void priv(){
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_1 ;
\&   print($obj\->get_data() . "\en") ; # prints data
\&   $obj\->set_data("new data") ;
\&   print($obj\->get_data() . "\en") ; # prints new data
.Ve
.PP
\&\f(CW\*(C`Inline::Java\*(C'\fR created a new namespace called \f(CW\*(C`main::Pod_1\*(C'\fR and 
created the following functions:
.PP
.Vb 6
\&   sub main::Pod_::new { ... }
\&   sub main::Pod_::Pod_1 { ... }
\&   sub main::Pod_::get_data { ... }
\&   sub main::Pod_::get_sdata { ... }
\&   sub main::Pod_::set_data { ... }
\&   sub main::Pod_::DESTROY { ... }
.Ve
.PP
Note that only the public methods are exported to Perl.
.PP
Inner classes are also supported, you simply need to supply a reference
to an outer class object as the first parameter of the constructor:
.PP
.Vb 4
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      class Pod_2 {
\&         public Pod_2(){
\&         }
\&
\&         public class Pod_2_Inner {
\&            public String name = "Pod_2_Inner" ;
\&
\&            public Pod_2_Inner(){
\&            }
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_2() ;
\&   my $obj2 = new Pod_2::Pod_2_Inner($obj) ;
\&   print($obj2\->{name} . "\en") ; # prints Pod_2_Inner
.Ve
.SH "METHODS"
.IX Header "METHODS"
In the previous example we have seen how to call a method. You can also
call static methods in the following manner:
.PP
.Vb 4
\&   print Pod_1\->get_sdata() . "\en" ; # prints static data
\&   # or
\&   my $obj = new Pod_1() ;
\&   print $obj\->get_sdata() . "\en" ; # prints static data
.Ve
.PP
You can pass any kind of Perl scalar or any Java object to a method. It
will be automatically converted to the correct type:
.PP
.Vb 7
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      class Pod_3_arg {
\&         public Pod_3_arg(){
\&         }
\&      }
\&      class Pod_3 {
\&         public int n ;
\&
\&         public Pod_3(int i, String j, Pod_3_arg k) {
\&            n = i ;
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_3_arg() ;
\&   my $obj2 = new Pod_3(5, "toto", $obj) ;
\&   print($obj2\->{n} . "\en") ; # prints 5
.Ve
.PP
will work fine. These objects can be of any type, even if these types
are not known to \f(CW\*(C`Inline::Java\*(C'\fR. This is also true for return types:
.PP
.Vb 2
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      import java.util.* ;
\&
\&      class Pod_4 {
\&         public Pod_4(){
\&         }
\&
\&         public HashMap get_hash(){
\&            HashMap h = new HashMap() ;
\&            h.put("key", "value") ;
\&
\&            return h ;
\&         }
\&
\&         public String do_stuff_to_hash(HashMap h){
\&           return (String)h.get("key") ;
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_4() ;
\&   my $h = $obj\->get_hash() ;
\&   print($obj\->do_stuff_to_hash($h) . "\en") ; # prints value
.Ve
.PP
Objects of types unknown to Perl can exist in the Perl space, you just 
can't call any of their methods. See the \s-1STUDYING\s0 section for more
information on how to tell \f(CW\*(C`Inline::Java\*(C'\fR to learn about these classes.
.SH "MEMBER VARIABLES"
.IX Header "MEMBER VARIABLES"
You can also access all public member variables (static or not) from Perl.
As with method arguments, the types of these variables does not need to
be known to Perl:
.PP
.Vb 2
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      import java.util.* ;
\&
\&      class Pod_5 {
\&         public int i ;
\&         public static HashMap hm ;
\&
\&         public Pod_5(){
\&         }
\&     }
\&   END
\&
\&   my $obj = new Pod_5() ;
\&   $obj\->{i} = 2 ;
\&   print($obj\->{i} . "\en") ; # prints 2
\&   my $hm1 = $obj\->{hm} ; # instance way
\&   my $hm2 = $Pod_4::hm ; # static way
.Ve
.PP
Note: Watch out for typos when accessing members in the static fashion,
\&'use strict' will not catch them since they have a package name...
.SH "ARRAYS"
.IX Header "ARRAYS"
You can also send, receive and modify arrays. This is done simply by
using Perl lists:
.PP
.Vb 2
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      import java.util.* ;
\&
\&      class Pod_6 {
\&         public int i[] = {5, 6, 7} ;
\&
\&         public Pod_6(){
\&         }
\&
\&         public String [] f(String a[]){
\&            return a ;
\&         }
\&
\&         public String [][] f(String a[][]){
\&            return a ;
\&         }
\&     }
\&   END
\&
\&   my $obj = new Pod_6() ;
\&   my $i_2 = $obj\->{i}\->[2] ; # 7
\&   print($i_2 . "\en") ; # prints 7
\&
\&   my $a1 = $obj\->f(["a", "b", "c"]) ; # String []
\&   my $a2 = $obj\->f([
\&      ["00", "01"],
\&      ["10", "11"],
\&   ]) ; # String [][]
\&   print($a2\->[1]\->[0] . "\en") ; # prints 10
.Ve
.SH "EXCEPTIONS"
.IX Header "EXCEPTIONS"
You can now (as of 0.31) catch exceptions as objects when they are thrown 
from Java. To do this you use the regular Perl exception tools: eval and
$@. A helper function named 'caught' is provided to help determine the
type of the exception. Here is a example of a typical use:
.PP
.Vb 2
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      import java.util.* ;
\&
\&      class Pod_9 {
\&         public Pod_9(boolean t) throws Exception {
\&            if (t){
\&               throw new Exception("ouch!") ;
\&            }
\&         }
\&      }
\&   END
\&
\&   use Inline::Java qw(caught) ;
\&
\&   eval {
\&           my $obj = new Pod_9(1) ;
\&   } ;
\&   if ($@){
\&      if (caught("java.lang.Exception")){
\&         my $msg = $@\->getMessage() ;
\&         print($msg . "\en") ; # prints ouch!
\&      }
\&      else{
\&         # It wasn\*(Aqt a Java exception after all...
\&         die $@ ;
\&      }
\&   }
.Ve
.PP
What's important to understand is that $@ actually contains a reference
to the Throwable object that was thrown by Java. The \fIgetMessage()\fR function
is really a method of the java.lang.Exception class. So if Java is throwing
a custom exception you have in your code, you will have access to that
exception object's public methods just like any other Java object in
\&\f(CW\*(C`Inline::Java\*(C'\fR. 
Note: \f(CW\*(C`Inline::Java\*(C'\fR uses eval under the hood, so it recommended that you
store any exception in a temporary variable before processing it, especially
f you will be calling other \f(CW\*(C`Inline::Java\*(C'\fR functions. It is also probably 
a good idea to undef $@ once you have treated a Java exception, or else 
the object still has a reference until $@ is reset by the next eval.
.SH "FILEHANDLES"
.IX Header "FILEHANDLES"
Java filehandles (java.io.Reader, java.io.Writer, java.io.InputStream or
java.io.OutputStream objects) can be wrapped the \f(CW\*(C`Inline::Java::Handle\*(C'\fR
class to allow reading or writing from Perl. Here's an example:
.PP
.Vb 2
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      import java.io.* ;
\&
\&      class Pod_91 {
\&         public static Reader getReader(String file) throws FileNotFoundException {
\&           return new FileReader(file) ;
\&         }
\&      }
\&   END
\&
\&    my $o = Pod_91\->getReader(\*(Aqdata.txt\*(Aq) ;
\&    my $h = new Inline::Java::Handle($o) ;
\&    while (<$h>){
\&      chomp($_) ;
\&      print($_ . "\en") ; # prints data
\&    }
.Ve
.PP
What's important to understand is that $@ actually contains a reference
to the Throwable object that was thrown by Java. The \fIgetMessage()\fR function
is really a method of the java.lang.Exception class. So if Java is throwing
a custom exception you have in your code, you will have access to that
exception object's public methods just like any other Java object in
\&\f(CW\*(C`Inline::Java\*(C'\fR. It is also probably a good idea to undef $@ once you have
treated a Java exception, or else the object still has a reference until
$@ is reset by the next eval.
.SH "CALLBACKS"
.IX Header "CALLBACKS"
See Inline::Java::Callbacks for more information on making callbacks.
.SH "STUDYING"
.IX Header "STUDYING"
As of version 0.21, \f(CW\*(C`Inline::Java\*(C'\fR can learn about other Java classes
and use them just like the Java code you write inside your Perl script.
In fact you are not even required to write Java code inside your Perl
script anymore. Here's how to use the 'studying' function:
.PP
.Vb 4
\&   use Inline (
\&      Java => \*(AqSTUDY\*(Aq,
\&      STUDY => [\*(Aqjava.util.HashMap\*(Aq],
\&   ) ;
\&
\&   my $hm = new java::util::HashMap() ;
\&   $hm\->put("key", "value") ;
\&   my $val = $hm\->get("key") ;
\&   print($val . "\en") ; # prints value
.Ve
.PP
If you do not wish to put any Java code inside you Perl script, you must
use the string '\s-1STUDY\s0' as your code. This will skip the build section.
.PP
You can also use the \s-1AUTOSTUDY\s0 option to tell \f(CW\*(C`Inline::Java\*(C'\fR that you wish
to study all classes that it comes across:
.PP
.Vb 2
\&   use Inline Java => <<\*(AqEND\*(Aq, AUTOSTUDY => 1 ;
\&      import java.util.* ;
\&
\&      class Pod_10 {
\&         public Pod_10(){
\&         }
\&
\&         public HashMap get_hm(){
\&            HashMap hm = new HashMap() ;
\&            return hm ;
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_10() ;
\&   my $hm = $obj\->get_hm() ;
\&   $hm\->put("key", "value") ;
\&   my $val = $hm\->get("key") ;
\&   print($val . "\en") ; # prints value
.Ve
.PP
In this case \f(CW\*(C`Inline::Java\*(C'\fR intercepts the return value of the \fIget_hm()\fR
method, sees that it's of a type that it doesn't know about 
(java.lang.HashMap), and immediately studies the class. After that call 
the java::lang::HashMap class is available to use through Perl.
.PP
In some cases you may not know which classes to study until runtime. In 
these cases you can use the \fIstudy_classes()\fR function:
.PP
.Vb 5
\&   use Inline (
\&      Java => \*(AqSTUDY\*(Aq,
\&      STUDY => [],
\&   ) ;
\&   use Inline::Java qw(study_classes) ;
\&
\&   study_classes([\*(Aqjava.util.HashMap\*(Aq], undef) ;
\&   my $hm = new java::util::HashMap() ;
\&   $hm\->put("key", "value") ;
\&   my $val = $hm\->get("key") ;
\&   print($val . "\en") ; # prints value
.Ve
.PP
The \fIstudy_classes()\fR function takes 2 arguments, a reference to an array of
class names (like the \s-1STUDY\s0 configuration option) and the name of the 
package in which to bind those classes. If the name of the package is 
undefined, the classes will be bound to the current (caller) package.
.PP
Note: You can only specify the names of packages in which you have 
previously \*(L"used\*(R" \f(CW\*(C`Inline::Java\*(C'\fR.
.SH "TYPE CASTING"
.IX Header "TYPE CASTING"
Sometimes you need to manipulate a Java object using a specific
subtype. That's when type casting is necessary. Here's an 
example of this:
.PP
.Vb 6
\&   use Inline (
\&      Java => \*(AqSTUDY\*(Aq,
\&      STUDY => [\*(Aqjava.util.HashMap\*(Aq],
\&      AUTOSTUDY => 1,
\&   ) ;
\&   use Inline::Java qw(cast) ;
\&
\&   my $hm = new java::util::HashMap() ;
\&   $hm\->put(\*(Aqkey\*(Aq, \*(Aqvalue\*(Aq) ;
\&
\&   my $entries = $hm\->entrySet()\->toArray() ;
\&   foreach my $e (@{$entries}){
\&     # print($e\->getKey() . "\en") ; # No!
\&     print(cast(\*(Aqjava.util.Map$Entry\*(Aq, $e)\->getKey() . "\en") ; # prints key
\&   }
.Ve
.PP
In this case, \f(CW\*(C`Inline::Java\*(C'\fR knows that \f(CW$e\fR is of type java.util.HashMap$Entry.
The problem is that this type is not public, and therefore we can't access
the object through that type. We must cast it to a java.util.Map$Entry, which
is a public interface and will allow us to access the \fIgetKey()\fR method.
.PP
You can also use type casting to force the selection of a specific method
signature for methods that have multiple signatures. See examples similar
to this in the \*(L"\s-1TYPE\s0 \s-1COERCING\s0\*(R" section below.
.SH "TYPE COERCING"
.IX Header "TYPE COERCING"
Type coercing is the equivalent of casting for primitives types 
and arrays. It is used to force the selection if a specific method
signature when \f(CW\*(C`Inline::Java\*(C'\fR has multiple choices. The coerce 
function returns a special object that can only be used when calling
Java methods or assigning Java members. Here is an example:
.PP
.Vb 4
\&   use Inline Java => <<\*(AqEND\*(Aq ;
\&      class Pod_101 {
\&         public Pod_101(){
\&         }
\&
\&         public String f(int i){
\&            return "int" ;
\&         }
\&
\&         public String f(char c){
\&            return "char" ;
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_101() ;
\&   print($obj\->f(\*(Aq5\*(Aq) . "\en") ; # prints int
.Ve
.PP
In this case, \f(CW\*(C`Inline::Java\*(C'\fR will call f(int i), because '5' is an integer.
But '5' is a valid char as well. So to force the call of f(char c), do the 
following:
.PP
.Vb 4
\&   use Inline::Java qw(coerce) ;
\&   $obj\->f(coerce(\*(Aqchar\*(Aq, \*(Aq5\*(Aq)) ;
\&   # or
\&   $obj\->f(Inline::Java::coerce(\*(Aqchar\*(Aq, \*(Aq5\*(Aq)) ;
.Ve
.PP
The coerce function forces the selection of the matching signature. Note that
the coerce must match the argument type exactly. Coercing to a class that
extends the argument type will not work.
.PP
Another case where type coercing is needed is when one wants to pass an array
as a java.lang.Object:
.PP
.Vb 4
\&   use Inline Java => <<\*(AqEND\*(Aq;
\&      class Pod_8 {
\&         public Object o ;
\&         int a[] = {1, 2, 3} ;
\&
\&         public Pod_8() {
\&         }
\&      }
\&   END
\&
\&   my $obj = new Pod_8() ;
\&   $obj\->{o} = [1, 2, 3] ;      # No!
.Ve
.PP
The reason why this will not work is simple. When \f(CW\*(C`Inline::Java\*(C'\fR sees an
array, it checks the Java type you are trying to match it against to validate
the construction of your Perl list. But in this case, it can't validate
the array because you're assigning it to an Object. You must use the 3 
parameter version of the coerce function to do this:
.PP
.Vb 4
\&   $obj\->{o} = Inline::Java::coerce(
\&     "java.lang.Object", 
\&     [1, 2, 3],
\&     "[Ljava.lang.String;") ;
.Ve
.PP
This tells \f(CW\*(C`Inline::Java\*(C'\fR to validate your Perl list as a String [], and 
then coerce it as an Object.
.PP
Here is how to construct the array type representations:
.PP
.Vb 3
\&  [<type>  \-> 1 dimensional <type> array
\&  [[<type> \-> 2 dimensional <type> array
\&  ...
\&
\&  where <type> is one of:
\&    B byte     S short     I int     J long  
\&    F float    D double    C char    Z boolean
\&
\&    L<class>; array of <class> objects
.Ve
.PP
This is described in more detail in most Java books that talk about
reflection.
.PP
But you only need to do this if you have a Perl list. If you already have a
Java array reference obtained from elsewhere, you don't even need to coerce:
.PP
.Vb 1
\&   $obj\->{o} = $obj\->{a} ;
.Ve
.SH "JNI vs CLIENT/SERVER MODES"
.IX Header "JNI vs CLIENT/SERVER MODES"
Starting in version 0.20, it is possible to use the \s-1JNI\s0 (Java Native 
Interface) extension. This enables \f(CW\*(C`Inline::Java\*(C'\fR to load the Java virtual 
machine as a shared object instead of running it as a stand-alone server.
This brings an improvement in performance.
.PP
If you have built the \s-1JNI\s0 extension, you must enable it explicitely by doing
one of the following:
.IP "1." 4
Set the \s-1JNI\s0 configuration option to 1
.IP "2." 4
Set the \s-1PERL_INLINE_JAVA_JNI\s0 environment variable to 1
.PP
Note: \f(CW\*(C`Inline::Java\*(C'\fR only creates one virtual machine instance. Therefore
you can't use \s-1JNI\s0 for some sections and client/server for others. The first
section determines the execution mode.
.PP
See \s-1README\s0.JNI for more information about the \s-1JNI\s0 extension.
.SH "SHARED_JVM"
.IX Header "SHARED_JVM"
Starting with version 0.30, the \f(CW\*(C`Inline::Java\*(C'\fR \s-1JVM\s0 can now be shared between
multiple processes. The first process to start creates the \s-1JVM\s0 but does not 
shut it down on exit. All other processes can then connect as needed to the \s-1JVM\s0. 
If any of these other processes where created by forking the parent process, 
the Inline::Java\->\fIreconnect_JVM()\fR function must be called in the child to get 
a fresh connection to the \s-1JVM\s0. Ex:
.PP
.Vb 11
\&   use Inline (
\&      Java => <<\*(AqEND\*(Aq,
\&         class Pod_11 {
\&            public static int i = 0 ;
\&            public Pod_11(){
\&               i++ ;
\&            }
\&         }
\&   END
\&      SHARED_JVM => 1,
\&   ) ;
\&
\&   my $nb = 5 ;
\&   for (my $i = 0 ; $i < $nb ; $i++){
\&      if (! fork()){
\&         Inline::Java::reconnect_JVM() ;
\&         my $f = new Pod_11() ;
\&         exit ;
\&      }
\&   }
\&   sleep(5) ;
\&
\&   my $f = new Pod_11() ;
\&   print($f\->{i} . "\en") ; # prints 6
.Ve
.PP
Once this code was run, each of the 6 processes will have created a different 
instance of the 't' class. Data can be shared between the processes by using 
static members in the Java code.
.PP
Note: The Java System.out stream is closed in \s-1SHARED_JVM\s0 mode.
.SH "USING Inline::Java IN A CGI"
.IX Header "USING Inline::Java IN A CGI"
If you want to use \f(CW\*(C`Inline::Java\*(C'\fR in a \s-1CGI\s0 script, do the following:
.PP
.Vb 10
\&   use CGI ;
\&   use Inline (
\&      Java => <<\*(AqEND\*(Aq,
\&         class Pod_counter {
\&            public static int cnt = 0 ;
\&            public Pod_counter(){
\&               cnt++ ;
\&            }
\&         }
\&   END
\&      SHARED_JVM => 1,
\&      DIRECTORY => \*(Aq/somewhere/your/web/server/can/write\*(Aq,
\&   ) ;
\&
\&   my $c = new Pod_counter() ;
\&   my $q = new CGI() ;
\&   print 
\&      $q\->start_html() . 
\&      "This page has been accessed " . $c\->{cnt} . " times." .
\&      $q\->end_html() ;
.Ve
.PP
In this scenario, the first \s-1CGI\s0 to execute will start the \s-1JVM\s0, but does
not shut it down on exit. Subsequent \s-1CGI\s0, since they have the \s-1SHARED_JVM\s0
option enabled, will try to connect to the already existing \s-1JVM\s0 before
trying to start a new one. Therefore if the \s-1JVM\s0 happens to crash or is
killed, the next \s-1CGI\s0 that runs will start a new one. The \s-1JVM\s0 will be
killed when Apache is shut down.
.PP
See the \s-1BUGS\s0 \s-1AND\s0 \s-1DEFICIENCIES\s0 section if you have problems starting 
the \s-1SHARED_JVM\s0 server in a \s-1CGI\s0.
.SH "USING Inline::Java UNDER MOD_PERL"
.IX Header "USING Inline::Java UNDER MOD_PERL"
Here is an example of how to use \f(CW\*(C`Inline::Java\*(C'\fR under mod_perl:
.PP
.Vb 10
\&   use Apache2::Const qw(:common) ;
\&   use Inline (
\&      Java => <<\*(AqEND\*(Aq,
\&         class Pod_counter {
\&            public static int cnt = 0 ;
\&            public Pod_counter(){
\&               cnt++ ;
\&            }
\&         }
\&   END
\&      SHARED_JVM => 1,
\&      DIRECTORY => \*(Aq/somewhere/your/web/server/can/write\*(Aq,
\&   ) ;
\&
\&   my $c = new Pod_counter() ;
\&
\&   sub handler {
\&      my $r = shift ;
\&
\&      my $q = new CGI ;
\&      print
\&         $q\->start_html() .
\&         "This page has been accessed " . $c\->{cnt} . " times." .
\&         $q\->end_html() ;
\&
\&      return OK ;
\&   }
.Ve
.PP
See \s-1USING\s0 Inline::Java \s-1IN\s0 A \s-1CGI\s0 for more details.
.PP
If you are using ModPerl::Registry, make sure to use the \f(CW\*(C`PACKAGE\*(C'\fR
configuration option to specifiy the package in which \f(CW\*(C`Inline::Java\*(C'\fR
should bind the Java code, since ModPerl::Registry will place your
code in a package with a unpredictable name.
.PP
See the \s-1BUGS\s0 \s-1AND\s0 \s-1DEFICIENCIES\s0 section if you have problems starting 
the \s-1SHARED_JVM\s0 server under \s-1MOD_PERL\s0.
.SS "Preloading and PerlChildInitHandler"
.IX Subsection "Preloading and PerlChildInitHandler"
If you are loading \f(CW\*(C`Inline::Java\*(C'\fR during your server startup (common practice to 
increase shared memory and reduce run time) and you are using \f(CW\*(C`SHARED_JVM\*(C'\fR, then 
your Apache processes will all share the same socktd connection to that \s-1JVM\s0.
This will result in garbled communication and strange errors (like \*(L"Can't receive packet from \s-1JVM\s0\*(R", \*(L"Broken pipe\*(R", etc).
.PP
To fix this you need to tell Apache that after each child process has forked they
each need to create their own connections to the \s-1JVM\s0. This is done during the 
\&\f(CW\*(C`ChildInit\*(C'\fR stage.
.PP
For Apache 1.3.x this could look like:
.PP
.Vb 2
\&   # in httpd.conf
\&   PerlChildInitHandler MyProject::JavaReconnect
.Ve
.PP
And \f(CW\*(C`MyProject::JavaReconnect\*(C'\fR could be as simple as this:
.PP
.Vb 3
\&   package MyProject::JavaReconnect;
\&   sub handler($$) { Inline::Java::reconnect_JVM() }
\&   1;
.Ve
.SH "BUGS AND DEFICIENCIES"
.IX Header "BUGS AND DEFICIENCIES"
When reporting a bug, please do the following:
.PP
.Vb 4
\& \- Put "use Inline REPORTBUG;" at the top of your code, or
\&   use the command line option "perl \-MInline=REPORTBUG ...".
\& \- Run your code.
\& \- Follow the printed instructions.
.Ve
.PP
Here are some things to watch out for:
.IP "1." 4
You shouldn't name any of your classes 'B', 'S', 'I', 'J', 'F', 'D',
\&'C', 'Z' or 'L'. These classes seem to be used internally by Java to
represent the primitive types.
.IP "2." 4
If you upgrade \f(CW\*(C`Inline::Java\*(C'\fR from a previous version, be sure to delete
your _Inline directory so that \f(CW\*(C`Inline::Java\*(C'\fR's own Java classes get 
rebuilt to match the Perl code.
.IP "3." 4
Under certain environments, i.e. \s-1CGI\s0 or mod_perl, the \s-1JVM\s0 cannot start
properly because of the way these environments set up \s-1STDIN\s0 and \s-1STDOUT\s0.
In these cases, you may wish to control the \s-1JVM\s0 (in shared mode) manually
using the following commands:
.Sp
.Vb 4
\&    % perl \-MInline::Java::Server=status
\&    % perl \-MInline::Java::Server=start 
\&    % perl \-MInline::Java::Server=stop 
\&    % perl \-MInline::Java::Server=restart
.Ve
.Sp
You can specify \f(CW\*(C`Inline::Java\*(C'\fR options by setting the proper
environment variables, and you can also set the _Inline directory by using
the \s-1PERL_INLINE_JAVA_DIRECTORY\s0 environment variable.
.Sp
In addition, you may also wish to set the \s-1START_JVM\s0 option to 0 in your scripts 
to prevent them from trying to start their own \s-1JVM\s0 if they can't find one,
thereby causing problems.
.IP "4." 4
Because of problems with modules \f(CW\*(C`Inline::Java\*(C'\fR depends on, the usage of paths
containing spaces is not fully supported on all platforms. This applies to the
installation directory as well as the path for J2SDK and \s-1CLASSPATH\s0 elements.
.IP "5." 4
Even though it in run through a profiler regularly, \f(CW\*(C`Inline::Java\*(C'\fR is relatively 
slow compared to native Perl or Java.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Inline::Java::Callback, Inline::Java::PerlNatives, 
Inline::Java::PerlInterpreter.
.PP
For information about using \f(CW\*(C`Inline\*(C'\fR, see Inline.
.PP
For information about other Inline languages, see Inline-Support.
.PP
\&\f(CW\*(C`Inline::Java\*(C'\fR's mailing list is <inline@perl.org>.
To subscribe, send an email to <inline\-subscribe@perl.org>
.SH "AUTHOR"
.IX Header "AUTHOR"
Patrick LeBoutillier <patl@cpan.org> is the author of Inline::Java.
.PP
Brian Ingerson <ingy@cpan.org> is the author of Inline.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001\-2005, Patrick LeBoutillier.
.PP
All Rights Reserved. This module is free software. It may be used,
redistributed and/or modified under the terms of the Perl Artistic
License. See http://www.perl.com/perl/misc/Artistic.html for more
details.
