.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::SOAP11 3"
.TH XML::Compile::SOAP11 3 "2011-06-20" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::SOAP11 \- base for SOAP1.1 implementation
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& XML::Compile::SOAP11 has extra code in
\&   XML::Compile::SOAP11::Encoding
\&
\& XML::Compile::SOAP11
\&   is a XML::Compile::SOAP
\&
\& XML::Compile::SOAP11 is extended by
\&   XML::Compile::SOAP11::Client
\&   XML::Compile::SOAP11::Server
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # use either XML::Compile::SOAP11::Client or ::Server
\& # See XML::Compile::SOAP for global usage examples.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module handles the \s-1SOAP\s0 protocol version 1.1.
See \fIhttp://www.w3.org/TR/2000/NOTE\-SOAP\-20000508/\fR).
The implementation tries to behave like described in
\&\fIhttp://www.ws\-i.org/Profiles/BasicProfile\-1.0.html\fR
.PP
Two extensions are made: the \s-1SOAP11\s0 client
XML::Compile::SOAP11::Client.
and server in XML::Compile::SOAP11::Server.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->new(OPTIONS)"
To simplify the URIs of the actors, as specified with the \f(CW\*(C`destination\*(C'\fR
option, you may use the \s-1STRING\s0 \f(CW\*(C`NEXT\*(C'\fR.  It will be replaced by the
right \s-1URI\s0.
.Sp
.Vb 3
\& \-Option    \-\-Defined in     \-\-Default
\&  media_type  XML::Compile::SOAP  application/soap+xml
\&  schemas     XML::Compile::SOAP  created internally
.Ve
.RS 4
.IP "media_type => \s-1MIMETYPE\s0" 2
.IX Item "media_type => MIMETYPE"
.PD 0
.ie n .IP "schemas => ""XML::Compile::Cache"" object" 2
.el .IP "schemas => \f(CWXML::Compile::Cache\fR object" 2
.IX Item "schemas => XML::Compile::Cache object"
.RE
.RS 4
.RE
.PD
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBname\fR" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR" 4
.IX Item "$obj->name"
See \*(L"Accessors\*(R" in XML::Compile::SOAP
.ie n .IP "$obj\->\fBschemas\fR" 4
.el .IP "\f(CW$obj\fR\->\fBschemas\fR" 4
.IX Item "$obj->schemas"
See \*(L"Accessors\*(R" in XML::Compile::SOAP
.ie n .IP "$obj\->\fBversion\fR" 4
.el .IP "\f(CW$obj\fR\->\fBversion\fR" 4
.IX Item "$obj->version"
See \*(L"Accessors\*(R" in XML::Compile::SOAP
.SS "Single message"
.IX Subsection "Single message"
.ie n .IP "$obj\->\fBcompileMessage\fR(('\s-1SENDER\s0'|'\s-1RECEIVER\s0'), \s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBcompileMessage\fR(('\s-1SENDER\s0'|'\s-1RECEIVER\s0'), \s-1OPTIONS\s0)" 4
.IX Item "$obj->compileMessage(('SENDER'|'RECEIVER'), OPTIONS)"
.Vb 9
\& \-Option        \-\-Defined in     \-\-Default
\&  body            XML::Compile::SOAP  []
\&  destination     XML::Compile::SOAP  []
\&  faults          XML::Compile::SOAP  []
\&  header          XML::Compile::SOAP  undef
\&  headerfault                      []
\&  mustUnderstand  XML::Compile::SOAP  []
\&  role            XML::Compile::SOAP  ULTIMATE
\&  roles           XML::Compile::SOAP  []
.Ve
.RS 4
.IP "body => ENTRIES|HASH" 2
.IX Item "body => ENTRIES|HASH"
.PD 0
.IP "destination => ARRAY-OF-PAIRS" 2
.IX Item "destination => ARRAY-OF-PAIRS"
.IP "faults => ENTRIES|HASH" 2
.IX Item "faults => ENTRIES|HASH"
.IP "header => ENTRIES|HASH" 2
.IX Item "header => ENTRIES|HASH"
.IP "headerfault => \s-1ENTRIES\s0" 2
.IX Item "headerfault => ENTRIES"
.PD
\&\s-1ARRAY\s0 of simple name with element references, for all expected
faults.  There can be unexpected faults, which will not get
decoded automatically.
.IP "mustUnderstand => STRING|ARRAY\-OF\-STRING" 2
.IX Item "mustUnderstand => STRING|ARRAY-OF-STRING"
.PD 0
.IP "role => URI|ARRAY\-OF\-URI" 2
.IX Item "role => URI|ARRAY-OF-URI"
.IP "roles => ARRAY-OF-URI" 2
.IX Item "roles => ARRAY-OF-URI"
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBmessageStructure\fR(\s-1XML\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmessageStructure\fR(\s-1XML\s0)" 4
.IX Item "$obj->messageStructure(XML)"
.IP "XML::Compile::SOAP11\->\fBmessageStructure\fR(\s-1XML\s0)" 4
.IX Item "XML::Compile::SOAP11->messageStructure(XML)"
.PD
See \*(L"Single message\*(R" in XML::Compile::SOAP
.SS "Helpers"
.IX Subsection "Helpers"
.SS "Transcoding"
.IX Subsection "Transcoding"
.ie n .IP "$obj\->\fBreplyMustUnderstandFault\fR(\s-1TYPE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBreplyMustUnderstandFault\fR(\s-1TYPE\s0)" 4
.IX Item "$obj->replyMustUnderstandFault(TYPE)"
See \*(L"Transcoding\*(R" in XML::Compile::SOAP
.ie n .IP "$obj\->\fBroleAbbreviation\fR(\s-1URI\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBroleAbbreviation\fR(\s-1URI\s0)" 4
.IX Item "$obj->roleAbbreviation(URI)"
See \*(L"Transcoding\*(R" in XML::Compile::SOAP
.ie n .IP "$obj\->\fBroleURI\fR(URI|STRING)" 4
.el .IP "\f(CW$obj\fR\->\fBroleURI\fR(URI|STRING)" 4
.IX Item "$obj->roleURI(URI|STRING)"
See \*(L"Transcoding\*(R" in XML::Compile::SOAP
.SH "DETAILS"
.IX Header "DETAILS"
.SS "\s-1SOAP\s0 introduction"
.IX Subsection "SOAP introduction"
.SS "Naming types and elements"
.IX Subsection "Naming types and elements"
.SS "Client and Server implementations"
.IX Subsection "Client and Server implementations"
.SS "Use of wildcards (any/anyAttribute)"
.IX Subsection "Use of wildcards (any/anyAttribute)"
.SS "Header and Body entries"
.IX Subsection "Header and Body entries"
\fISimplest form\fR
.IX Subsection "Simplest form"
.PP
In the simplest form, the \f(CW\*(C`header\*(C'\fR and \f(CW\*(C`body\*(C'\fR refer (optionally) to a
list of \s-1PAIRS\s0, each containing a free to choose unique label and the
type of the element.  The unique label will be used in the Perl \s-1HASH\s0
which represents the message.
.PP
.Vb 2
\& my $h1el = pack_type $myns, $some_local;
\& my $b1el = \*(Aqmyprefix:$other_local\*(Aq;
\&
\& my $encode_query = $client\->compileMessage
\&   ( \*(AqSENDER\*(Aq
\&   , header   => [ h1 => $h1el ]
\&   , body     => [ b1 => $b1el ]
\&   , mustUnderstand => \*(Aqh1\*(Aq
\&   , destination    => [ h1 => \*(AqNEXT\*(Aq ]
\&   );
.Ve
.PP
\fIMost powerful form\fR
.IX Subsection "Most powerful form"
.PP
When the simple form is too simple, you can use a \s-1HASH\s0 for the header,
body or both.  The \s-1HASH\s0 structure is much like the \s-1WSDL\s0 structure.
For example:
.PP
.Vb 10
\& my $encode_query = $client\->compileMessage
\&   ( \*(AqSENDER\*(Aq
\&   , header   =>
\&      { use   => \*(Aqliteral\*(Aq
\&      , parts => [ { name => \*(Aqh1\*(Aq, element => $h1el
\&                   , mustUnderstand => 1, destination => \*(AqNEXT\*(Aq
\&                   } ]
\&      }
\&   , body     => [ b1 => $b1el ]
\&   );
.Ve
.PP
So, the header now is one \s-1HASH\s0, which tells us that we have a literal
definition (this is the default).  The optional parts for the header is
an \s-1ARRAY\s0 of HASHes, each describing one part.  As you can see, the
mustUnderstand and destination fields are more convenient (although
the other syntax will work as well).
.PP
If you feel the need to control the compilation of the various parts,
with hooks or options (see \fIXML::Compile::Schema::compile()\fR), then have
a look at \fIXML::Compile::Cache::declare()\fR.  Declare how to handle the
various types before you call \fIcompileMessage()\fR.
.PP
You only call \fIcompileMessage()\fR explicitly if you do not have a \s-1WSDL\s0
file which contains this information. In the unlucky situation, you
have to dig out the defined types by hand.
.PP
But even with a \s-1WSDL\s0, there are still a few problems you may encounter.
For instance, the \s-1WSDL\s0 will not contain \f(CW\*(C`mustUnderstand\*(C'\fR and \f(CW\*(C`actor\*(C'\fR
header routing information.  You can add these to the compileClient call
.PP
.Vb 5
\&  my $call = $wsdl\->compileClient
\&    ( \*(AqMyCall\*(Aq
\&    , mustUnderstand => \*(Aqh1\*(Aq
\&    , destination    => [ h1 => \*(AqNEXT\*(Aq ]
\&    );
.Ve
.SS "Receiving faults in \s-1SOAP1\s0.1"
.IX Subsection "Receiving faults in SOAP1.1"
When faults are received, they will be returned with the \f(CW\*(C`Fault\*(C'\fR key
in the data structure.  So:
.PP
.Vb 2
\&  my $answer = $call\->($question);
\&  if($answer\->{Fault}) { ... }
.Ve
.PP
As extra service, for each of the fault types, as defined with
compileMessage(faults), a decoded structure is included.  The name
of that structure can be found like this:
.PP
.Vb 5
\&  if(my $faults = $answer\->{Fault})
\&  {   my $name    = $faults\->{_NAME};
\&      my $decoded = $answer\->{$name};
\&      ...
\&  }
.Ve
.PP
The untranslated \f(CW$faults\fR \s-1HASH\s0 looks like this:
.PP
.Vb 7
\& Fault =>
\&   { faultcode => \*(Aq{http://schemas.xmlsoap.org/soap/envelope/}Server.first\*(Aq
\&   , faultstring => \*(Aqmy mistake\*(Aq
\&   , faultactor => \*(Aqhttp://schemas.xmlsoap.org/soap/actor/next\*(Aq
\&   , detail => { \*(Aq{http://test\-types}fault_one\*(Aq => [ XMLNODES ] }
\&   , _NAME => \*(Aqfault1\*(Aq
\&   }
.Ve
.PP
The \f(CW\*(C`_NAME\*(C'\fR originates from the compileMessage(faults) option:
.PP
.Vb 2
\&   $soap\->compileMessage(\*(AqRECEIVER\*(Aq, ...
\&     , faults => [ fault1 => \*(Aq{http://test\-types}fault_one\*(Aq ] );
.Ve
.PP
Now, automatically the answer will contain the decoded fault
structure as well:
.PP
.Vb 8
\&  fault1 =>
\&    { code => \*(Aq{http://schemas.xmlsoap.org/soap/envelope/}Server.first\*(Aq
\&    , class  => [ \*(Aqhttp://schemas.xmlsoap.org/soap/envelope/\*(Aq
\&         , \*(AqReceiver\*(Aq, \*(Aqfirst\*(Aq ]
\&    , reason => \*(Aqmy mistake\*(Aq,
\&    , role   => \*(AqNEXT\*(Aq
\&    , detail => { help => \*(Aqplease ignore\*(Aq }
\&    }
.Ve
.PP
The \f(CW\*(C`detail\*(C'\fR is the decoding of the \s-1XMLNODES\s0, which are defined to
be of type \f(CW\*(C`{http://test\-types}fault_one\*(C'\fR.
.PP
The \f(CW\*(C`class\*(C'\fR is an unpacked version of the code.  \s-1SOAP1\s0.2 is using the
(better) terms \f(CW\*(C`Sender\*(C'\fR and \f(CW\*(C`Receiver\*(C'\fR.
.PP
\&\f(CW\*(C`role\*(C'\fR is constructed by decoding the \f(CW\*(C`faultactor\*(C'\fR using
\&\fIroleAbbreviation()\fR.  The names are closer to the \s-1SOAP1\s0.2 specification.
.PP
If the received fault is of an unpredicted type, then the client tries
to \s-1DWIM\s0. in the worst case, \f(CW\*(C`detail\*(C'\fR will list the unparsed XMLNODEs.
When the XML::Compile::SOAP::Daemon server has produced the error,
the content of the reply will typically be
.PP
.Vb 10
\& { Fault =>        # SOAP version specific
\&    { _NAME => \*(Aqerror\*(Aq
\&    , #...more...
\&    }
\& , error =>        # less SOAP version specific, readable
\&    { role    => \*(AqNEXT\*(Aq
\&    , reason  => \*(Aqprocedure xyz for SOAP11 produced an invalid response\*(Aq
\&    , error   => \*(Aqsome explanation\*(Aq
\&    , code    =>
\&        \*(Aq{http://schemas.xmlsoap.org/soap/envelope/}Server.invalidResponse\*(Aq
\&    , class   => [ SOAP11ENV, \*(AqReceiver\*(Aq, \*(AqinvalidResponse\*(Aq ],
\&    }
\&  }
.Ve
.PP
Hence, a typical client routine could contain
.PP
.Vb 10
\&  my ($answer, $trace) = $call\->(message => $message);
\&  if(my $f = $answer\->{Fault})
\&  {   if($f\->{_NAME} eq \*(Aqerror\*(Aq)
\&      {   # server implementation error
\&          die "SERVER ERROR:\en$answer\->{error}{error}\en";
\&      }
\&      else
\&      {   # the fault is described in the WSDL, handle it!
\&          warn "FAULT:\en",Dumper $answer\->{$f\->{_NAME}};
\&      }
\&  }
\&  else
\&  {   # correct answer
\&      print Dumper $answer;
\&  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile-SOAP distribution version 2.24,
built on June 20, 2011. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Other distributions in this suite:
XML::Compile,
XML::Compile::SOAP,
XML::Compile::SOAP12,
XML::Compile::SOAP::Daemon,
XML::Compile::SOAP::WSA,
XML::Compile::C14N,
XML::Compile::WSS,
XML::Compile::Tester,
XML::Compile::Cache,
XML::Compile::Dumper,
XML::Compile::RPC,
XML::Rewrite,
XML::eXistDB,
and
XML::LibXML::Simple.
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2011 by Mark Overmeer. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
