.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::Passphrase 3"
.TH Authen::Passphrase 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::Passphrase \- hashed passwords/passphrases as objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Authen::Passphrase;
\&
\&        $ppr = Authen::Passphrase\->from_crypt($passwd);
\&        $ppr = Authen::Passphrase\->from_rfc2307($userPassword);
\&
\&        if($ppr\->match($passphrase)) { ...
\&
\&        $passphrase = $ppr\->passphrase;
\&
\&        $crypt = $ppr\->as_crypt;
\&        $userPassword = $ppr\->as_rfc2307;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the base class for a system of objects that encapsulate
passphrases.  An object of this type is a passphrase recogniser: its
job is to recognise whether an offered passphrase is the right one.
For security, such passphrase recognisers usually do not themselves know
the passphrase they are looking for; they can merely recognise it when
they see it.  There are many schemes in use to achieve this effect,
and the intent of this class is to provide a consistent interface to
them all, hiding the details.
.PP
The \s-1CPAN\s0 package Authen-Passphrase contains implementations of several
specific passphrase schemes in addition to the base class.  See the
specific classes for notes on the security properties of each scheme.
In new systems, if there is a choice of which passphrase algorithm to
use, it is recommended to use Authen::Passphrase::SaltedDigest or
Authen::Passphrase::BlowfishCrypt.  Most other schemes are too weak
for new applications, and should be used only for backward compatibility.
.SS "Side-channel cryptanalysis"
.IX Subsection "Side-channel cryptanalysis"
Both the Authen-Passphrase framework and most of the underlying
cryptographic algorithm implementations are vulnerable to side-channel
cryptanalytic attacks.  However, the impact of this is quite limited.
.PP
Unlike the case of symmetric encryption, where a side-channel attack can
extract the plaintext directly, the cryptographic operations involved in
passphrase recognition don't directly process the correct passphrase.
A sophisticated side-channel attack, applied when offering incorrect
passphrases for checking, could potentially extract salt (from the
operation of the hashing algorithm) and the target hash value (from
the comparison of hash values).  This would enable a cryptanalytic or
brute-force attack on the passphrase recogniser to be performed offline.
This is not a disaster; the very intent of storing only a hash of
the correct passphrase is that leakage of these stored values doesn't
compromise the passphrase.
.PP
In a typical usage scenario for this framework, the side-channel attacks
that can be mounted are very restricted.  If authenticating network
users, typically an attacker has no access at all to power consumption,
electromagnetic emanation, and other such side channels.  The only
side channel that is readily available is timing, and the precision of
timing measurements is significantly blunted by the normal processes of
network communication.  For example, it would not normally be feasible
to mount a timing attack against hash value comparison (to see how far
through the values the first mismatch was).
.PP
Perl as a whole has not been built as a platform for
side-channel-resistant cryptography, so hardening Authen-Passphrase and
its underlying algorithms is not feasible.  In any serious use of Perl
for cryptography, including for authentication using Authen-Passphrase,
an analysis should be made of the exposure to side-channel attacks,
and if necessary efforts made to further blunt the timing channel.
.PP
One timing attack that is very obviously feasible over the network is to
determine which of several passphrase hashing algorithms is being used.
This can potentially distinguish between classes of user accounts,
or distinguish between existing and non-existing user accounts when an
attacker is guessing usernames.  To obscure this information requires
an extreme restriction of the timing channel, most likely by explicitly
pausing to standardise the amount of time spent on authentication.
This defence also rules out essentially all other timing attacks.
.SH "PASSPHRASE ENCODINGS"
.IX Header "PASSPHRASE ENCODINGS"
Because hashed passphrases frequently need to be stored, various encodings
of them have been devised.  This class has constructors and methods to
support these.
.SS "crypt encoding"
.IX Subsection "crypt encoding"
The Unix \fIcrypt()\fR function, which performs passphrase hashing, returns
hashes in a textual format intended to be stored in a text file.
In particular, such hashes are stored in /etc/passwd (and now /etc/shadow)
to control access to Unix user accounts.  The same textual format has
been adopted and extended by other passphrase-handling software such as
password crackers.
.PP
For historical reasons, there are several different syntaxes used in this
format.  The original DES-based password scheme represents its hashes
simply as a string of thirteen base 64 digits.  An extended variant of
this scheme uses nineteen base 64 digits, preceded by an "\fB_\fR\*(L" marker.
A more general syntax was developed later, which starts the string with
\&\*(R"\fB$\fR\*(L", an alphanumeric scheme identifier, and another \*(R"\fB$\fR".
.PP
In addition to actual passphrase hashes, the crypt format can also
represent a couple of special cases.  The empty string indicates that
there is no access control; it is possible to login without giving a
passphrase.  Finally, any string that is not a possible output of \fIcrypt()\fR
may be used to prevent login completely; "\fB*\fR" is the usual choice,
but other strings are used too.
.PP
crypt strings are intended to be used in text files that use colon and
newline characters as delimiters.  This module treats the crypt string
syntax as being limited to \s-1ASCII\s0 graphic characters excluding colon.
.SS "\s-1RFC\s0 2307 encoding"
.IX Subsection "RFC 2307 encoding"
\&\s-1RFC\s0 2307 describes an encoding system for passphrase hashes, to be used
in the "\fBuserPassword\fR\*(L" attribute in \s-1LDAP\s0 databases.  It encodes hashes
as \s-1ASCII\s0 text, and supports several passphrase schemes in an extensible
way by starting the encoding with an alphanumeric scheme identifier
enclosed in braces.  There are several standard scheme identifiers.
The \*(R"\fB{\s-1CRYPT\s0}\fR" scheme allows the use of any crypt encoding.
.PP
This module treats the \s-1RFC\s0 2307 string syntax as being limited to \s-1ASCII\s0
graphic characters.
.PP
The \s-1RFC\s0 2307 encoding is a good one, and is recommended for storage and
exchange of passphrase hashes.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "Authen::Passphrase\->from_crypt(\s-1PASSWD\s0)" 4
.IX Item "Authen::Passphrase->from_crypt(PASSWD)"
Returns a passphrase recogniser object matching the supplied crypt
encoding.  This constructor may only be called on the base class, not
any subclass.
.Sp
The specific passphrase recogniser class is loaded at runtime, so
successfully loading \f(CW\*(C`Authen::Passphrase\*(C'\fR does not guarantee that
it will be possible to use a specific type of passphrase recogniser.
If necessary, check separately for presence and loadability of the
recogniser class.
.Sp
Known scheme identifiers:
.RS 4
.ie n .IP "\fB\fB$1\fB$\fR" 4
.el .IP "\fB\f(CB$1\fB$\fR" 4
.IX Item "$1$"
A baroque passphrase scheme based on \s-1MD5\s0, designed by
Poul-Henning Kamp and originally implemented in FreeBSD.  See
Authen::Passphrase::MD5Crypt.
.ie n .IP "\fB\fB$2\fB$\fR" 4
.el .IP "\fB\f(CB$2\fB$\fR" 4
.IX Item "$2$"
.PD 0
.ie n .IP "\fB\fB$2a\fB$\fR" 4
.el .IP "\fB\f(CB$2a\fB$\fR" 4
.IX Item "$2a$"
.PD
Two versions of a passphrase scheme based on Blowfish,
designed by Niels Provos and David Mazieres for OpenBSD.  See
Authen::Passphrase::BlowfishCrypt.
.ie n .IP "\fB\fB$3\fB$\fR" 4
.el .IP "\fB\f(CB$3\fB$\fR" 4
.IX Item "$3$"
The NT-Hash scheme, which stores the \s-1MD4\s0 hash of the passphrase expressed
in Unicode.  See Authen::Passphrase::NTHash.
.ie n .IP "\fB\fB$IPB2\fB$\fR" 4
.el .IP "\fB\f(CB$IPB2\fB$\fR" 4
.IX Item "$IPB2$"
Invision Power Board 2.x salted \s-1MD5\s0
.ie n .IP "\fB\fB$K4\fB$\fR" 4
.el .IP "\fB\f(CB$K4\fB$\fR" 4
.IX Item "$K4$"
Kerberos \s-1AFS\s0 \s-1DES\s0
.ie n .IP "\fB\fB$LM\fB$\fR" 4
.el .IP "\fB\f(CB$LM\fB$\fR" 4
.IX Item "$LM$"
Half of the Microsoft \s-1LAN\s0 Manager hash scheme.  The two
halves of a \s-1LAN\s0 Manager hash can be separated and manipulated
independently; this represents such an isolated half.  See
Authen::Passphrase::LANManagerHalf.
.ie n .IP "\fB\fB$NT\fB$\fR" 4
.el .IP "\fB\f(CB$NT\fB$\fR" 4
.IX Item "$NT$"
The NT-Hash scheme, which stores the \s-1MD4\s0 hash of the passphrase expressed
in Unicode.  See Authen::Passphrase::NTHash.
.Sp
The \fB\f(CB$3\fB$\fR identifier refers to the same hash algorithm, but has a
slightly different textual format (an extra "\fB$\fR").
.ie n .IP "\fB\fB$P\fB$\fR" 4
.el .IP "\fB\f(CB$P\fB$\fR" 4
.IX Item "$P$"
Portable \s-1PHP\s0 password hash (phpass), based on \s-1MD5\s0.  See
Authen::Passphrase::PHPass.
.ie n .IP "\fB\fB$VMS1\fB$\fR" 4
.el .IP "\fB\f(CB$VMS1\fB$\fR" 4
.IX Item "$VMS1$"
.PD 0
.ie n .IP "\fB\fB$VMS2\fB$\fR" 4
.el .IP "\fB\f(CB$VMS2\fB$\fR" 4
.IX Item "$VMS2$"
.ie n .IP "\fB\fB$VMS3\fB$\fR" 4
.el .IP "\fB\f(CB$VMS3\fB$\fR" 4
.IX Item "$VMS3$"
.PD
Three variants of the Purdy polynomial system used in \s-1VMS\s0.
See Authen::Passphrase::VMSPurdy.
.ie n .IP "\fB\fB$af\fB$\fR" 4
.el .IP "\fB\f(CB$af\fB$\fR" 4
.IX Item "$af$"
Kerberos v4 \s-1TGT\s0
.ie n .IP "\fB\fB$apr1\fB$\fR" 4
.el .IP "\fB\f(CB$apr1\fB$\fR" 4
.IX Item "$apr1$"
A variant of the \fB\f(CB$1\fB$\fR scheme, used by Apache.
.ie n .IP "\fB\fB$krb5\fB$\fR" 4
.el .IP "\fB\f(CB$krb5\fB$\fR" 4
.IX Item "$krb5$"
Kerberos v5 \s-1TGT\s0
.RE
.RS 4
.Sp
The historical formats supported are:
.ie n .IP """\fIbbbbbbbbbbbbb\fR""" 4
.el .IP "``\fIbbbbbbbbbbbbb\fR''" 4
.IX Item """bbbbbbbbbbbbb"""
("\fIb\fR" represents a base 64 digit.)  The original DES-based Unix password
hash scheme.  See Authen::Passphrase::DESCrypt.
.ie n .IP """\fB_\fR\fIbbbbbbbbbbbbbbbbbbb\fR""" 4
.el .IP "``\fB_\fR\fIbbbbbbbbbbbbbbbbbbb\fR''" 4
.IX Item """_bbbbbbbbbbbbbbbbbbb"""
("\fIb\fR" represents a base 64 digit.)  Extended DES-based passphrase hash
scheme from BSDi.  See Authen::Passphrase::DESCrypt.
.ie n .IP """""" 4
.el .IP "``''" 4
Accept any passphrase.  See Authen::Passphrase::AcceptAll.
.ie n .IP """\fB*\fR""" 4
.el .IP "``\fB*\fR''" 4
.IX Item """*"""
To handle historical practice, anything non-empty but shorter than 13
characters and not starting with "\fB$\fR" is treated as deliberately
rejecting all passphrases.  (See Authen::Passphrase::RejectAll.)
Anything 13 characters or longer, or starting with "\fB$\fR", that is not
recognised as a hash is treated as an error.
.RE
.RS 4
.Sp
There are also two different passphrase schemes that use a crypt string
consisting of 24 base 64 digits.  One is named \*(L"bigcrypt\*(R" and appears in
HP-UX, Digital Unix, and \s-1OSF/1\s0 (see Authen::Passphrase::BigCrypt).
The other is named \*(L"crypt16\*(R" and appears in Ultrix and Tru64 (see
Authen::Passphrase::Crypt16).  These schemes conflict.  Neither of
them is accepted as a crypt string by this constructor; such strings
are regarded as invalid encodings.
.RE
.IP "Authen::Passphrase\->from_rfc2307(\s-1USERPASSWORD\s0)" 4
.IX Item "Authen::Passphrase->from_rfc2307(USERPASSWORD)"
Returns a passphrase recogniser object matching the supplied \s-1RFC\s0 2307
encoding.  This constructor may only be called on the base class, not
any subclass.
.Sp
The specific passphrase recogniser class is loaded at runtime.  See the
note about this for the \*(L"from_crypt\*(R" constructor above.
.Sp
Known scheme identifiers:
.RS 4
.IP "\fB{\s-1CLEARTEXT\s0}\fR" 4
.IX Item "{CLEARTEXT}"
Passphrase stored in cleartext.  See Authen::Passphrase::Clear.
.IP "\fB{\s-1CRYPT\s0}\fR" 4
.IX Item "{CRYPT}"
The scheme identifier is followed by a crypt string.
.IP "\fB{\s-1CRYPT16\s0}\fR" 4
.IX Item "{CRYPT16}"
Used ambiguously by Exim, to refer to either crypt16
(see Authen::Passphrase::Crypt16) or bigcrypt (see
Authen::Passphrase::BigCrypt) depending on compilation options.
This is a bug, resulting from a confusion between the two algorithms.
This module does not support any meaning for this scheme identifier.
.IP "\fB{K5KEY}\fR" 4
.IX Item "{K5KEY}"
Not a real passphrase scheme, but a placeholder to indicate that a
Kerberos key stored separately should be checked against.  No data
follows the scheme identifier.
.IP "\fB{\s-1KERBEROS\s0}\fR" 4
.IX Item "{KERBEROS}"
Not a real passphrase scheme, but a placeholder to indicate that
Kerberos should be invoked to check against a user's passphrase.
The scheme identifier is followed by the user's username, in the form
"\fIname\fR\fB@\fR\fIrealm\fR".
.IP "\fB{\s-1LANM\s0}\fR" 4
.IX Item "{LANM}"
Synonym for \fB{\s-1LANMAN\s0}\fR, used by CommuniGate Pro.
.IP "\fB{\s-1LANMAN\s0}\fR" 4
.IX Item "{LANMAN}"
The Microsoft \s-1LAN\s0 Manager hash scheme.  See
Authen::Passphrase::LANManager.
.IP "\fB{\s-1MD4\s0}\fR" 4
.IX Item "{MD4}"
The \s-1MD4\s0 digest of the passphrase is stored.  See
Authen::Passphrase::SaltedDigest.
.IP "\fB{\s-1MD5\s0}\fR" 4
.IX Item "{MD5}"
The \s-1MD5\s0 digest of the passphrase is stored.  See
Authen::Passphrase::SaltedDigest.
.IP "\fB{\s-1MSNT\s0}\fR" 4
.IX Item "{MSNT}"
The NT-Hash scheme, which stores the \s-1MD4\s0 hash of the passphrase expressed
in Unicode.  See Authen::Passphrase::NTHash.
.IP "\fB{\s-1NS\-MTA\-MD5\s0}\fR" 4
.IX Item "{NS-MTA-MD5}"
An MD5\-based scheme used by Netscape Mail Server.  See
Authen::Passphrase::NetscapeMail.
.IP "\fB{\s-1RMD160\s0}\fR" 4
.IX Item "{RMD160}"
The \s-1RIPEMD\-160\s0 digest of the passphrase is stored.  See
Authen::Passphrase::SaltedDigest.
.IP "\fB{\s-1SASL\s0}\fR" 4
.IX Item "{SASL}"
Not a real passphrase scheme, but a placeholder to indicate that \s-1SASL\s0
should be invoked to check against a user's passphrase.  The scheme
identifier is followed by the user's username.
.IP "\fB{\s-1SHA\s0}\fR" 4
.IX Item "{SHA}"
The \s-1SHA\-1\s0 digest of the passphrase is stored.  See
Authen::Passphrase::SaltedDigest.
.IP "\fB{\s-1SMD5\s0}\fR" 4
.IX Item "{SMD5}"
The \s-1MD5\s0 digest of the passphrase plus a salt is stored.  See
Authen::Passphrase::SaltedDigest.
.IP "\fB{\s-1SSHA\s0}\fR" 4
.IX Item "{SSHA}"
The \s-1SHA\-1\s0 digest of the passphrase plus a salt is stored.
See Authen::Passphrase::SaltedDigest.
.IP "\fB{\s-1UNIX\s0}\fR" 4
.IX Item "{UNIX}"
Not a real passphrase scheme, but a placeholder to indicate that Unix
mechanisms should be used to check against a Unix user's login passphrase.
The scheme identifier is followed by the user's username.
.IP "\fB{\s-1WM\-CRY\s0}\fR" 4
.IX Item "{WM-CRY}"
Synonym for \fB{\s-1CRYPT\s0}\fR, used by CommuniGate Pro.
.RE
.RS 4
.RE
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ppr\->match(\s-1PASSPHRASE\s0)" 4
.el .IP "\f(CW$ppr\fR\->match(\s-1PASSPHRASE\s0)" 4
.IX Item "$ppr->match(PASSPHRASE)"
Checks whether the supplied passphrase is correct.  Returns a truth value.
.ie n .IP "$ppr\->passphrase" 4
.el .IP "\f(CW$ppr\fR\->passphrase" 4
.IX Item "$ppr->passphrase"
If a matching passphrase can be easily determined by the passphrase
recogniser then this method will return it.  This is only feasible for
very weak passphrase schemes.  The method \f(CW\*(C`die\*(C'\fRs if it is infeasible.
.ie n .IP "$ppr\->as_crypt" 4
.el .IP "\f(CW$ppr\fR\->as_crypt" 4
.IX Item "$ppr->as_crypt"
Encodes the passphrase recogniser in crypt format and returns the encoded
result.  \f(CW\*(C`die\*(C'\fRs if the passphrase recogniser cannot be represented in
this form.
.ie n .IP "$ppr\->as_rfc2307" 4
.el .IP "\f(CW$ppr\fR\->as_rfc2307" 4
.IX Item "$ppr->as_rfc2307"
Encodes the passphrase recogniser in \s-1RFC\s0 2307 format and returns
the encoded result.  \f(CW\*(C`die\*(C'\fRs if the passphrase recogniser cannot be
represented in this form.
.SH "SUBCLASSING"
.IX Header "SUBCLASSING"
This class is designed to be subclassed, and cannot be instantiated alone.
Any subclass must implement the \*(L"match\*(R" method.  That is the minimum
required.
.PP
Subclasses should implement the \*(L"as_crypt\*(R" and \*(L"as_rfc2307\*(R" methods
and the \*(L"from_crypt\*(R" and \*(L"from_rfc2307\*(R" constructors wherever
appropriate, with the following exception.  If a passphrase scheme has
a crypt encoding but no native \s-1RFC\s0 2307 encoding, so it can be \s-1RFC\s0 2307
encoded only by using the "\fB{\s-1CRYPT\s0}\fR" scheme, then \*(L"as_rfc2307\*(R" and
\&\*(L"from_rfc2307\*(R" should \fInot\fR be implemented by the class.  There is a
default implementation of the \*(L"as_rfc2307\*(R" method that uses "\fB{\s-1CRYPT\s0}\fR"
and \*(L"as_crypt\*(R", and a default implementation of the \*(L"from_rfc2307\*(R"
method that recognises "\fB{\s-1CRYPT\s0}\fR" and passes the embedded crypt string
to the \*(L"from_crypt\*(R" constructor.
.PP
Implementation of the \*(L"passphrase\*(R" method is entirely optional.
It should be attempted only for schemes that are so ludicrously weak as
to allow passphrases to be cracked reliably in a short time.  Dictionary
attacks are not appropriate implementations.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MooseX::Types::Authen::Passphrase,
\&\fIcrypt\fR\|(3),
\&\s-1RFC\s0 2307
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
