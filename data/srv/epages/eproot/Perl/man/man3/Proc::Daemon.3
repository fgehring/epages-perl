.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Proc::Daemon 3"
.TH Proc::Daemon 3 "2011-06-03" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Proc::Daemon \- Run Perl program(s) as a daemon process.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Proc::Daemon;
\&
\&    $daemon = Proc::Daemon\->new(
\&        work_dir => \*(Aq/my/daemon/directory\*(Aq,
\&        .....
\&    );
\&
\&    $Kid_1_PID = $daemon\->Init;
\&
\&    unless ( $Kid_1_PID ) {
\&        # code executed only by the child ...
\&    }
\&
\&    $Kid_2_PID = $daemon\->Init( { 
\&                    work_dir     => \*(Aq/other/daemon/directory\*(Aq,
\&                    exec_command => \*(Aqperl /home/my_script.pl\*(Aq,
\&                 } );
\&
\&    $pid = $daemon\->Status( ... );
\&
\&    $stopped = $daemon\->Kill_Daemon( ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module can be used by a Perl program to initialize itself as a daemon
or to execute (\f(CW\*(C`exec\*(C'\fR) a system command as daemon. You can also check the status
of the daemon (alive or dead) and you can kill the daemon.
.PP
A daemon is a process that runs in the background with no controlling
terminal. Generally servers (like \s-1FTP\s0, \s-1HTTP\s0 and \s-1SIP\s0 servers) run as daemon
processes. Do not make the mistake to think that a daemon is a server. ;\-)
.PP
Proc::Daemon does the following:
.IP "1." 4
The script forks a child.
.IP "2." 4
The child changes the current working directory to
the value of 'work_dir'.
.IP "3." 4
The child clears the file creation mask.
.IP "4." 4
The child becomes a session leader, which detaches the program from the
controlling terminal.
.IP "5." 4
The child forks another child (the final daemon process). This prevents
the potential of acquiring a controlling terminal at all and detaches the
daemon completely from the first parent.
.IP "6." 4
The second child closes all open file descriptors (unless you define
\&\f(CW\*(C`dont_close_fh\*(C'\fR and/or \f(CW\*(C`dont_close_fd\*(C'\fR).
.IP "7." 4
The second child opens \s-1STDIN\s0, \s-1STDOUT\s0 and \s-1STDERR\s0 to the location defined in the
constructor (\f(CW\*(C`new\*(C'\fR).
.IP "8." 4
The second child returns to the calling script, or the program defined
in 'exec_command' is executed and the second child never returns.
.IP "9." 4
The first child transfers the \s-1PID\s0 of the second child (daemon) to the
parent. Additionally the \s-1PID\s0 of the daemon process can be written into a file
if 'pid_file' is defined. Then the first child exits.
.IP "10." 4
If the parent script is looking for a return value, then the \s-1PID\s0(s) of the
child/ren will be returned. Otherwise the parent will exit.
.PP
\&\s-1NOTE:\s0 Because of the second fork the daemon will not be a session-leader and
therefore Signals will not be send to other members of his process group. If
you need the functionality of a session-leader you may want to call
\&\fIPOSIX::setsid()\fR manually at your daemon.
.PP
\&\s-1INFO:\s0 Since \f(CW\*(C`fork\*(C'\fR is not performed the same way on Windows systems as on
Linux, this module does not work with Windows. Patches appreciated!
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.ie n .IP "new ( %ARGS )" 4
.el .IP "new ( \f(CW%ARGS\fR )" 4
.IX Item "new ( %ARGS )"
The constructor creates a new Proc::Daemon object based on the hash \f(CW%ARGS\fR. The
following keys from \f(CW%ARGS\fR are used:
.RS 4
.IP "work_dir" 8
.IX Item "work_dir"
Defines the path to the working directory of your daemon. Defaults to \f(CW\*(C`/\*(C'\fR.
.IP "setuid" 8
.IX Item "setuid"
Sets the real user identifier (\f(CW$<\fR) and the effective user identifier
(\f(CW$>\fR) for the daemon process using \f(CW\*(C`POSIX::setuid( ... )\*(C'\fR, in case you
want to run your daemon under an other user then the parent. Obviously the
first user must have the rights to switch to the new user otherwise it will
stay the same. It is helpful to define the argument \f(CW\*(C`setuid\*(C'\fR if you start your
script at boot time by init with the superuser, but wants the daemon to run
under a normal user account.
.IP "child_STDIN" 8
.IX Item "child_STDIN"
Defines the path to \s-1STDIN\s0 for your daemon. Defaults to \f(CW\*(C`/dev/null\*(C'\fR. Default
Mode is '<' (read). You can define other Mode the same way as you do using
Perls \f(CW\*(C`open\*(C'\fR in a two-argument form.
.IP "child_STDOUT" 8
.IX Item "child_STDOUT"
Defines the path where the output of your daemon will go. Defaults to
\&\f(CW\*(C`/dev/null\*(C'\fR. Default Mode is '+>' (write/read). You can define other Mode the
same way as you do using Perls \f(CW\*(C`open\*(C'\fR in a two-argument form.
.IP "child_STDERR" 8
.IX Item "child_STDERR"
Defines the path where the error output of your daemon will go. Defaults to
\&\f(CW\*(C`/dev/null\*(C'\fR. Default Mode is '+>' (write/read). You can define other Mode the
same way as you do using Perls \f(CW\*(C`open\*(C'\fR in a two-argument form, see example
below.
.IP "dont_close_fh" 8
.IX Item "dont_close_fh"
If you define it, it must be an arrayref with file handles you want to preserve
from the parent into the child (daemon). This may be the case if you have code
below a \f(CW\*(C`_\|_DATA_\|_\*(C'\fR token in your script or module called by \f(CW\*(C`use\*(C'\fR or
\&\f(CW\*(C`require\*(C'\fR.
.Sp
.Vb 1
\&    dont_close_fh => [ \*(Aqmain::DATA\*(Aq, \*(AqPackageName::DATA\*(Aq, $my_filehandle, ... ],
.Ve
.Sp
You can add any kind of file handle to the array (expression in single quotes or
a scalar variable), including '\s-1STDIN\s0', '\s-1STDOUT\s0' and '\s-1STDERR\s0'. Logically the path
settings from above (\f(CW\*(C`child_STDIN\*(C'\fR, ...) will be ignored in this case.
.Sp
\&\s-1DISCLAIMER:\s0 Using this argument may not detach your daemon fully from the
parent! Use it at your own risk.
.IP "dont_close_fd" 8
.IX Item "dont_close_fd"
Same function and disclaimer as \f(CW\*(C`dont_close_fh\*(C'\fR, but instead of file handles
you write the numeric file descriptors inside the arrayref.
.IP "pid_file" 8
.IX Item "pid_file"
Defines the path to a file (owned by the parent user) where the \s-1PID\s0 of the
daemon process will be stored. Defaults to \f(CW\*(C`undef\*(C'\fR (= write no file).
.IP "exec_command" 8
.IX Item "exec_command"
Scalar or arrayref with system command(s) that will be executed by the
daemon via Perls \f(CW\*(C`exec PROGRAM_LIST\*(C'\fR. In this case the child will never
return to the parents process!
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 9
\&    my $daemon = Proc::Daemon\->new(
\&        work_dir     => \*(Aq/working/daemon/directory\*(Aq,
\&        child_STDOUT => \*(Aq/path/to/daemon/output.file\*(Aq,
\&        child_STDERR => \*(Aq+>>debug.txt\*(Aq,
\&        pid_file     => \*(Aqpid.txt\*(Aq,
\&        exec_command => \*(Aqperl /home/my_script.pl\*(Aq,
\&      # or:
\&      # exec_command => [ \*(Aqperl /home/my_script.pl\*(Aq, \*(Aqperl /home/my_other_script.pl\*(Aq ],
\&    );
.Ve
.Sp
In this example:
.IP "\(bu" 8
the \s-1PID\s0 of the daemon will be returned to \f(CW$daemon\fR in the parent process
and a pid-file will be created at \f(CW\*(C`/working/daemon/directory/pid.txt\*(C'\fR.
.IP "\(bu" 8
\&\s-1STDOUT\s0 will be open with Mode '+>' (write/read)
to \f(CW\*(C`/path/to/daemon/output.file\*(C'\fR and \s-1STDERR\s0 will be open
to \f(CW\*(C`/working/daemon/directory/debug.txt\*(C'\fR with Mode '+>>' (write/read opened for
appending).
.IP "\(bu" 8
the script \f(CW\*(C`/home/my_script.pl\*(C'\fR will be executed by \f(CW\*(C`perl\*(C'\fR and run as
daemon. Therefore the child process will never return to this parent script.
.RE
.RS 4
.RE
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "Init( [ { %ARGS } ] )" 4
.el .IP "Init( [ { \f(CW%ARGS\fR } ] )" 4
.IX Item "Init( [ { %ARGS } ] )"
Become a daemon.
.Sp
If used for the first time after \f(CW\*(C`new\*(C'\fR, you call \f(CW\*(C`Init\*(C'\fR with the object
reference to start the daemon.
.Sp
.Vb 1
\&    $pid = $daemon\->Init();
.Ve
.Sp
If you want to use the object reference created by \f(CW\*(C`new\*(C'\fR for other daemons,
you write \f(CW\*(C`Init( { %ARGS } )\*(C'\fR. \f(CW%ARGS\fR are the same as described in
\&\f(CW\*(C`new\*(C'\fR. Notice that you shouldn't call \f(CW\*(C`Init()\*(C'\fR without argument in this case,
or the next daemon will execute and/or write in the same files as the first
daemon. To prevent this use at least an empty anonymous hash here.
.Sp
.Vb 5
\&    $pid = $daemon\->Init( {} );
\&    @pid = $daemon\->Init( {
\&        work_dir     => \*(Aq/other/daemon/directory\*(Aq,
\&        exec_command => [ \*(Aqperl /home/my_second_script.pl\*(Aq, \*(Aqperl /home/my_third_script.pl\*(Aq ],
\&    } );
.Ve
.Sp
If you don't need the Proc::Daemon object reference in your script, you
can also use the method without object reference:
.Sp
.Vb 3
\&    $pid = Proc::Daemon::Init();
\&    # or
\&    $pid = Proc::Daemon::Init( { %ARGS } );
.Ve
.Sp
\&\f(CW\*(C`Init\*(C'\fR returns the \s-1PID\s0 (scalar) of the daemon to the parent, or the PIDs
(array) of the daemons created if \f(CW\*(C`exec_command\*(C'\fR has more then one program
to execute. See examples above.
.Sp
\&\f(CW\*(C`Init\*(C'\fR returns 0 to the child (daemon).
.Sp
If you call the \f(CW\*(C`Init\*(C'\fR method in the context without looking for a return value
(void context) the parent process will \f(CW\*(C`exit\*(C'\fR here like in earlier versions:
.Sp
.Vb 1
\&    Proc::Daemon::Init();
.Ve
.ie n .IP "Status( [ $ARG ] )" 4
.el .IP "Status( [ \f(CW$ARG\fR ] )" 4
.IX Item "Status( [ $ARG ] )"
This function checks the status of the process (daemon). Returns the \s-1PID\s0 number
(alive) or 0 (dead).
.Sp
\&\f(CW$ARG\fR can be a string with:
.RS 4
.IP "\(bu" 8
\&\f(CW\*(C`undef\*(C'\fR, in this case it tries to get the \s-1PID\s0 to check out of the object
reference settings.
.IP "\(bu" 8
a \s-1PID\s0 number to check.
.IP "\(bu" 8
the path to a file containing the \s-1PID\s0 to check.
.IP "\(bu" 8
the command line entry of the running program to check. This requires
Proc::ProcessTable to be installed.
.RE
.RS 4
.RE
.ie n .IP "Kill_Daemon( [ $ARG [, \s-1SIGNAL\s0] ] )" 4
.el .IP "Kill_Daemon( [ \f(CW$ARG\fR [, \s-1SIGNAL\s0] ] )" 4
.IX Item "Kill_Daemon( [ $ARG [, SIGNAL] ] )"
This function kills the Daemon process. Returns the number of processes
successfully killed (which mostly is not the same as the \s-1PID\s0 number), or 0 if
the process wasn't found.
.Sp
\&\f(CW$ARG\fR is the same as of \f(CW\*(C`Status()\*(C'\fR. \s-1SIGNAL\s0 is an optional signal name or number
as required by Perls \f(CW\*(C`kill\*(C'\fR function and listed out by \f(CW\*(C`kill \-l\*(C'\fR on your
system. Default value is 9 ('\s-1KILL\s0' = non-catchable, non-ignorable kill).
.IP "Fork" 4
.IX Item "Fork"
Is like the Perl built-in \f(CW\*(C`fork\*(C'\fR, but it retries to fork over 30 seconds if
necessary and if possible to fork at all. It returns the child \s-1PID\s0 to the
parent process and 0 to the child process. If the fork is unsuccessful
it \f(CW\*(C`warn\*(C'\fRs and returns \f(CW\*(C`undef\*(C'\fR.
.SH "OTHER METHODS"
.IX Header "OTHER METHODS"
Proc::Daemon also defines some other functions. See source code for more
details:
.ie n .IP "OpenMax( [ $NUMBER ] )" 4
.el .IP "OpenMax( [ \f(CW$NUMBER\fR ] )" 4
.IX Item "OpenMax( [ $NUMBER ] )"
Returns the maximum file descriptor number. If undetermined \f(CW$NUMBER\fR will be
returned.
.IP "adjust_settings" 4
.IX Item "adjust_settings"
Does some fixes/adjustments on the \f(CW\*(C`new\*(C'\fR settings together with \f(CW\*(C`fix_filename\*(C'\fR.
.ie n .IP "fix_filename( $KEYNAME )" 4
.el .IP "fix_filename( \f(CW$KEYNAME\fR )" 4
.IX Item "fix_filename( $KEYNAME )"
Prevents double use of same filename in different processes.
.ie n .IP "get_pid( [ $STRING ] )" 4
.el .IP "get_pid( [ \f(CW$STRING\fR ] )" 4
.IX Item "get_pid( [ $STRING ] )"
Returns the wanted \s-1PID\s0 if it can be found.
.ie n .IP "get_pid_by_proc_table_attr( $ATTR, $MATCH )" 4
.el .IP "get_pid_by_proc_table_attr( \f(CW$ATTR\fR, \f(CW$MATCH\fR )" 4
.IX Item "get_pid_by_proc_table_attr( $ATTR, $MATCH )"
Returns the wanted \s-1PID\s0 by looking into the process table, or \f(CW\*(C`undef\*(C'\fR. Requires
the \f(CW\*(C`Proc::ProcessTable\*(C'\fR module to be installed.
.SH "NOTES"
.IX Header "NOTES"
\&\f(CW\*(C`Proc::Daemon::init\*(C'\fR is still available for backwards capability.
.SH "AUTHORS"
.IX Header "AUTHORS"
Primary-maintainer and code writer until version 0.03:
.IP "\(bu" 4
Earl Hood, earl@earlhood.com, http://www.earlhood.com/
.PP
Co-maintainer and code writer since version 0.04:
.IP "\(bu" 4
Detlef Pilzecker, http://search.cpan.org/~deti/,
http://www.secure\-sip\-server.net/
.SH "CREDITS"
.IX Header "CREDITS"
Initial implementation of \f(CW\*(C`Proc::Daemon\*(C'\fR derived from the following sources:
.IP "\(bu" 4
\&\*(L"Advanced Programming in the \s-1UNIX\s0 Environment\*(R" by W. Richard Stevens.
Addison-Wesley, Copyright 1992.
.IP "\(bu" 4
\&\*(L"\s-1UNIX\s0 Network Programming\*(R", Vol 1, by W. Richard Stevens.
Prentice-Hall \s-1PTR\s0, Copyright 1998.
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
This module requires the \f(CW\*(C`POSIX\*(C'\fR module to be installed.
.PP
The \f(CW\*(C`Proc::ProcessTable\*(C'\fR module is not essentially required but it can be
useful if it is installed (see above).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \s-1POSIX\s0, Proc::ProcessTable
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This module is Copyright (C) 1997\-2011 by Earl Hood and Detlef Pilzecker.
.PP
All Rights Reserved.
.PP
This module is free software. It may be used, redistributed and/or modified
under the same terms as Perl itself.
