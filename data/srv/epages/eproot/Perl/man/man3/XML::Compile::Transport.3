.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::Transport 3"
.TH XML::Compile::Transport 3 "2017-01-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::Transport \- base class for XML transporters
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& XML::Compile::Transport
\&   is a XML::Compile::SOAP::Extension
\&
\& XML::Compile::Transport is extended by
\&   XML::Compile::Transport::SOAPHTTP
\&   XML::Compile::Transport::SOAPHTTP_AnyEvent
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use XML::Compile::Transport::SOAPHTTP;
\& my $trans  = XML::Compile::Transport::SOAPHTTP\->new(...);
\& my $call   = $trans\->compileClient(...);
\&
\& my ($xmlout, $trace) = $call\->($xmlin);
\& my $xmlout = $call\->($xmlin);   # when no trace needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module defines the exchange of (\s-1XML\s0) messages. The module does not
known how to parse or compose \s-1XML\s0, but only worries about the transport
aspects.
.PP
On the moment, there are three transporter implementations:
.IP "XML::Compile::Transport::SOAPHTTP" 4
.IX Item "XML::Compile::Transport::SOAPHTTP"
implements an synchronous message exchange; the library waits for an
answer before it returns to the user application. The information is
exchanged using \s-1HTTP\s0 with \s-1SOAP\s0 encapsulation (\s-1SOAP\s0 also defines a
transport protocol over \s-1HTTP\s0 without encapsulation)
.IP "XML::Compile::Transport::SOAPHTTP_AnyEvent" 4
.IX Item "XML::Compile::Transport::SOAPHTTP_AnyEvent"
Event-driven implementation, based on AnyEvent.  The user provides a
callback to handle responses. Many queries can be spawned in parallel,
in a single process.  Find this in a separate distribution.
.IP "XML::Compile::Transport::SOAPHTTP_MojoUA" 4
.IX Item "XML::Compile::Transport::SOAPHTTP_MojoUA"
Event-driven implementation,  which fits in the Mojolicious infrastructure.
Find this in a separate distribution.
.PP
Extends \*(L"\s-1DESCRIPTION\s0\*(R" in XML::Compile::SOAP::Extension.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\s0\*(R" in XML::Compile::SOAP::Extension.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in XML::Compile::SOAP::Extension.
.IP "XML::Compile::Transport\->\fBnew\fR(%options)" 4
.IX Item "XML::Compile::Transport->new(%options)"
.Vb 3
\& \-Option \-\-Default
\&  address  \*(Aqhttp://localhost\*(Aq
\&  charset  \*(Aqutf\-8\*(Aq
.Ve
.RS 4
.IP "address => URI|ARRAY\-of\-URI" 2
.IX Item "address => URI|ARRAY-of-URI"
One or more \s-1URI\s0 which represents the servers.
.IP "charset => \s-1STRING\s0" 2
.IX Item "charset => STRING"
.RE
.RS 4
.RE
.SS "\s-1WSDL11\s0"
.IX Subsection "WSDL11"
Extends \*(L"\s-1WSDL11\s0\*(R" in XML::Compile::SOAP::Extension.
.ie n .IP "$obj\->\fBwsdl11Init\fR($wsdl, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBwsdl11Init\fR($wsdl, \f(CW$args\fR)" 4
.IX Item "$obj->wsdl11Init($wsdl, $args)"
.PD 0
.ie n .IP "XML::Compile::Transport\->\fBwsdl11Init\fR($wsdl, $args)" 4
.el .IP "XML::Compile::Transport\->\fBwsdl11Init\fR($wsdl, \f(CW$args\fR)" 4
.IX Item "XML::Compile::Transport->wsdl11Init($wsdl, $args)"
.PD
Inherited, see \*(L"\s-1WSDL11\s0\*(R" in XML::Compile::SOAP::Extension
.SS "\s-1SOAP11\s0"
.IX Subsection "SOAP11"
Extends \*(L"\s-1SOAP11\s0\*(R" in XML::Compile::SOAP::Extension.
.ie n .IP "$obj\->\fBsoap11ClientWrapper\fR($operation, $call, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBsoap11ClientWrapper\fR($operation, \f(CW$call\fR, \f(CW$args\fR)" 4
.IX Item "$obj->soap11ClientWrapper($operation, $call, $args)"
Inherited, see \*(L"\s-1SOAP11\s0\*(R" in XML::Compile::SOAP::Extension
.ie n .IP "$obj\->\fBsoap11HandlerWrapper\fR($operation, $callback, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBsoap11HandlerWrapper\fR($operation, \f(CW$callback\fR, \f(CW$args\fR)" 4
.IX Item "$obj->soap11HandlerWrapper($operation, $callback, $args)"
Inherited, see \*(L"\s-1SOAP11\s0\*(R" in XML::Compile::SOAP::Extension
.ie n .IP "$obj\->\fBsoap11OperationInit\fR($operation, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBsoap11OperationInit\fR($operation, \f(CW$args\fR)" 4
.IX Item "$obj->soap11OperationInit($operation, $args)"
.PD 0
.ie n .IP "XML::Compile::Transport\->\fBsoap11OperationInit\fR($operation, $args)" 4
.el .IP "XML::Compile::Transport\->\fBsoap11OperationInit\fR($operation, \f(CW$args\fR)" 4
.IX Item "XML::Compile::Transport->soap11OperationInit($operation, $args)"
.PD
Inherited, see \*(L"\s-1SOAP11\s0\*(R" in XML::Compile::SOAP::Extension
.SS "\s-1SOAP12\s0"
.IX Subsection "SOAP12"
Extends \*(L"\s-1SOAP12\s0\*(R" in XML::Compile::SOAP::Extension.
.ie n .IP "$obj\->\fBsoap12ClientWrapper\fR($operation, $call, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBsoap12ClientWrapper\fR($operation, \f(CW$call\fR, \f(CW$args\fR)" 4
.IX Item "$obj->soap12ClientWrapper($operation, $call, $args)"
Inherited, see \*(L"\s-1SOAP12\s0\*(R" in XML::Compile::SOAP::Extension
.ie n .IP "$obj\->\fBsoap12HandlerWrapper\fR($operation, $callback, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBsoap12HandlerWrapper\fR($operation, \f(CW$callback\fR, \f(CW$args\fR)" 4
.IX Item "$obj->soap12HandlerWrapper($operation, $callback, $args)"
Inherited, see \*(L"\s-1SOAP12\s0\*(R" in XML::Compile::SOAP::Extension
.ie n .IP "$obj\->\fBsoap12OperationInit\fR($operation, $args)" 4
.el .IP "\f(CW$obj\fR\->\fBsoap12OperationInit\fR($operation, \f(CW$args\fR)" 4
.IX Item "$obj->soap12OperationInit($operation, $args)"
.PD 0
.ie n .IP "XML::Compile::Transport\->\fBsoap12OperationInit\fR($operation, $args)" 4
.el .IP "XML::Compile::Transport\->\fBsoap12OperationInit\fR($operation, \f(CW$args\fR)" 4
.IX Item "XML::Compile::Transport->soap12OperationInit($operation, $args)"
.PD
Inherited, see \*(L"\s-1SOAP12\s0\*(R" in XML::Compile::SOAP::Extension
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBaddress\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddress\fR()" 4
.IX Item "$obj->address()"
Get a server address to contact. If multiple addresses were specified,
than one is chosen at random.
.ie n .IP "$obj\->\fBaddresses\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBaddresses\fR()" 4
.IX Item "$obj->addresses()"
Returns a list of all server contact addresses (URIs)
.ie n .IP "$obj\->\fBcharset\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcharset\fR()" 4
.IX Item "$obj->charset()"
Returns the charset to be used when sending,
.SS "Handlers"
.IX Subsection "Handlers"
.ie n .IP "$obj\->\fBcompileClient\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBcompileClient\fR(%options)" 4
.IX Item "$obj->compileClient(%options)"
Compile a client handler.  Returned is a subroutine which is called
with a text represenation of the \s-1XML\s0 request, or an XML::LibXML tree.
In \s-1SCALAR\s0 context, an XML::LibXML parsed tree of the answer message
is returned.  In \s-1LIST\s0 context, that answer is followed by a \s-1HASH\s0 which
contains trace information.
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  hook        <undef>
\&  kind        \*(Aqrequest\-response\*(Aq
\&  xml_format  0
.Ve
.RS 4
.IP "hook => \s-1CODE\s0" 2
.IX Item "hook => CODE"
See section \*(L"Use of the transport hook\*(R".
When defined, the hook will be called, in stead of transmitting the
message.  The hook will gets three parameters passed in: the textual
representation of the \s-1XML\s0 message to be transmitted, the trace \s-1HASH\s0 with
all values collected so far, and the transporter object.  The trace \s-1HASH\s0
will have a massive amount of additional information added as well.
.Sp
You may add information to the trace.  You have to return a textual
representation of the \s-1XML\s0 answer, or \f(CW\*(C`undef\*(C'\fR to indicate that the
message was totally unacceptable.
.IP "kind => \s-1STRING\s0" 2
.IX Item "kind => STRING"
Kind of communication, as defined by \s-1WSDL\s0.
.IP "xml_format => 0|1|2" 2
.IX Item "xml_format => 0|1|2"
[2.26] See XML::LibXML::Document subroutine toString.  With '1', you will get
beautified output.
.RE
.RS 4
.RE
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Use of the transport hook"
.IX Subsection "Use of the transport hook"
A \fItransport hook\fR can be used to follow the process of creating a
message to its furthest extend: it will be called with the data as
used by the actual protocol, but will not connect to the internet.
Within the transport hook routine, you have to simulate the remote
server's activities.
.PP
There are two reasons to use a hook:
.IP "." 4
You want to fake a server, to produce a test environment.
.IP "." 4
You may need to modify the request or answer messages outside the
reach of XML::Compile::SOAP, because something is wrong in either
your \s-1WSDL\s0 of XML::Compile message processing.
.PP
\fI\s-1XML\s0 and Header Modifications\fR
.IX Subsection "XML and Header Modifications"
.PP
Some servers require special extensions, which do not follow any standard
(or logic). But even those features can be tricked, although it requires
quite some programming skills.
.PP
The \f(CW\*(C`transport_hook\*(C'\fR routine is called with a \f(CW$trace\fR hash, one of
whose entries is the UserAgent which was set up for the data transfer. You
can modify the outgoing message \s-1XML\s0 body and headers, carry out the data
exchange using the UserAgent, and then examine the returned Response for
content and headers using methods similar to the following:
.PP
.Vb 3
\& sub transport_hook($$$)
\& {   my ($request, $trace, $transporter) = @_;
\&     my $content = $request\->content;
\&
\&     # ... modify content if you need
\&     my $new_content = encode "utf\-8", $anything;
\&     $request\->content($new_content);
\&     $request\->header(Content_Length => length $new_content);
\&     $request\->header(Content_Type => \*(Aqtext/plain; charset=utf\-8\*(Aq);
\&
\&     # ... update the headers
\&     $request\->header(Name => "value");
\&
\&     # sent the request myself
\&     my $ua = $trace\->{user_agent};
\&     my $response = $ua\->request($request);
\&
\&     # ... check the response headers
\&     my $name = $response\->header(\*(AqName\*(Aq);
\&
\&     # ... use the response content
\&     my $received = $response\->decoded_content || $response\->content;
\&
\&     $response;
\& }
.Ve
.PP
You should be aware that if you change the size or length of the content
you \s-1MUST\s0 update the \f(CW\*(C`Content\-Length\*(C'\fR header value, as demonstrated above.
.PP
\fITransport hook for debugging\fR
.IX Subsection "Transport hook for debugging"
.PP
The transport hook is a perfect means for producing automated tests.  Also,
the XML::Compile::SOAP module tests use it extensively.  It works like this
(for the \s-1SOAPHTTP\s0 simluation):
.PP
.Vb 1
\& use Test::More;
\&
\& sub fake_server($$)
\& {  my ($request, $trace) = @_;
\&    my $content = $request\->decoded_content;
\&    is($content, <<_\|_EXPECTED_CONTENT);
\&<SOAP\-ENV:Envelope>...</SOAP\-ENV:Envelope>
\&_\|_EXPECTED_CONTENT
\&
\&    HTTP::Response\->new(200, \*(AqConstant\*(Aq
\&      , [ \*(AqContent\-Type\*(Aq => \*(Aqtext/xml\*(Aq ]
\&      , <<_\|_ANSWER
\&<SOAP\-ENV:Envelope>...</SOAP\-ENV:Envelope>
\&_\|_ANSWER
\& }
.Ve
.PP
Then, the fake server is initiated in one of the follow ways:
.PP
.Vb 3
\&  my $transport = XML::Compile::Transport::SOAPHTTP\->new(...);
\&  my $http = $transport\->compileClient(hook => \e&fake_server, ...);
\&  $wsdl\->compileClient(\*(AqGetLastTracePrice\*(Aq, transporter => $http);
.Ve
.PP
or
.PP
.Vb 3
\&  my $soap = XML::Compile::SOAP11::Client\->new(...);
\&  my $call = $soap\->compileClient(encode => ..., decode => ...,
\&      transport_hook => \e&fake_server);
.Ve
.PP
or
.PP
.Vb 3
\&  my $wsdl = XML::Compile::WSDL11\->new(...);
\&  $wsdl\->compileClient(\*(AqGetLastTracePrice\*(Aq,
\&      transport_hook => \e&fake_server);
.Ve
.PP
\fITransport hook for basic authentication\fR
.IX Subsection "Transport hook for basic authentication"
.PP
[Adapted from an example contributed by Kieron Johnson]
This example shows a transport_hook for \fIcompileClient()\fR to add to http
headers for the basic http authentication.  The parameter can also be
used for \fIcompileAll()\fR and many other related functions.
.PP
.Vb 2
\&  my $call = $wsdl\->compileClient($operation
\&     , transport_hook => \e&basic_auth );
\&
\&  # HTTP basic authentication encodes the username and password with
\&  # Base64. The encoded source string has format: "username:password"
\&  # With the below HTTP header being required:
\&  #        "Authorization: Basic [encoded password]"
\&
\&  use MIME::Base64 \*(Aqencode_base64\*(Aq;
\&
\&  my $user     = \*(Aqmyuserid\*(Aq ;
\&  my $password = \*(Aqmypassword\*(Aq;
\&
\&  sub basic_auth($$)
\&  {   my ($request, $trace) = @_;
\&
\&      # Encode userid and password
\&      my $authorization = \*(AqBasic \*(Aq. encode_base64 "$user:$password";
\&
\&      # Modify http header to include basic authorisation
\&      $request\->header(Authorization => $authorization );
\&
\&      my $ua = $trace\->{user_agent};
\&      $ua\->request($request);
\&  }
.Ve
.SH "Helpers"
.IX Header "Helpers"
.IP "XML::Compile::Transport\->\fBregister\fR($uri)" 4
.IX Item "XML::Compile::Transport->register($uri)"
Declare an transporter type.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile-SOAP distribution version 3.21,
built on January 11, 2017. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2017 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
