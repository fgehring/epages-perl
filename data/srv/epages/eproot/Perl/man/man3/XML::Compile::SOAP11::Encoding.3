.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::SOAP11::Encoding 3"
.TH XML::Compile::SOAP11::Encoding 3 "2011-06-20" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::SOAP11::Encoding \- SOAP encoding
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& ### FOR THE MOMENT UNUSABLE
\& # see t/13enc11.t in the distribution for complex examples
\&
\& my $client = XML::Compile::SOAP11::Client\->new();
\& $client\->startEncoding(...);  # loads this module
\&
\& # create: <SOAP\-ENC:int>41</SOAP\-ENC:int>
\& my $xml = $client\->enc(int => 41);
\&
\& # create: <SOAP\-ENC:int id="hhtg">42</SOAP\-ENC:int>
\& my $xml = $client\->enc(int => 42, \*(Aqhhtg\*(Aq);
\&
\& # create: <code xsi:type="xsd:int">43</code>
\& my $int = pack_type SCHEMA2001, \*(Aqint\*(Aq;
\& my $xml = $client\->typed($int, code => 43);
\&
\& # create: <ref href="#id\-1"/>  (xyz get\*(Aqs id if it hasn\*(Aqt)
\& my $xml = $client\->href(\*(Aqref\*(Aq, $xyz);
\& my $xml = $client\->href(\*(Aqref\*(Aq, $xyz, \*(Aqid\-1\*(Aq);  # explicit label
\& 
\& # create: <number>3</number>   (gets validated as well!)
\& my $xml = $client\->element($int, number => 3);
\&
\& # create one\-dimensional array of ints
\& my $xml = $client\->array(undef, $int, \e@xml);
\& my $xml = $client\->array(\*(Aq{myns}mylocal\*(Aq, $int, \e@xml);
\&
\& # create multi\-dimensional array
\& my $xml = $client\->multidim(undef, $int, $matrix);
\& my $xml = $client\->multidim(\*(Aq{myns}mylocal\*(Aq, $int, $matrix);
\&
\& # decode an incoming encoded structure (as far as possible)
\& my $hash = $client\->dec($xml);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module loads extra functionality into the XML::Compile::SOAP
namespace: all kinds of methods which are used to SOAP-encode data.
.PP
The loading is triggered by calling \fIstartEncoding()\fR.  In threaded
applications, you may wish to call that method once before the \fIfork()\fR,
such that not each threads or forked process needs to compile the
code again.  Of course, you can also \f(CW\*(C`use\*(C'\fR this package explicitly.
.SH "METHODS"
.IX Header "METHODS"
.SS "Transcoding"
.IX Subsection "Transcoding"
\fIEncoding\fR
.IX Subsection "Encoding"
.ie n .IP "$obj\->\fBarray\fR((NAME|undef), \s-1ITEM_TYPE\s0, ARRAY-of-ELEMENTS, \s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBarray\fR((NAME|undef), \s-1ITEM_TYPE\s0, ARRAY-of-ELEMENTS, \s-1OPTIONS\s0)" 4
.IX Item "$obj->array((NAME|undef), ITEM_TYPE, ARRAY-of-ELEMENTS, OPTIONS)"
Arrays can be a mess: a mixture of anything and nothing.  Therefore,
you have to help the generation more than you may wish for.  This
method produces an one dimensional array, \fImultidim()\fR is used for
multi-dimensional arrays.
.Sp
The \s-1NAME\s0 is the packed type of the array itself.  When undef,
the \f(CW\*(C`{soap\-enc\-ns}Array\*(C'\fR will be used (the action soap
encoding namespace will be used).
.Sp
The \s-1ITEM_TYPE\s0 specifies the type of each element within the array.
This type is used to create the \f(CW\*(C`arrayType\*(C'\fR attribute, however
doesn't tell enough about the items themselves: they may be
extensions to that type.
.Sp
Each of the \s-1ELEMENTS\s0 must be an XML::LibXML::Node, either
self-constructed, or produced by one of the builder methods in
this class, like \fIenc()\fR or \fItyped()\fR.
.Sp
Returned is the XML::LibXML::Element which represents the
array.
.Sp
.Vb 6
\& \-Option      \-\-Default
\&  array_type    <generated>
\&  id            <undef>
\&  nested_array  \*(Aq\*(Aq
\&  offset        0
\&  slice         <all remaining>
.Ve
.RS 4
.IP "array_type => \s-1STRING\s0" 2
.IX Item "array_type => STRING"
The arrayType attribute content.  When explicitly set to undef, the
attribute is not created.
.IP "id => \s-1STRING\s0" 2
.IX Item "id => STRING"
Assign an id to the array.  If not defined, than no id attribute is
added.
.IP "nested_array => \s-1STRING\s0" 2
.IX Item "nested_array => STRING"
The \s-1ARRAY\s0 type should reflect nested array structures if they are
homogeneous.  This is a really silly part of the specs, because there
is no need for it on any other comparible place in the specs... but ala.
.Sp
For instance: \f(CW\*(C`nested_array => \*(Aq[,]\*(Aq\*(C'\fR, means that this array
contains two-dimensional arrays.
.IP "offset => \s-1INTEGER\s0" 2
.IX Item "offset => INTEGER"
When a partial array is to be transmitted, the number of the base
element.
.IP "slice => \s-1INTEGER\s0" 2
.IX Item "slice => INTEGER"
When a partial array is to be transmitted, this is the length of
the slice to be sent (the number of elements starting with the \f(CW\*(C`offset\*(C'\fR
element)
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBelement\fR(\s-1TYPE\s0, \s-1NAME\s0, \s-1VALUE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBelement\fR(\s-1TYPE\s0, \s-1NAME\s0, \s-1VALUE\s0)" 4
.IX Item "$obj->element(TYPE, NAME, VALUE)"
Create an element.  The \s-1NAME\s0 is for node, where a namespace component
is translated into a prefix.  When you wish for a \f(CW\*(C`type\*(C'\fR attribute,
use \fItyped()\fR.
.Sp
When the \s-1TYPE\s0 does not contain a namespace indication, it is taken
in the selected schema namespace.  If the \s-1VALUE\s0 already is a
XML::LibXML::Element, then that one is used (and the \s-1NAME\s0 ignored).
.ie n .IP "$obj\->\fBenc\fR(\s-1LOCAL\s0, \s-1VALUE\s0, [\s-1ID\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBenc\fR(\s-1LOCAL\s0, \s-1VALUE\s0, [\s-1ID\s0])" 4
.IX Item "$obj->enc(LOCAL, VALUE, [ID])"
In the \s-1SOAP\s0 specification, encoding types are defined: elements
which do not have a distinguishable name but use the type of the
data as name.  Yep, ugly!
.Sp
example:
.Sp
.Vb 4
\&  my $xml = $soap\->enc(\*(Aqint\*(Aq, 43);
\&  my $xml = $soap\->enc(int => 43);
\&  print $xml\->toString;
\&    # <SOAP\-ENC:int>43</SOAP\-ENC:int>
\&
\&  my $xml = $soap\->enc(\*(Aqint\*(Aq, 42, id => \*(Aqme\*(Aq);
\&  my $xml = $soap\->enc(int => 42, id => \*(Aqme\*(Aq);
\&  print $xml\->toString;
\&    # <SOAP\-ENC:int id="me">42</SOAP\-ENC:int>
.Ve
.ie n .IP "$obj\->\fBencAddNamespace\fR(\s-1PAIRS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBencAddNamespace\fR(\s-1PAIRS\s0)" 4
.IX Item "$obj->encAddNamespace(PAIRS)"
Convenience alternative for \fIencAddNamespaces()\fR.
.ie n .IP "$obj\->\fBencAddNamespaces\fR(\s-1PAIRS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBencAddNamespaces\fR(\s-1PAIRS\s0)" 4
.IX Item "$obj->encAddNamespaces(PAIRS)"
Add prefix definitions for this one encoding cyclus.  Each time
\&\fIstartEncoding()\fR is called, the table is reset.  The namespace
table is returned.
.ie n .IP "$obj\->\fBhref\fR(\s-1NAME\s0, \s-1ELEMENT\s0, [\s-1ID\s0])" 4
.el .IP "\f(CW$obj\fR\->\fBhref\fR(\s-1NAME\s0, \s-1ELEMENT\s0, [\s-1ID\s0])" 4
.IX Item "$obj->href(NAME, ELEMENT, [ID])"
Create a reference element with \s-1NAME\s0 to the existing \s-1ELEMENT\s0.  When the
\&\s-1ELEMENT\s0 does not have an \*(L"id\*(R" attribute yet, then \s-1ID\s0 will be used.  In
case not \s-1ID\s0 was specified, then one is generated.
.ie n .IP "$obj\->\fBmultidim\fR((NAME|undef), \s-1ITEM_TYPE\s0, ARRAY-of-ELEMENTS, \s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBmultidim\fR((NAME|undef), \s-1ITEM_TYPE\s0, ARRAY-of-ELEMENTS, \s-1OPTIONS\s0)" 4
.IX Item "$obj->multidim((NAME|undef), ITEM_TYPE, ARRAY-of-ELEMENTS, OPTIONS)"
A multi-dimensional array, less flexible than a single dimensional
array, which can be created with \fIarray()\fR.
.Sp
The array must be square: in each of the dimensions, the length of
each row must be the same.  On the other hand, it may be sparse
(contain undefs).  The size of each dimension is determined by the
length of its first element.
.Sp
.Vb 2
\& \-Option\-\-Default
\&  id      undef
.Ve
.RS 4
.IP "id => \s-1STRING\s0" 2
.IX Item "id => STRING"
.RE
.RS 4
.RE
.PD 0
.ie n .IP "$obj\->\fBnil\fR([\s-1TYPE\s0], \s-1NAME\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBnil\fR([\s-1TYPE\s0], \s-1NAME\s0)" 4
.IX Item "$obj->nil([TYPE], NAME)"
.PD
Create an element with \s-1NAME\s0 which explicitly has the \f(CW\*(C`xsi:nil\*(C'\fR attribute.
If the \s-1NAME\s0 is full (has a namespace to it), it will be translated into
a \s-1QNAME\s0, otherwise, it is considered not namespace qualified.
.Sp
If a \s-1TYPE\s0 is given, then an explicit type parameter is added.
.ie n .IP "$obj\->\fBprefixed\fR(TYPE|(\s-1NAMESPACE\s0,LOCAL))" 4
.el .IP "\f(CW$obj\fR\->\fBprefixed\fR(TYPE|(\s-1NAMESPACE\s0,LOCAL))" 4
.IX Item "$obj->prefixed(TYPE|(NAMESPACE,LOCAL))"
Translate a NAMESPACE-LOCAL combination (which may be represented as
a packed \s-1TYPE\s0) into a prefixed notation.
.Sp
The complication is that the \s-1NAMESPACE\s0 may not naturally have a prefixed
assigned to it: the produced \s-1SOAP\s0 message is the result of compilation,
and only the namespaces which are registered to be used during compile-time
are added to the list on the top-level.
.ie n .IP "$obj\->\fBstartEncoding\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstartEncoding\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->startEncoding(OPTIONS)"
This needs to be called before any encoding routine, because it
initializes the internals.  Each call will reset all compiled
cached translator routines.
.Sp
When you use the standard RPC-encoded interface, this will be
called for you.
.Sp
.Vb 4
\& \-Option    \-\-Default
\&  doc         <required>
\&  namespaces  {}
\&  prefixes    {}
.Ve
.RS 4
.IP "doc => XML::LibXML::Document" 2
.IX Item "doc => XML::LibXML::Document"
.PD 0
.IP "namespaces => HASH|ARRAY" 2
.IX Item "namespaces => HASH|ARRAY"
.PD
Pre release 0.74 name for option \f(CW\*(C`prefixes\*(C'\fR.
.IP "prefixes => HASH|ARRAY" 2
.IX Item "prefixes => HASH|ARRAY"
Like XML::Compile::Schema::compile(prefixes), this can
be a \s-1HASH\s0 (see example) or an \s-1ARRAY\s0 with prefix-uri pairs.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\& my %ns;
\& $ns{$MYNS} = {uri => $MYNS, prefix => \*(Aqm\*(Aq};
\& $soap\->startEncoding(doc => $doc, prefixes => \e%ns);
\&
\& # or
\& $soap\->startEncoding(doc => $doc, prefixes => [ m => $MYNS ]);
.Ve
.RE
.ie n .IP "$obj\->\fBstruct\fR(\s-1TYPE\s0, \s-1CHILDS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstruct\fR(\s-1TYPE\s0, \s-1CHILDS\s0)" 4
.IX Item "$obj->struct(TYPE, CHILDS)"
Create a structure, an element with childs.  The \s-1CHILDS\s0 must be fully
prepared XML::LibXML::Element objects.
.ie n .IP "$obj\->\fBtyped\fR(\s-1TYPE\s0, \s-1NAME\s0, \s-1VALUE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBtyped\fR(\s-1TYPE\s0, \s-1NAME\s0, \s-1VALUE\s0)" 4
.IX Item "$obj->typed(TYPE, NAME, VALUE)"
A \*(L"typed\*(R" element shows its type explicitly, via the \*(L"xsi:type\*(R" attribute.
The \s-1VALUE\s0 will get processed via an auto-generated XML::Compile writer,
so validated.  The processing is cashed.
.Sp
When \s-1VALUE\s0 already is an XML::LibXML::Element, then no processing
nor value checking will be performed.  The \s-1NAME\s0 will be ignored.
.Sp
If the \s-1TYPE\s0 is not qualified, then it is interpreted as basic type, as
defined by the selected schema.  If you explicitly
need a non-namespace typed item, then use an empty namespace.  In any
case, the type must be defined and the value is validated.
.Sp
example:
.Sp
.Vb 2
\& my $xml = $soap\->typed(int => count => 5);
\& my $xml = $soap\->typed(pack_type(SCHEMA1999, \*(Aqint\*(Aq), count => 5);
\&
\& my $xml = $soap\->typed(pack_type(\*(Aq\*(Aq, \*(Aqmine\*(Aq), a => 1);
\& my $xml = $soap\->typed(\*(Aq{}mine\*(Aq), a => 1); #same
.Ve
.PP
\fIDecoding\fR
.IX Subsection "Decoding"
.ie n .IP "$obj\->\fBdec\fR(\s-1XMLNODES\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdec\fR(\s-1XMLNODES\s0)" 4
.IX Item "$obj->dec(XMLNODES)"
Decode the \s-1XMLNODES\s0 (list of XML::LibXML::Element objects).  Use
Data::Dumper to figure-out what the produced output is: it is a guess,
so may not be perfect (do not use \s-1RPC\s0 but document style soap for
good results).
.Sp
The decoded data is returned.  When startDecoding(simplify) is true,
then the returned data is compact but may be sloppy.  Otherwise,
a \s-1HASH\s0 is returned containing as much info as could be extracted from
the tree.
.ie n .IP "$obj\->\fBdecSimplify\fR(\s-1TREE\s0, \s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBdecSimplify\fR(\s-1TREE\s0, \s-1OPTIONS\s0)" 4
.IX Item "$obj->decSimplify(TREE, OPTIONS)"
Simplify the \s-1TREE\s0 of output produced by \fIdec()\fR to contain only
data.  Of course, this will remove useful information.
.Sp
From each of the HASHes in the tree, the \f(CW\*(C`_NAME\*(C'\fR, \f(CW\*(C`_TYPE\*(C'\fR, \f(CW\*(C`id\*(C'\fR,
and any/anyAttribute fields are removed.  If only a \f(CW\*(C`_\*(C'\fR is left over,
that related value will replace the \s-1HASH\s0 as a whole.
.ie n .IP "$obj\->\fBstartDecoding\fR(\s-1OPTIONS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBstartDecoding\fR(\s-1OPTIONS\s0)" 4
.IX Item "$obj->startDecoding(OPTIONS)"
Each call to this method will restart the cache of the decoding
internals.
.Sp
Currently \fBnot supported\fR, is the automatic decoding of elements which
\&\fIinherit\fR from \f(CW\*(C`SOAP\-ENC:Array\*(C'\fR.  If you encounter these, you have to
play with hooks.
.Sp
.Vb 3
\& \-Option     \-\-Default
\&  reader_opts  {}
\&  simplify     <false>
.Ve
.RS 4
.IP "reader_opts => \s-1HASH\s0" 2
.IX Item "reader_opts => HASH"
Extend or overrule the default reader options.  Available options
are shown in \fIXML::Compile::Schema::compile()\fR.
.IP "simplify => \s-1BOOLEAN\s0" 2
.IX Item "simplify => BOOLEAN"
Call \fIdecSimplify()\fR automatically at the end of \fIdec()\fR, so producing
an easily accessible output tree.
.RE
.RS 4
.RE
.PP
\&\s-1SOAP\s0 defines encodings, especially for SOAP-RPC.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile-SOAP distribution version 2.24,
built on June 20, 2011. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Other distributions in this suite:
XML::Compile,
XML::Compile::SOAP,
XML::Compile::SOAP12,
XML::Compile::SOAP::Daemon,
XML::Compile::SOAP::WSA,
XML::Compile::C14N,
XML::Compile::WSS,
XML::Compile::Tester,
XML::Compile::Cache,
XML::Compile::Dumper,
XML::Compile::RPC,
XML::Rewrite,
XML::eXistDB,
and
XML::LibXML::Simple.
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2011 by Mark Overmeer. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
