.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Entropy::RawSource::CryptCounter 3"
.TH Data::Entropy::RawSource::CryptCounter 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Entropy::RawSource::CryptCounter \- counter mode of block cipher
as I/O handle
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Data::Entropy::RawSource::CryptCounter;
\&
\&        my $rawsrc = Data::Entropy::RawSource::CryptCounter
\&                        \->new(Crypt::Rijndael\->new($key));
\&
\&        $c = $rawsrc\->getc;
\&        # and the rest of the I/O handle interface
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides an I/O handle connected to a virtual file which
contains the output of a block cipher in counter mode.  This makes a
good source of pseudorandom bits.  The handle implements a substantial
subset of the interfaces described in IO::Handle and IO::Seekable.
.PP
For use as a general entropy source, it is recommended to wrap an object
of this class using \f(CW\*(C`Data::Entropy::Source\*(C'\fR, which provides methods to
extract entropy in more convenient forms than mere octets.
.PP
The amount of entropy the virtual file actually contains is only the
amount that is in the key, which is at most the length of the key.
It superficially appears to be much more than this, if (and to the
extent that) the block cipher is secure.  This technique is not
suitable for all problems, and requires a careful choice of block
cipher and keying method.  Applications requiring true entropy
should generate it (see Data::Entropy::RawSource::Local) or
download it (see Data::Entropy::RawSource::RandomnumbersInfo and
Data::Entropy::RawSource::RandomOrg).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Data::Entropy::RawSource::CryptCounter\->new(\s-1KEYED_CIPHER\s0)" 4
.IX Item "Data::Entropy::RawSource::CryptCounter->new(KEYED_CIPHER)"
\&\s-1KEYED_CIPHER\s0 must be a cipher object supporting the standard \f(CW\*(C`blocksize\*(C'\fR
and \f(CW\*(C`encrypt\*(C'\fR methods.  For example, an instance of \f(CW\*(C`Crypt::Rijndael\*(C'\fR
(with the default \f(CW\*(C`MODE_ECB\*(C'\fR) would be appropriate.  A handle object
is created and returned which refers to a virtual file containing the
output of the cipher's counter mode.
.SH "METHODS"
.IX Header "METHODS"
A subset of the interfaces described in IO::Handle and IO::Seekable
are provided:
.ie n .IP "$rawsrc\->read(\s-1BUFFER\s0, LENGTH[, \s-1OFFSET\s0])" 4
.el .IP "\f(CW$rawsrc\fR\->read(\s-1BUFFER\s0, LENGTH[, \s-1OFFSET\s0])" 4
.IX Item "$rawsrc->read(BUFFER, LENGTH[, OFFSET])"
.PD 0
.ie n .IP "$rawsrc\->getc" 4
.el .IP "\f(CW$rawsrc\fR\->getc" 4
.IX Item "$rawsrc->getc"
.ie n .IP "$rawsrc\->ungetc(\s-1ORD\s0)" 4
.el .IP "\f(CW$rawsrc\fR\->ungetc(\s-1ORD\s0)" 4
.IX Item "$rawsrc->ungetc(ORD)"
.ie n .IP "$rawsrc\->eof" 4
.el .IP "\f(CW$rawsrc\fR\->eof" 4
.IX Item "$rawsrc->eof"
.PD
Buffered reading from the source, as in IO::Handle.
.ie n .IP "$rawsrc\->sysread(\s-1BUFFER\s0, LENGTH[, \s-1OFFSET\s0])" 4
.el .IP "\f(CW$rawsrc\fR\->sysread(\s-1BUFFER\s0, LENGTH[, \s-1OFFSET\s0])" 4
.IX Item "$rawsrc->sysread(BUFFER, LENGTH[, OFFSET])"
Unbuffered reading from the source, as in IO::Handle.
.ie n .IP "$rawsrc\->close" 4
.el .IP "\f(CW$rawsrc\fR\->close" 4
.IX Item "$rawsrc->close"
Does nothing.
.ie n .IP "$rawsrc\->opened" 4
.el .IP "\f(CW$rawsrc\fR\->opened" 4
.IX Item "$rawsrc->opened"
Retruns true to indicate that the source is available for I/O.
.ie n .IP "$rawsrc\->clearerr" 4
.el .IP "\f(CW$rawsrc\fR\->clearerr" 4
.IX Item "$rawsrc->clearerr"
.PD 0
.ie n .IP "$rawsrc\->error" 4
.el .IP "\f(CW$rawsrc\fR\->error" 4
.IX Item "$rawsrc->error"
.PD
Error handling, as in IO::Handle.
.ie n .IP "$rawsrc\->getpos" 4
.el .IP "\f(CW$rawsrc\fR\->getpos" 4
.IX Item "$rawsrc->getpos"
.PD 0
.ie n .IP "$rawsrc\->setpos(\s-1POS\s0)" 4
.el .IP "\f(CW$rawsrc\fR\->setpos(\s-1POS\s0)" 4
.IX Item "$rawsrc->setpos(POS)"
.ie n .IP "$rawsrc\->tell" 4
.el .IP "\f(CW$rawsrc\fR\->tell" 4
.IX Item "$rawsrc->tell"
.ie n .IP "$rawsrc\->seek(\s-1POS\s0, \s-1WHENCE\s0)" 4
.el .IP "\f(CW$rawsrc\fR\->seek(\s-1POS\s0, \s-1WHENCE\s0)" 4
.IX Item "$rawsrc->seek(POS, WHENCE)"
.PD
Move around within the buffered source, as in IO::Seekable.
.ie n .IP "$rawsrc\->sysseek(\s-1POS\s0, \s-1WHENCE\s0)" 4
.el .IP "\f(CW$rawsrc\fR\->sysseek(\s-1POS\s0, \s-1WHENCE\s0)" 4
.IX Item "$rawsrc->sysseek(POS, WHENCE)"
Move around within the unbuffered source, as in IO::Seekable.
.PP
The buffered (\f(CW\*(C`read\*(C'\fR et al) and unbuffered (\f(CW\*(C`sysread\*(C'\fR et al) sets
of methods are interchangeable, because no such distinction is made by
this class.
.PP
\&\f(CW\*(C`tell\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, and \f(CW\*(C`sysseek\*(C'\fR only work within the first 4 GiB of the
virtual file.  The file is actually much larger than that: for Rijndael
(\s-1AES\s0), or any other cipher with a 128\-bit block, the file is 2^52 YiB
(2^132 B).  \f(CW\*(C`getpos\*(C'\fR and \f(CW\*(C`setpos\*(C'\fR work throughout the file.
.PP
Methods to write to the file are unimplemented because the virtual file
is fundamentally read-only.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Crypt::Rijndael,
Data::Entropy::RawSource::Local,
Data::Entropy::RawSource::RandomOrg,
Data::Entropy::RawSource::RandomnumbersInfo,
Data::Entropy::Source
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2011
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
