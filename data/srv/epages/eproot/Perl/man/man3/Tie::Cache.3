.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cache 3"
.TH Cache 3 "2002-06-29" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Tie::Cache \- LRU Cache in Memory
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Tie::Cache;
\& tie %cache, \*(AqTie::Cache\*(Aq, 100, { Debug => 1 };   
\& tie %cache2, \*(AqTie::Cache\*(Aq, { MaxCount => 100, MaxBytes => 50000 };
\& tie %cache3, \*(AqTie::Cache\*(Aq, 100, { Debug => 1 , WriteSync => 0};   
\&
\& # Options ##################################################################
\& #
\& # Debug =>      0 \- DEFAULT, no debugging output
\& #               1 \- prints cache statistics upon destroying
\& #               2 \- prints detailed debugging info
\& #
\& # MaxCount =>   Maximum entries in cache.
\& #
\& # MaxBytes =>   Maximum bytes taken in memory for cache based on approximate 
\& #               size of total cache structure in memory
\& #
\& #               There is approximately 240 bytes used per key/value pair in the cache for 
\& #               the cache data structures, so a cache of 5000 entries would take
\& #               at approximately 1.2M plus the size of the data being cached.
\& #
\& # MaxSize  =>   Maximum size of each cache entry. Larger entries are not cached.
\& #                   This helps prevent much of the cache being flushed when 
\& #                   you set an exceptionally large entry.  Defaults to MaxBytes/10
\& #
\& # WriteSync =>  1 \- DEFAULT, write() when data is dirtied for 
\& #                   TRUE CACHE (see below)
\& #               0 \- write() dirty data as late as possible, when leaving 
\& #                   cache, or when cache is being DESTROY\*(Aqd
\& #
\& ############################################################################
\&
\& # cache supports normal tied hash functions
\& $cache{1} = 2;       # STORE
\& print "$cache{1}\en"; # FETCH
\&
\& # FIRSTKEY, NEXTKEY
\& while(($k, $v) = each %cache) { print "$k: $v\en"; } 
\& 
\& delete $cache{1};    # DELETE
\& %cache = ();         # CLEAR
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a least recently used (\s-1LRU\s0) cache in memory
through a tie interface.  Any time data is stored in the tied hash,
that key/value pair has an entry time associated with it, and 
as the cache fills up, those members of the cache that are
the oldest are removed to make room for new entries.
.PP
So, the cache only \*(L"remembers\*(R" the last written entries, up to the 
size of the cache.  This can be especially useful if you access 
great amounts of data, but only access a minority of the data a 
majority of the time.
.PP
The implementation is a hash, for quick lookups, 
overlaying a doubly linked list for quick insertion and deletion.
On a WinNT \s-1PII\s0 300, writes to the hash were done at a rate 
3100 per second, and reads from the hash at 6300 per second.   
Work has been done to optimize refreshing cache entries that are 
frequently read from, code like \f(CW$cache\fR{entry}, which moves the 
entry to the end of the linked list internally.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Tie::Cache installs easily using the make or nmake commands as
shown below.  Otherwise, just copy Cache.pm to \f(CW$PERLLIB\fR/site/Tie
.PP
.Vb 4
\&        > perl Makefile.PL
\&        > make
\&        > make test 
\&        > make install
\&
\&        * use nmake for win32
\&        ** you can also just copy Cache.pm to $perllib/Tie
.Ve
.SH "BENCMARKS"
.IX Header "BENCMARKS"
There is another simpler \s-1LRU\s0 cache implementation in \s-1CPAN\s0,
Tie::Cache::LRU, which has the same basic size limiting 
functionality, and for this functionality, the exact same 
interface.
.PP
Through healthy competition, Michael G Schwern got 
Tie::Cache::LRU mostly faster than Tie::Cache on reads & writes:
.PP
.Vb 4
\& Cache Size 5000       Tie::Cache 0.17  Tie::Cache::LRU 0.21
\& 10000 Writes             1.55 CPU sec          1.10 CPU sec
\& 40000 Reads              1.82 CPU sec          1.58 CPU sec
\& 10000 Deletes            0.55 CPU sec          0.59 CPU sec
.Ve
.PP
Unless you are using \s-1TRUE\s0 \s-1CACHE\s0 or MaxBytes functionality,
using Tie::Cache::LRU should be an easy replacement for Tie::Cache.
.SH "TRUE CACHE"
.IX Header "TRUE CACHE"
To use class as a true cache, which acts as the sole interface 
for some data set, subclass the real cache off Tie::Cache, 
with \f(CW@ISA\fR = qw( 'Tie::Cache' ) notation.  Then override
the \fIread()\fR method for behavior when there is a cache miss,
and the \fIwrite()\fR method for behavior when the cache's data 
changes.
.PP
When WriteSync is 1 or \s-1TRUE\s0 (\s-1DEFAULT\s0), \fIwrite()\fR is called immediately
when data in the cache is modified.  If set to 0, data that has 
been modified in the cache gets written out when the entries are deleted or
during the \s-1DESTROY\s0 phase of the cache object, usually at the end of
a script.
.PP
To have the dirty data \fIwrite()\fR periodically while WriteSync is set to 0,
there is a \fIflush()\fR cache \s-1API\s0 call that will flush the dirty writes
in this way.  Just call the \fIflush()\fR \s-1API\s0 like:
.PP
.Vb 1
\&  my $write_flush_count = tied(%cache)\->flush();
.Ve
.PP
The \fIflush()\fR \s-1API\s0 was added in the .17 release thanks to Rob Bloodgood.
.SH "TRUE CACHE EXAMPLE"
.IX Header "TRUE CACHE EXAMPLE"
.Vb 1
\& use Tie::Cache;
\&
\& # personalize the Tie::Cache object, by inheriting from it
\& package My::Cache;
\& @ISA = qw(Tie::Cache);
\&
\& # override the read() and write() member functions
\& # these tell the cache what to do with a cache miss or flush
\& sub read { 
\&    my($self, $key) = @_; 
\&    print "cache miss for $key, read() data\en";
\&    rand() * $key; 
\& }
\& sub write { 
\&    my($self, $key, $value) = @_;
\&    print "flushing [$key, $value] from cache, write() data\en";
\& }
\&
\& my $cache_size   = $ARGV[0] || 2;
\& my $num_to_cache = $ARGV[1] || 4;   
\& my $Debug = $ARGV[2] || 1;
\&
\& tie %cache, \*(AqMy::Cache\*(Aq, $cache_size, {Debug => $Debug};   
\&
\& # load the cache with new data, each through its contents,
\& # and then reload in reverse order.
\& for(1..$num_to_cache) { print "read data $_: $cache{$_}\en" }
\& while(my($k, $v) = each %cache) { print "each data $k: $v\en"; }
\& for(my $i=$num_to_cache; $i>0; $i\-\-) { print "read data $i: $cache{$i}\en"; }
\&
\& # flush writes now, trivial use since will happen in DESTROY() anyway
\& tied(%cache)\->flush(); 
\&
\& # clear cache in 2 ways, write will flush out to disk
\& %cache = ();
\& undef %cache;
.Ve
.SH "NOTES"
.IX Header "NOTES"
Many thanks to all those who helped me make this module a reality, 
including:
.PP
.Vb 6
\&        :) Tom Hukins who provided me insight and motivation for
\&           finishing this module.
\&        :) Jamie McCarthy, for trying to make Tie::Cache be all
\&           that it can be.
\&        :) Rob Fugina who knows how to "TRULY CACHE".
\&        :) Rob Bloodgood, for the TRUE CACHE flush() API
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Please send any questions or comments to Joshua Chamas
at chamas@alumni.stanford.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1999\-2002 Joshua Chamas, Chamas Enterprises Inc.  
Sponsored by development on NodeWorks http://www.nodeworks.com
.PP
All rights reserved. This program is free software; 
you can redistribute it and/or modify it under the same 
terms as Perl itself.
