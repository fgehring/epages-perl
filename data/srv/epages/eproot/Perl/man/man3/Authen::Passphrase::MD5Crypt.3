.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::Passphrase::MD5Crypt 3"
.TH Authen::Passphrase::MD5Crypt 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::Passphrase::MD5Crypt \- passphrases using the MD5\-based Unix
crypt()
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Authen::Passphrase::MD5Crypt;
\&
\&        $ppr = Authen::Passphrase::MD5Crypt\->new(
\&                        salt => "Vd3f8aG6",
\&                        hash_base64 => "GcsdF4YCXb0PM2UmXjIoI1");
\&
\&        $ppr = Authen::Passphrase::MD5Crypt\->new(
\&                        salt_random => 1,
\&                        passphrase => "passphrase");
\&
\&        $ppr = Authen::Passphrase::MD5Crypt\->from_crypt(
\&                \*(Aq$1$Vd3f8aG6$GcsdF4YCXb0PM2UmXjIoI1\*(Aq);
\&
\&        $ppr = Authen::Passphrase::MD5Crypt\->from_rfc2307(
\&                \*(Aq{CRYPT}$1$Vd3f8aG6$GcsdF4YCXb0PM2UmXjIoI1\*(Aq);
\&
\&        $salt = $ppr\->salt;
\&        $hash_base64 = $ppr\->hash_base64;
\&
\&        if($ppr\->match($passphrase)) { ...
\&
\&        $passwd = $ppr\->as_crypt;
\&        $userPassword = $ppr\->as_rfc2307;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class encapsulates a passphrase hashed using
the MD5\-based Unix \fIcrypt()\fR hash function.  This is a subclass of
Authen::Passphrase, and this document assumes that the reader is
familiar with the documentation for that class.
.PP
The \fIcrypt()\fR function in a modern Unix actually supports several
different passphrase schemes.  This class is concerned only with one
particular scheme, an MD5\-based algorithm designed by Poul-Henning Kamp
and originally implemented in FreeBSD.  To handle the whole range of
passphrase schemes supported by the modern \fIcrypt()\fR, see the
from_crypt constructor and the
as_crypt method in Authen::Passphrase.
.PP
The MD5\-based \fIcrypt()\fR scheme uses the whole passphrase, a salt which
can in principle be an arbitrary byte string, and the \s-1MD5\s0 message
digest algorithm.  First the passphrase and salt are hashed together,
yielding an \s-1MD5\s0 message digest.  Then a new digest is constructed,
hashing together the passphrase, the salt, and the first digest, all in
a rather complex form.  Then this digest is passed through a thousand
iterations of a function which rehashes it together with the passphrase
and salt in a manner that varies between rounds.  The output of the last
of these rounds is the resulting passphrase hash.
.PP
In the \fIcrypt()\fR function the raw hash output is then represented in \s-1ASCII\s0
as a 22\-character string using a base 64 encoding.  The base 64 digits
are "\fB.\fR\*(L", \*(R"\fB/\fR\*(L", \*(R"\fB0\fR\*(L" to \*(R"\fB9\fR\*(L", \*(R"\fBA\fR\*(L" to \*(R"\fBZ\fR\*(L", \*(R"\fBa\fR\*(L" to \*(R"\fBz\fR"
(in \s-1ASCII\s0 order).  Because the base 64 encoding can represent 132 bits
in 22 digits, more than the 128 required, the last digit can only take
four of the base 64 digit values.  An additional complication is that
the bytes of the raw algorithm output are permuted in a bizarre order
before being represented in base 64.
.PP
There is no tradition of handling these passphrase hashes in raw
binary form.  The textual encoding described above, including the final
permutation, is used universally, so this class does not support any
binary format.
.PP
The complex algorithm was designed to be slow to compute, in order
to resist brute force attacks.  However, the complexity is fixed,
and the operation of Moore's Law has rendered it far less expensive
than intended.  If efficiency of a brute force attack is a concern,
see Authen::Passphrase::BlowfishCrypt.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "Authen::Passphrase::MD5Crypt\->new(\s-1ATTR\s0 => \s-1VALUE\s0, ...)" 4
.IX Item "Authen::Passphrase::MD5Crypt->new(ATTR => VALUE, ...)"
Generates a new passphrase recogniser object using the MD5\-based \fIcrypt()\fR
algorithm.  The following attributes may be given:
.RS 4
.IP "\fBsalt\fR" 4
.IX Item "salt"
The salt, as a raw string.  It may be any byte string, but in \fIcrypt()\fR
usage it is conventionally limited to zero to eight base 64 digits.
.IP "\fBsalt_random\fR" 4
.IX Item "salt_random"
Causes salt to be generated randomly.  The value given for this
attribute is ignored.  The salt will be a string of eight base 64 digits.
The source of randomness may be controlled by the facility described
in Data::Entropy.
.IP "\fBhash_base64\fR" 4
.IX Item "hash_base64"
The hash, as a string of 22 base 64 digits.  This is the final part of
what \fIcrypt()\fR outputs.
.IP "\fBpassphrase\fR" 4
.IX Item "passphrase"
A passphrase that will be accepted.
.RE
.RS 4
.Sp
The salt must be given, and either the hash or the passphrase.
.RE
.IP "Authen::Passphrase::MD5Crypt\->from_crypt(\s-1PASSWD\s0)" 4
.IX Item "Authen::Passphrase::MD5Crypt->from_crypt(PASSWD)"
Generates a new passphrase recogniser object using the MD5\-based \fIcrypt()\fR
algorithm, from a crypt string.  The crypt string must consist of
"\fB\f(CB$1\fB$\fR\*(L", the salt, \*(R"\fB$\fR\*(L", then 22 base 64 digits giving the hash.
The salt may be up to 8 characters long, and cannot contain \*(R"\fB$\fR"
or any character that cannot appear in a crypt string.
.IP "Authen::Passphrase::MD5Crypt\->from_rfc2307(\s-1USERPASSWORD\s0)" 4
.IX Item "Authen::Passphrase::MD5Crypt->from_rfc2307(USERPASSWORD)"
Generates a new passphrase recogniser object using the MD5\-based
\&\fIcrypt()\fR algorithm, from an \s-1RFC\s0 2307 string.  The string must consist of
"\fB{\s-1CRYPT\s0}\fR" (case insensitive) followed by an acceptable crypt string.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ppr\->salt" 4
.el .IP "\f(CW$ppr\fR\->salt" 4
.IX Item "$ppr->salt"
Returns the salt, in raw form.
.ie n .IP "$ppr\->hash_base64" 4
.el .IP "\f(CW$ppr\fR\->hash_base64" 4
.IX Item "$ppr->hash_base64"
Returns the hash value, as a string of 22 base 64 digits.
.ie n .IP "$ppr\->match(\s-1PASSPHRASE\s0)" 4
.el .IP "\f(CW$ppr\fR\->match(\s-1PASSPHRASE\s0)" 4
.IX Item "$ppr->match(PASSPHRASE)"
.PD 0
.ie n .IP "$ppr\->as_crypt" 4
.el .IP "\f(CW$ppr\fR\->as_crypt" 4
.IX Item "$ppr->as_crypt"
.ie n .IP "$ppr\->as_rfc2307" 4
.el .IP "\f(CW$ppr\fR\->as_rfc2307" 4
.IX Item "$ppr->as_rfc2307"
.PD
These methods are part of the standard Authen::Passphrase interface.
Not every passphrase recogniser of this type can be represented as a
crypt string: the crypt format only allows the salt to be up to eight
bytes, and it cannot contain any \s-1NUL\s0 or "\fB$\fR" characters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::Passphrase,
Crypt::PasswdMD5
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
