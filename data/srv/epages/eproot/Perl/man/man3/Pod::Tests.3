.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pod::Tests 3"
.TH Pod::Tests 3 "2008-07-13" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pod::Tests \- Extracts embedded tests and code examples from POD
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Pod::Tests;
\&  $p = Pod::Tests\->new;
\&
\&  $p\->parse_file($file);
\&  $p\->parse_fh($fh);
\&  $p\->parse(@code);
\&
\&  my @examples = $p\->examples;
\&  my @tests    = $p\->tests;
\&
\&  foreach my $example (@examples) {
\&      print "The example:  \*(Aq$example\->{code}\*(Aq was on line ".
\&            "$example\->{line}\en";
\&  }
\&
\&  my @test_code         = $p\->build_tests(@tests);
\&  my @example_test_code = $p\->build_examples(@examples);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a specialized \s-1POD\s0 viewer to extract embedded tests and code
examples from \s-1POD\s0.  It doesn't do much more than that.  pod2test does
the useful work.
.SS "Parsing"
.IX Subsection "Parsing"
After creating a Pod::Tests object, you parse the \s-1POD\s0 by calling one
of the available parsing methods documented below.  You can call parse
as many times as you'd like, all examples and tests found will stack
up inside the object.
.SS "Testing"
.IX Subsection "Testing"
Once extracted, the tests can be built into stand-alone testing code
using the \fIbuild_tests()\fR and \fIbuild_examples()\fR methods.  However, it is
recommended that you first look at the pod2test program before
embarking on this.
.SS "Methods"
.IX Subsection "Methods"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $parser = Pod::Tests\->new;
.Ve
.PP
Returns a new Pod::Tests object which lets you read tests and examples
out of a \s-1POD\s0 document.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $parser\->parse(@code);
.Ve
.PP
Finds the examples and tests in a bunch of lines of Perl \f(CW@code\fR.  Once
run they're available via \fIexamples()\fR and \fItesting()\fR.
.ie n .SS "parse_file $file"
.el .SS "parse_file \f(CW$file\fP"
.IX Subsection "parse_file $file"
.Vb 1
\&  $parser\->parse_file($filename);
.Ve
.PP
Just like \fIparse()\fR except it works on a file.
.ie n .SS "parse_fh $fh"
.el .SS "parse_fh \f(CW$fh\fP"
.IX Subsection "parse_fh $fh"
.Vb 1
\&  $parser\->parse_fh($fh);
.Ve
.PP
Just like \fIparse()\fR except it works on a filehandle.
.SS "tests"
.IX Subsection "tests"
.Vb 1
\&  @testing  = $parser\->tests;
.Ve
.PP
Returns the tests found in the parsed \s-1POD\s0 documents.  Each element of
\&\f(CW@testing\fR is a hash representing an individual testing block and contains
information about that block.
.PP
.Vb 2
\&  $test\->{code}         actual testing code
\&  $test\->{line}         line from where the test was taken
.Ve
.SS "examples"
.IX Subsection "examples"
.Vb 1
\&  @examples = $parser\->examples;
.Ve
.PP
Returns the examples found in the parsed \s-1POD\s0 documents.  Each element of
\&\f(CW@examples\fR is a hash representing an individual testing block and contains
information about that block.
.PP
.Vb 2
\&  $test\->{code}         actual testing code
\&  $test\->{line}         line from where the test was taken
.Ve
.SS "build_tests"
.IX Subsection "build_tests"
.Vb 1
\&  my @code = $p\->build_tests(@tests);
.Ve
.PP
Returns a code fragment based on the given embedded \f(CW@tests\fR.  This
fragment is expected to print the usual \*(L"ok/not ok\*(R" (or something
Test::Harness can read) or nothing at all.
.PP
Typical usage might be:
.PP
.Vb 1
\&    my @code = $p\->build_tests($p\->tests);
.Ve
.PP
This fragment is suitable for placing into a larger test script.
.PP
\&\fB\s-1NOTE\s0\fR Look at pod2test before embarking on your own test building.
.SS "build_examples"
.IX Subsection "build_examples"
.Vb 1
\&  my @code = $p\->build_examples(@examples);
.Ve
.PP
Similar to \fIbuild_tests()\fR, it creates a code fragment which tests the
basic validity of your example code.  Essentially, it just makes sure
it compiles.
.PP
If your example has an \*(L"example testing\*(R" block associated with it it
will run the the example code and the example testing block.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Here's the simplest example, just finding the tests and examples in a
single module.
.PP
.Vb 2
\&  my $p = Pod::Tests\->new;
\&  $p\->parse_file("path/to/Some.pm");
.Ve
.PP
And one to find all the tests and examples in a directory of files.  This
illustrates building a set of examples and tests through multiple calls
to \fIparse_file()\fR.
.PP
.Vb 7
\&  my $p = Pod::Tests\->new;
\&  opendir(PODS, "path/to/some/lib/") || die $!;
\&  while( my $file = readdir PODS ) {
\&      $p\->parse_file($file);
\&  }
\&  printf "Found %d examples and %d tests in path/to/some/lib\en",
\&         scalar $p\->examples, scalar $p\->tests;
.Ve
.PP
Finally, an example of parsing your own \s-1POD\s0 using the \s-1DATA\s0 filehandle.
.PP
.Vb 2
\&  use Fcntl qw(:seek);
\&  my $p = Pod::Tests\->new;
\&
\&  # Seek to the beginning of the current code.
\&  seek(DATA, 0, SEEK_SET) || die $!;
\&  $p\->parse_fh(\e*DATA);
.Ve
.SS "\s-1SUPPORT\s0"
.IX Subsection "SUPPORT"
This module has been replaced by the newer Test::Inline 2. Most testing
code that currently works with \f(CW\*(C`pod2test\*(C'\fR should continue to work with
the new version. The most notable exceptions are \f(CW\*(C`=for begin\*(C'\fR and
\&\f(CW\*(C`=for end\*(C'\fR, which are deprecated.
.PP
After upgrading, Pod::Tests and \f(CW\*(C`pod2test\*(C'\fR were split out to provide
a compatibility package for legacy code.
.PP
\&\f(CW\*(C`pod2test\*(C'\fR will stay in \s-1CPAN\s0, but should remain unchanged indefinately,
with the exception of any minor bugs that will require squishing.
.PP
Bugs in this dist should be reported via the following \s-1URL\s0. Feature requests
should not be submitted, as further development is now occuring in
Test::Inline.
.PP
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Pod\-Tests <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Pod-Tests>
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com>
.PP
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Inline
.PP
pod2test, Perl 6 \s-1RFC\s0 183  http://dev.perl.org/rfc183.pod
.PP
Short set of slides on Pod::Tests
http://www.pobox.com/~schwern/talks/Embedded_Testing/
.PP
Similar schemes can be found in SelfTest and Test::Unit.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2005 \- 2008 Adam Kennedy.
.PP
Copyright 2001 \- 2003 Michael G Schwern.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
