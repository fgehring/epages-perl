.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Inline::Script 3"
.TH Test::Inline::Script 3 "2010-11-22" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Inline::Script \- Generate the test file for a single source file
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is where the heavy lifting happens to actually generating a
test file takes place. Given a source filename, this modules will load
it, parse out the relavent bits, put them into order based on the tags,
and then merge them into a test file.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  my $File = Test::Inline::Script\->new( $class, \e@sections, $check_count );
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor takes a class name, set of Section objects and
an optional \f(CW\*(C`check_count\*(C'\fR flag.
.PP
Returns a Test::Inline::Script object on success.
Returns \f(CW\*(C`undef\*(C'\fR on error.
.SS "class"
.IX Subsection "class"
Returns the class that the test file will test
.SS "filename"
.IX Subsection "filename"
.Vb 1
\&  my $filename = $File\->filename;
.Ve
.PP
The \f(CW\*(C`filename\*(C'\fR method returns the name of the output file that the tests
should be written to. For example, the class \f(CW\*(C`Foo::Bar\*(C'\fR would have the
filename value \f(CW\*(C`foo_bar.t\*(C'\fR.
.SS "config"
.IX Subsection "config"
.Vb 1
\&  my $config = $File\->config;
.Ve
.PP
The \f(CW\*(C`config\*(C'\fR method returns the config object for the file, assuming that 
it has one. If more than one are found, the first will be used, and any 
additional config sections discarded.
.PP
Returns a Test::Inline::Config object on success, or false if the
file does not contain a config section.
.SS "setup"
.IX Subsection "setup"
.Vb 1
\&  my @setup = $File\->setup;
.Ve
.PP
The \f(CW\*(C`setup\*(C'\fR method returns the setup sections from the file, in the same
order as in the file.
.PP
Returns a list of setup Test::Inline::Section objects, the null
array \f(CW\*(C`()\*(C'\fR if the file does not contain any setup objects.
.SS "sections"
.IX Subsection "sections"
.Vb 1
\&  my @sections = $File\->sections;
.Ve
.PP
The \f(CW\*(C`sections\*(C'\fR method returns all normal sections from the file, in the
same order as in the file. This may not be the order they will be written
to the test file, for that you should see the \f(CW\*(C`sorted\*(C'\fR method.
.PP
Returns a list of Test::Inline::Section objects, or the null array
\&\f(CW\*(C`()\*(C'\fR if the file does not contain any non-setup sections.
.SS "sorted"
.IX Subsection "sorted"
The \f(CW\*(C`sorted\*(C'\fR method returns all normal sections from the file, in an order
that satisfies any dependencies in the sections.
.PP
Returns a reference to an array of Test::Inline::Section objects,
\&\f(CW0\fR if the file does not contain any non-setup sections, or \f(CW\*(C`undef\*(C'\fR on
error.
.SS "tests"
.IX Subsection "tests"
If the number of tests for all of the sections within the file are known,
then the number of tests for the entire file can also be determined.
.PP
The \f(CW\*(C`tests\*(C'\fR method determines if the number of tests can be known, and
if so, calculates and returns the number of tests. Returns false if the
number of tests is not known.
.SS "merged_content"
.IX Subsection "merged_content"
The \f(CW\*(C`merged_content\*(C'\fR method generates and returns the merged contents of all
the sections in the file, including the setup sections at the beginning. The
method does not return the entire file, merely the part contained in the
sections. For the full file contents, see the \f(CW\*(C`file_content\*(C'\fR method.
.PP
Returns a string containing the merged section content on success, false
if there is no content, despite the existance of sections ( which would
have been empty ), or \f(CW\*(C`undef\*(C'\fR on error.
.SH "SUPPORT"
.IX Header "SUPPORT"
See the main \s-1SUPPORT\s0 section.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004 \- 2010 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
