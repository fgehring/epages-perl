.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Algorithm::Dependency::Source 3"
.TH Algorithm::Dependency::Source 3 "2009-04-14" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Algorithm::Dependency::Source \- Implements a source of heirachy items
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Algorithm::Dependency::Source class provides an abstract parent class for
implementing sources for the heirachy data the algorithm will use. For an
example of an implementation of this, see
Algorithm::Dependency::Source::File, which is bundled with the main
Algorithm::Dependency package.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new @arguments"
.el .SS "new \f(CW@arguments\fP"
.IX Subsection "new @arguments"
Although you cannot directly use the \f(CW\*(C`new\*(C'\fR constructor for
\&\f(CW\*(C`Algorithm::Dependency::Source\*(C'\fR, it will work the same in all subclasses.
.PP
The constructor takes zero or more subclass specific arguments to define the
location of the source of the items, and returns a new object. Alrough it
may check that the arguments you passed are valid, the source will usually
\&\s-1NOT\s0 actually load the items from the source, instead defering the loading
until you need to use the items.
.PP
Returns a new object on success, or \f(CW\*(C`undef\*(C'\fR on error.
.SS "load"
.IX Subsection "load"
The \f(CW\*(C`load\*(C'\fR method is the public method used to actually load the items from
their storage location into the the source object. The method will
automatically called, as needed, in most circumstances. You would generally
only want to use \f(CW\*(C`load\*(C'\fR manually if you think there may be some uncertainty
that the source will load correctly, and want to check it will work.
.PP
Returns true if the items are loaded successfully, or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .SS "item $name"
.el .SS "item \f(CW$name\fP"
.IX Subsection "item $name"
The \f(CW\*(C`item\*(C'\fR method fetches and returns the item object specified by the
name argument.
.PP
Returns an Algorithm::Dependency::Item object on success, or \f(CW\*(C`undef\*(C'\fR if
the named item does not exist in the source.
.SS "items"
.IX Subsection "items"
The \f(CW\*(C`items\*(C'\fR method returns, as a list of objects, all of the items
contained in the source. The item objects will be returned in the same order
as that in the storage location.
.PP
Returns a list of Algorithm::Dependency::Item objects on success, or
\&\f(CW\*(C`undef\*(C'\fR on error.
.SS "missing_dependencies"
.IX Subsection "missing_dependencies"
By default, we are leniant with missing dependencies if the item is neved 
used. For systems where having a missing dependency can be very bad, the 
\&\f(CW\*(C`missing_dependencies\*(C'\fR method checks all Items to make sure their 
dependencies exist.
.PP
If there are any missing dependencies, returns a reference to an array of
their ids. If there are no missing dependencies, returns 0. Returns 
\&\f(CW\*(C`undef\*(C'\fR on error.
.SH "EXTENDING"
.IX Header "EXTENDING"
\&\f(CW\*(C`Algorithm::Dependency::Source\*(C'\fR itself is a fairly thin module, and it
is intended that you will probably need to extend it to be able to
extract item data from whatever location you have stored them.
.PP
This is usually a fairly simple two step process.
.ie n .IP "Overload the ""new"" method." 4
.el .IP "Overload the \f(CWnew\fR method." 4
.IX Item "Overload the new method."
Assuming your subclass takes some form or argument on creation, you will
need to overload the \f(CW\*(C`new\*(C'\fR method to accept the arguments, validate them,
and store them in the source object.
.ie n .IP "Define the method ""_load_item_list""." 4
.el .IP "Define the method \f(CW_load_item_list\fR." 4
.IX Item "Define the method _load_item_list."
Leaving our parent's \f(CW\*(C`load\*(C'\fR method to take care of conflict, errors, and
whatever, the \f(CW\*(C`_load_item_list\*(C'\fR method is used to simply create a list of
Algorithm::Dependency::Item objects from wherever you store the item,
and return them as a list.
.PP
Having completed these two things, your subclass should be completed. For
an example of the code, have a look at the source for the simple subclass
Algorithm::Dependency::Source::File.
.SH "SUPPORT"
.IX Header "SUPPORT"
For general comments, contact the author.
.PP
To file a bug against this module, in a way you can keep track of, see the
\&\s-1CPAN\s0 bug tracking system.
.PP
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Algorithm\-Dependency <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Algorithm-Dependency>
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Algorithm::Dependency, Algorithm::Dependency::Source::File
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2009 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
