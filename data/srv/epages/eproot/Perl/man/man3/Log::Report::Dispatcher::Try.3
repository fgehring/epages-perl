.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Log::Report::Dispatcher::Try 3"
.TH Log::Report::Dispatcher::Try 3 "2016-10-21" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Log::Report::Dispatcher::Try \- capture all reports as exceptions
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& Log::Report::Dispatcher::Try
\&   is a Log::Report::Dispatcher
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& try { ... };       # mind the \*(Aq;\*(Aq !!
\& if($@) {           # signals something went wrong
\&
\& if(try {...}) {    # block ended normally
\&
\& my $x = try { read_temperature() };
\& my @x = try { read_lines_from_file() };
\&
\& try { ... }        # no comma!!
\&    mode => \*(AqDEBUG\*(Aq, accept => \*(AqERROR\-\*(Aq;
\&
\& try sub { ... },   # with comma
\&    mode => \*(AqDEBUG\*(Aq, accept => \*(AqALL\*(Aq;
\&
\& try \e&myhandler, accept => \*(AqERROR\-\*(Aq;
\& try { ... } hide => \*(AqTRACE\*(Aq;
\&
\& print ref $@;      # Log::Report::Dispatcher::Try
\&
\& $@\->reportFatal;   # re\-dispatch result of try block
\& $@\->reportAll;     # ... also warnings etc
\& if($@) {...}       # if errors
\& if($@\->failed) {   # same       # }
\& if($@\->success) {  # no errors  # }
\&
\& try { # something causes an error report, which is caught
\&       failure \*(Aqno network\*(Aq;
\&     };
\& $@\->reportFatal(to => \*(Aqsyslog\*(Aq);  # overrule destination
\&
\& print $@\->exceptions; # no re\-cast, just print
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \fILog::Report::try()\fR catches errors in the block (\s-1CODE\s0
reference) which is just following the function name.  All
dispatchers are temporarily disabled by \f(CW\*(C`try\*(C'\fR, and messages
which are reported are collected within a temporary dispatcher
named \f(CW\*(C`try\*(C'\fR.  When the \s-1CODE\s0 has run, that \f(CW\*(C`try\*(C'\fR dispatcher
is returned in \f(CW$@\fR, and all original dispatchers reinstated.
.PP
Then, after the \f(CW\*(C`try\*(C'\fR has finished, the routine which used
the \*(L"try\*(R" should decide what to do with the collected reports.
These reports are collected as Log::Report::Exception objects.
They can be ignored, or thrown to a higher level try... causing
an exit of the program if there is none.
.PP
Extends \*(L"\s-1DESCRIPTION\s0\*(R" in Log::Report::Dispatcher.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\s0\*(R" in Log::Report::Dispatcher.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in Log::Report::Dispatcher.
.ie n .IP "$obj\->\fBclose\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBclose\fR()" 4
.IX Item "$obj->close()"
Only when initiated with a \s-1FILENAME\s0, the file will be closed.  In any
other case, nothing will be done.
.ie n .IP "Log::Report::Dispatcher::Try\->\fBnew\fR($type, $name, %options)" 4
.el .IP "Log::Report::Dispatcher::Try\->\fBnew\fR($type, \f(CW$name\fR, \f(CW%options\fR)" 4
.IX Item "Log::Report::Dispatcher::Try->new($type, $name, %options)"
.Vb 10
\& \-Option       \-\-Defined in             \-\-Default
\&  accept         Log::Report::Dispatcher  depend on mode
\&  charset        Log::Report::Dispatcher  <undef>
\&  died                                    undef
\&  exceptions                              []
\&  format_reason  Log::Report::Dispatcher  \*(AqLOWERCASE\*(Aq
\&  hide                                    \*(AqNONE\*(Aq
\&  locale         Log::Report::Dispatcher  <system locale>
\&  mode           Log::Report::Dispatcher  \*(AqNORMAL\*(Aq
\&  on_die                                  \*(AqERROR\*(Aq
.Ve
.RS 4
.IP "accept => \s-1REASONS\s0" 2
.IX Item "accept => REASONS"
.PD 0
.IP "charset => \s-1CHARSET\s0" 2
.IX Item "charset => CHARSET"
.IP "died => \s-1STRING\s0" 2
.IX Item "died => STRING"
.PD
The exit string ($@) of the eval'ed block.
.IP "exceptions => \s-1ARRAY\s0" 2
.IX Item "exceptions => ARRAY"
\&\s-1ARRAY\s0 of Log::Report::Exception objects.
.IP "format_reason => '\s-1UPPERCASE\s0'|'\s-1LOWERCASE\s0'|'\s-1UCFIRST\s0'|'\s-1IGNORE\s0'|CODE" 2
.IX Item "format_reason => 'UPPERCASE'|'LOWERCASE'|'UCFIRST'|'IGNORE'|CODE"
.PD 0
.IP "hide => REASON|ARRAY|'\s-1ALL\s0'|'\s-1NONE\s0'" 2
.IX Item "hide => REASON|ARRAY|'ALL'|'NONE'"
.PD
[1.09] see \fIhide()\fR
.IP "locale => \s-1LOCALE\s0" 2
.IX Item "locale => LOCALE"
.PD 0
.IP "mode => '\s-1NORMAL\s0'|'\s-1VERBOSE\s0'|'\s-1ASSERT\s0'|'\s-1DEBUG\s0'|0..3" 2
.IX Item "mode => 'NORMAL'|'VERBOSE'|'ASSERT'|'DEBUG'|0..3"
.IP "on_die => '\s-1ERROR\s0'|'\s-1PANIC\s0'" 2
.IX Item "on_die => 'ERROR'|'PANIC'"
.PD
When code which runs in this block exits with a \fIdie()\fR, it will get
translated into a Log::Report::Exception using
\&\fILog::Report::Die::die_decode()\fR.  How serious are we about these
errors?
.RE
.RS 4
.RE
.SS "Accessors"
.IX Subsection "Accessors"
Extends \*(L"Accessors\*(R" in Log::Report::Dispatcher.
.ie n .IP "$obj\->\fBdie2reason\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBdie2reason\fR()" 4
.IX Item "$obj->die2reason()"
Returns the value of new(on_die).
.ie n .IP "$obj\->\fBdied\fR( [\s-1STRING\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBdied\fR( [\s-1STRING\s0] )" 4
.IX Item "$obj->died( [STRING] )"
The message which was reported by \f(CW\*(C`eval\*(C'\fR, which is used internally
to catch problems in the try block.
.ie n .IP "$obj\->\fBexceptions\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBexceptions\fR()" 4
.IX Item "$obj->exceptions()"
Returns all collected \f(CW\*(C`Log::Report::Exceptions\*(C'\fR.  The last of
them may be a fatal one.  The other are non-fatal.
.ie n .IP "$obj\->\fBhide\fR(REASON|REASONS|ARRAY|'\s-1ALL\s0'|'\s-1NONE\s0')" 4
.el .IP "\f(CW$obj\fR\->\fBhide\fR(REASON|REASONS|ARRAY|'\s-1ALL\s0'|'\s-1NONE\s0')" 4
.IX Item "$obj->hide(REASON|REASONS|ARRAY|'ALL'|'NONE')"
[1.09] By default, the try will only catch messages which stop the
execution of the block (errors etc, internally a 'die').  Other messages
are passed to parent try blocks, if none than to the dispatchers.
.Sp
This option gives the opportunity to block, for instance, trace messages.
Those messages are still collected inside the try object, so may get
passed-on later via \fIreportAll()\fR if you like.
.Sp
Be warned: Using this method will reset the whole 'hide' configuration:
it's a \fIset\fR not an \fIadd\fR.
.Sp
example: change the setting of the running block
.Sp
.Vb 2
\&  my $parent_try = dispatcher \*(Aqactive\-try\*(Aq;
\&  parent_try\->hide(\*(AqNONE\*(Aq);
.Ve
.ie n .IP "$obj\->\fBhides\fR(\s-1REASON\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBhides\fR(\s-1REASON\s0)" 4
.IX Item "$obj->hides(REASON)"
.PD 0
.ie n .IP "$obj\->\fBisDisabled\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBisDisabled\fR()" 4
.IX Item "$obj->isDisabled()"
.PD
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBmode\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmode\fR()" 4
.IX Item "$obj->mode()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBname\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBname\fR()" 4
.IX Item "$obj->name()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBneeds\fR( [$reason] )" 4
.el .IP "\f(CW$obj\fR\->\fBneeds\fR( [$reason] )" 4
.IX Item "$obj->needs( [$reason] )"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBtype\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtype\fR()" 4
.IX Item "$obj->type()"
Inherited, see \*(L"Accessors\*(R" in Log::Report::Dispatcher
.SS "Logging"
.IX Subsection "Logging"
Extends \*(L"Logging\*(R" in Log::Report::Dispatcher.
.ie n .IP "$obj\->\fBaddSkipStack\fR(@CODE)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSkipStack\fR(@CODE)" 4
.IX Item "$obj->addSkipStack(@CODE)"
.PD 0
.IP "Log::Report::Dispatcher::Try\->\fBaddSkipStack\fR(@CODE)" 4
.IX Item "Log::Report::Dispatcher::Try->addSkipStack(@CODE)"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBcollectLocation\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcollectLocation\fR()" 4
.IX Item "$obj->collectLocation()"
.PD 0
.IP "Log::Report::Dispatcher::Try\->\fBcollectLocation\fR()" 4
.IX Item "Log::Report::Dispatcher::Try->collectLocation()"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBcollectStack\fR( [$maxdepth] )" 4
.el .IP "\f(CW$obj\fR\->\fBcollectStack\fR( [$maxdepth] )" 4
.IX Item "$obj->collectStack( [$maxdepth] )"
.PD 0
.IP "Log::Report::Dispatcher::Try\->\fBcollectStack\fR( [$maxdepth] )" 4
.IX Item "Log::Report::Dispatcher::Try->collectStack( [$maxdepth] )"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBlog\fR($opts, $reason, $message)" 4
.el .IP "\f(CW$obj\fR\->\fBlog\fR($opts, \f(CW$reason\fR, \f(CW$message\fR)" 4
.IX Item "$obj->log($opts, $reason, $message)"
Other dispatchers translate the message here, and make it leave the
program.  However, messages in a \*(L"try\*(R" block are only captured in
an intermediate layer: they may never be presented to an end-users.
And for sure, we do not know the language yet.
.Sp
The \f(CW$message\fR is either a \s-1STRING\s0 or a Log::Report::Message.
.ie n .IP "$obj\->\fBreportAll\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBreportAll\fR(%options)" 4
.IX Item "$obj->reportAll(%options)"
Re-cast the messages in all collect exceptions into the defined
dispatchers, which were disabled during the try block. The \f(CW%options\fR
will end-up as \s-1HASH\s0 of \f(CW%options\fR to \fILog::Report::report()\fR; see
\&\fILog::Report::Exception::throw()\fR which does the job.
.ie n .IP "$obj\->\fBreportFatal\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBreportFatal\fR()" 4
.IX Item "$obj->reportFatal()"
Re-cast only the fatal message to the defined dispatchers.  If the
block was left without problems, then nothing will be done.  The \f(CW%options\fR
will end-up as \s-1HASH\s0 of \f(CW%options\fR to \fILog::Report::report()\fR; see
\&\fILog::Report::Exception::throw()\fR which does the job.
.ie n .IP "$obj\->\fBskipStack\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBskipStack\fR()" 4
.IX Item "$obj->skipStack()"
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBstackTraceLine\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBstackTraceLine\fR(%options)" 4
.IX Item "$obj->stackTraceLine(%options)"
.PD 0
.IP "Log::Report::Dispatcher::Try\->\fBstackTraceLine\fR(%options)" 4
.IX Item "Log::Report::Dispatcher::Try->stackTraceLine(%options)"
.PD
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.ie n .IP "$obj\->\fBtranslate\fR(HASH\-$of\-%options, $reason, $message)" 4
.el .IP "\f(CW$obj\fR\->\fBtranslate\fR(HASH\-$of\-%options, \f(CW$reason\fR, \f(CW$message\fR)" 4
.IX Item "$obj->translate(HASH-$of-%options, $reason, $message)"
Inherited, see \*(L"Logging\*(R" in Log::Report::Dispatcher
.SS "Status"
.IX Subsection "Status"
.ie n .IP "$obj\->\fBfailed\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfailed\fR()" 4
.IX Item "$obj->failed()"
Returns true if the block was left with an fatal message.
.ie n .IP "$obj\->\fBshowStatus\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBshowStatus\fR()" 4
.IX Item "$obj->showStatus()"
If this object is kept in \f(CW$@\fR, and someone uses this as string, we
want to show the fatal error message.
.Sp
The message is not very informative for the good cause: we do not want
people to simply print the \f(CW$@\fR, but wish for a re-cast of the message
using \fIreportAll()\fR or \fIreportFatal()\fR.
.ie n .IP "$obj\->\fBsuccess\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBsuccess\fR()" 4
.IX Item "$obj->success()"
Returns true if the block exited normally.
.ie n .IP "$obj\->\fBwasFatal\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBwasFatal\fR(%options)" 4
.IX Item "$obj->wasFatal(%options)"
Returns the Log::Report::Exception which caused the \*(L"try\*(R" block to
die, otherwise an empty \s-1LIST\s0 (undef).
.Sp
.Vb 2
\& \-Option\-\-Default
\&  class   undef
.Ve
.RS 4
.IP "class => CLASS|REGEX" 2
.IX Item "class => CLASS|REGEX"
Only return the exception if it was fatal, and in the same time in
the specified \s-1CLASS\s0 (as string) or matches the \s-1REGEX\s0.
See \fILog::Report::Message::inClass()\fR
.RE
.RS 4
.RE
.SH "DETAILS"
.IX Header "DETAILS"
Extends \*(L"\s-1DETAILS\s0\*(R" in Log::Report::Dispatcher.
.SH "OVERLOADING"
.IX Header "OVERLOADING"
.IP "overload: \fBboolean\fR" 4
.IX Item "overload: boolean"
Returns true if the previous try block did produce a terminal
error.  This \*(L"try\*(R" object is assigned to \f(CW$@\fR, and the usual
perl syntax is \f(CW\*(C`if($@) {...error\-handler...}\*(C'\fR.
.IP "overload: \fBstringify\fR" 4
.IX Item "overload: stringify"
When \f(CW$@\fR is used the traditional way, it is checked to have
a string content.  In this case, stringify into the fatal error
or nothing.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of Log-Report distribution version 1.18,
built on October 21, 2016. Website: \fIhttp://perl.overmeer.net/log\-report/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 134:" 4
.IX Item "Around line 134:"
Unterminated M<...> sequence
.Sp
Deleting unknown formatting code M<>
