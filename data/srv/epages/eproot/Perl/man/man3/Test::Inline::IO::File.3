.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Inline::IO::File 3"
.TH Test::Inline::IO::File 3 "2010-11-22" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Inline::IO::File \- Test::Inline Local Filesystem IO Handler
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBTest::Inline::IO::File\fR is the default \s-1IO\s0 handler for Test::Inline.
.PP
Test::Inline 2.0 was conceived in an enterprise setting, and retains
the flexibilty, power, and bulk that this created, although for most
users the power and complexity that is available is largely hidden away
under multiple layers of sensible defaults.
.PP
The intent with the \f(CW\*(C`InputHandler\*(C'\fR and \f(CW\*(C`OutputHandle\*(C'\fR parameters is to
allow Test::Inline to be able to pull source data from anywhere, and
write the resulting test scripts to anywhere.
.PP
Until a more powerful pure-OO file-system \s-1API\s0 comes along, this module
serves as a minimalist implementation of the subset of functionality
that Test::Inline needs in order to work.
.PP
An alternative \s-1IO\s0 Handler class need not subclass this one (although it
is recommended), merely implement the same interface, taking whatever
alternative arguments to the \f(CW\*(C`new\*(C'\fR constructor that it wishes.
.PP
All methods in this class are provided with unix-style paths, and should do
the translating to the underlying filesystem themselves if required.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 2
\&  # Simplified usage
\&  $io_handler = Test::Inline::IO::File\->new( $path );
\&  
\&  # Full key/value usage
\&  $io_handler = Test::Inline::IO::File\->new(
\&          path     => $path,
\&          readonly => 1,
\&  );
.Ve
.PP
The \f(CW\*(C`new\*(C'\fR constructor takes a root path on the local filesystem
and returns a new \f(CW\*(C`Test::Inline::IO::File\*(C'\fR object to that
location.
.ie n .SS "exists_file $file"
.el .SS "exists_file \f(CW$file\fP"
.IX Subsection "exists_file $file"
The \f(CW\*(C`exists_file\*(C'\fR method checks to see if a particular file currently
exists in the input handler.
.PP
Returns true if it exists, or false if not.
.ie n .SS "exists_dir $dir"
.el .SS "exists_dir \f(CW$dir\fP"
.IX Subsection "exists_dir $dir"
The \f(CW\*(C`exists_dir\*(C'\fR method checks to see if a particular directory currently
exists in the input handler.
.PP
Returns true if it exists, or false if not.
.ie n .SS "read $file"
.el .SS "read \f(CW$file\fP"
.IX Subsection "read $file"
The \f(CW\*(C`read\*(C'\fR method reads in the entire contents of a single file,
returning it as a reference to a \s-1SCALAR\s0. It also localises the
newlines as it does this, so files from different operating
systems should read as you expect.
.PP
Returns a \s-1SCALAR\s0 reference, or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .SS "write $file, $content"
.el .SS "write \f(CW$file\fP, \f(CW$content\fP"
.IX Subsection "write $file, $content"
The \f(CW\*(C`write\*(C'\fR method writes a string to a file in one hit, creating
it and it's path if needed.
.ie n .SS "class_file $class"
.el .SS "class_file \f(CW$class\fP"
.IX Subsection "class_file $class"
Assuming your input FileHandler is pointing at the root directory
of a lib path (meaning that My::Module will be located at My/Module.pm
within it) the \f(CW\*(C`class_file\*(C'\fR method will take a class name, and check to see
if the file for that class exists in the FileHandler.
.PP
Returns a reference to an \s-1ARRAY\s0 containing the filename if it exists,
or \f(CW\*(C`undef\*(C'\fR on error.
.ie n .SS "find $class"
.el .SS "find \f(CW$class\fP"
.IX Subsection "find $class"
The \f(CW\*(C`find\*(C'\fR method takes as argument a directory root class, and then scans within
the input FileHandler to find all files contained in that class or any
other classes under it's namespace.
.PP
Returns a reference to an \s-1ARRAY\s0 containing all the files within the class,
or \f(CW\*(C`undef\*(C'\fR on error.
.SH "TO DO"
.IX Header "TO DO"
\&\- Convert to using FSI::FileSystem objects, once they exist
.SH "SUPPORT"
.IX Header "SUPPORT"
See the main \s-1SUPPORT\s0 section.
.SH "AUTHOR"
.IX Header "AUTHOR"
Adam Kennedy <adamk@cpan.org>, <http://ali.as/>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004 \- 2010 Adam Kennedy.
.PP
This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.
.PP
The full text of the license can be found in the
\&\s-1LICENSE\s0 file included with this module.
