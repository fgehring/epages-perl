.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Mockify 3"
.TH Test::Mockify 3 "2018-03-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Mockify \- minimal mocking framework for perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Test::Mockify;
\&  use Test::Mockify::Verify qw ( WasCalled );
\&  use Test::Mockify::Matcher qw ( String );
\&
\&  # build a new mocked object
\&  my $MockObjectBuilder = Test::Mockify\->new(\*(AqSampleLogger\*(Aq, []);
\&  $MockObjectBuilder\->mock(\*(Aqlog\*(Aq)\->when(String())\->thenReturnUndef();
\&  my $MockedLogger = $MockLoggerBuilder\->getMockObject();
\&
\&  # inject mocked object into the code you want to test
\&  my $App = SampleApp\->new(\*(Aqlogger\*(Aq=> $MockedLogger);
\&  $App\->do_something();
\&
\&  # verify that the mocked method was called
\&  ok(WasCalled($MockedLogger, \*(Aqlog\*(Aq), \*(Aqlog was called\*(Aq);
\&  done_testing();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Use Test::Mockify to create and configure mock objects. Use Test::Mockify::Verify to
verify the interactions with your mocks. Use Test::Mockify::Sut to inject dependencies into your Sut.
.PP
You can find a Example Project in ExampleProject <https://github.com/ChristianBreitkreutz/Mockify/tree/master/t/ExampleProject>
.PP
Also have a look to Test::Mockify::Sut. This Module provides multiple options to inject mocks into your Sut (System Under Test).
.SH "METHODS"
.IX Header "METHODS"
.SS "getMockObject"
.IX Subsection "getMockObject"
Provides the actual mock object, which you can use in the test.
.PP
.Vb 3
\&  my $aParameterList = [\*(AqSomeValueForConstructor\*(Aq];
\&  my $MockObjectBuilder = Test::Mockify\->new( \*(AqMy::Module\*(Aq, $aParameterList );
\&  my $MyModuleObject = $MockObjectBuilder\->getMockObject();
.Ve
.SS "mock"
.IX Subsection "mock"
This is the place where the mocked methods are defined. The method also proves that the method you like to mock actually exists.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
This method takes one parameter, which is the name of the method you like to mock.
Because you need to specify more detailed the behaviour of this mock you have to chain the method signature (when) and the expected return value (then...).
.PP
For example, the next line will create a mocked version of the method log, but only if this method is called with any string and the number 123. In this case it will return the String 'Hello World'. Mockify will throw an error if this method is called somehow else.
.PP
.Vb 4
\&  my $MockObjectBuilder = Test::Mockify\->new( \*(AqSample::Logger\*(Aq, [] );
\&  $MockObjectBuilder\->mock(\*(Aqlog\*(Aq)\->when(String(), Number(123))\->thenReturn(\*(AqHello World\*(Aq);
\&  my $SampleLogger = $MockObjectBuilder\->getMockObject();
\&  is($SampleLogger\->log(\*(Aqabc\*(Aq,123), \*(AqHello World\*(Aq);
.Ve
.PP
when
.IX Subsection "when"
.PP
To define the signature in the needed structure you must use the Test::Mockify::Matcher.
.PP
whenAny
.IX Subsection "whenAny"
.PP
If you don't want to specify the method signature at all, you can use whenAny.
It is not possible to mix \f(CW\*(C`whenAny\*(C'\fR and \f(CW\*(C`when\*(C'\fR for the same method.
.PP
then ...
.IX Subsection "then ..."
.PP
For possible return types please look in Test::Mockify::ReturnValue
.SS "spy"
.IX Subsection "spy"
Use spy if you want to observe a method. You can use the Test::Mockify::Verify to ensure that the method was called with the expected parameters.
.PP
\fIsynopsis\fR
.IX Subsection "synopsis"
.PP
This method takes one parameter, which is the name of the method you like to spy.
Because you need to specify more detailed the behaviour of this spy you have to define the method signature with \f(CW\*(C`when\*(C'\fR
.PP
For example, the next line will create a method spy of the method log, but only if this method is called with any string and the number 123. Mockify will throw an error if this method is called in another way.
.PP
.Vb 3
\&  my $MockObjectBuilder = Test::Mockify\->new( \*(AqSample::Logger\*(Aq, [] );
\&  $MockObjectBuilder\->spy(\*(Aqlog\*(Aq)\->when(String(), Number(123));
\&  my $SampleLogger = $MockObjectBuilder\->getMockObject();
\&
\&  # call spied method
\&  $SampleLogger\->log(\*(Aqabc\*(Aq, 123);
\&
\&  # verify that the spied method was called
\&  is_deeply(GetParametersFromMockifyCall($MockedLogger, \*(Aqlog\*(Aq),[\*(Aqabc\*(Aq, 123], \*(AqCheck parameters of first call\*(Aq);
.Ve
.PP
when
.IX Subsection "when"
.PP
To define the signature in the needed structure you must use the Test::Mockify::Matcher.
.PP
whenAny
.IX Subsection "whenAny"
.PP
If you don't want to specify the method signature at all, you can use whenAny.
It is not possible to mix \f(CW\*(C`whenAny\*(C'\fR and \f(CW\*(C`when\*(C'\fR for the same method.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2017 ePages GmbH
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Christian Breitkreutz <christianbreitkreutz@gmx.de>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Dustin Buckenmeyer <dustin.buckenmeyer@gmail.com> and \s-1ECS\s0 Tuning <https://www.ecstuning.com/> for giving Dustin the opportunity to pursue this idea and ultimately give it back to the community!
