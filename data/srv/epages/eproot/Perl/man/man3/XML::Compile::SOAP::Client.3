.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::SOAP::Client 3"
.TH XML::Compile::SOAP::Client 3 "2017-01-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::SOAP::Client \- SOAP message initiators
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& XML::Compile::SOAP::Client is extended by
\&   XML::Compile::SOAP11::Client
\&   XML::Compile::SOAP12::Client
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # never used directly, only via XML::Compile::SOAP1[12]::Client
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class defines the methods that each client side of the \s-1SOAP\s0
message exchange protocols must implement.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
This object can not be instantiated, but is only used as secundary
base class.  The primary must contain the \f(CW\*(C`new\*(C'\fR.
.SS "Handlers"
.IX Subsection "Handlers"
.ie n .IP "$obj\->\fBcompileClient\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBcompileClient\fR(%options)" 4
.IX Item "$obj->compileClient(%options)"
.Vb 8
\& \-Option   \-\-Default
\&  async      <false>
\&  decode     <required>
\&  encode     <required>
\&  kind       request\-response
\&  name       <undef>
\&  soap       \*(AqSOAP11\*(Aq
\&  transport  <required>
.Ve
.RS 4
.IP "async => \s-1BOOLEAN\s0" 2
.IX Item "async => BOOLEAN"
If true, a whole different code-reference is returned. Each time it
is called, the call will be made but the function returns immediately.
As additional parameter to the call, you must provide a \f(CW\*(C`_callback\*(C'\fR
parameter which is a code-reference which will handle the result.
.IP "decode => \s-1CODE\s0" 2
.IX Item "decode => CODE"
The \s-1CODE\s0 reference is produced by \fIXML::Compile::SOAP::compileMessage()\fR,
and must be a \s-1RECEIVER:\s0 translate a \s-1SOAP\s0 message into Perl data.  Even in
one-way operation, this decode should be provided: some servers may pass
back some \s-1XML\s0 in case of errors.
.IP "encode => \s-1CODE\s0" 2
.IX Item "encode => CODE"
The \s-1CODE\s0 reference is produced by \fIXML::Compile::SOAP::compileMessage()\fR,
and must be a \s-1SENDER:\s0 translates Perl data structures into the \s-1SOAP\s0
message in \s-1XML\s0.
.IP "kind => \s-1STRING\s0" 2
.IX Item "kind => STRING"
Which kind of client is this.  \s-1WSDL11\s0 defines four kinds of client-server
interaction.  Only \f(CW\*(C`request\-response\*(C'\fR (the default) and \f(CW\*(C`one\-way\*(C'\fR are
currently supported.
.IP "name => \s-1STRING\s0" 2
.IX Item "name => STRING"
.PD 0
.IP "soap => OBJECT|'\s-1SOAP11\s0'|'\s-1SOAP12\s0'" 2
.IX Item "soap => OBJECT|'SOAP11'|'SOAP12'"
.PD
When the transport parameter is an object, this is used to wrap the
\&\s-1SOAP\s0 content according to the matching transporter regulation.
.IP "transport => CODE|OBJECT" 2
.IX Item "transport => CODE|OBJECT"
The \s-1CODE\s0 reference is produced by an extensions of
\&\fIXML::Compile::Transport::compileClient()\fR (usually
\&\fIXML::Compile::Transport::SOAPHTTP::compileClient()\fR.
.Sp
If you pass a XML::Compile::Transport::SOAPHTTP object, the
compileClient will be called for you.  This is possible in case you do
not have any configuration options to pass with the \fIcompileClient()\fR.
.RE
.RS 4
.Sp
example:
.Sp
Normal call:
.Sp
.Vb 3
\&   my $call = $wsdl\->compileClient(\*(AqmyOp\*(Aq);
\&   my ($answer, $trace) = $call\->(@params);
\&   #do something with $answer
.Ve
.Sp
Async call:
.Sp
.Vb 6
\&   my $call = $wsdl\->compileClient(\*(AqmyOp\*(Aq, async => 1);
\&   sub cb
\&   {  my ($answer, $trace) = @_;
\&      #do something with $answer
\&   };
\&   $call\->(@params, _callback => \e&cb);
.Ve
.RE
.SH "DETAILS"
.IX Header "DETAILS"
.SS "Client side \s-1SOAP\s0"
.IX Subsection "Client side SOAP"
\fICalling the server (Document style)\fR
.IX Subsection "Calling the server (Document style)"
.PP
First, you compile the call either via a \s-1WSDL\s0 file (see
XML::Compile::WSDL11), or in a few manual steps (which are described
in the next section).  In either way, you end-up with a \s-1CODE\s0 references
which can be called multiple times.
.PP
.Vb 2
\&    # compile once
\&    my $call   = $soap\->compileClient(...);
\&
\&    # and call often
\&    my $answer = $call\->(%request);  # list of pairs
\&    my $answer = $call\->(\e%request); # same, but HASH
\&    my $answer = $call\->(\e%request, \*(AqUTF\-8\*(Aq);  # same
\&
\&    # or with trace details, see XML::Compile::SOAP::Trace
\&    my ($answer, $trace) = $call\->...
.Ve
.PP
But what is the structure of \f(CW%request\fR and \f(CW$answer\fR?  Well, there
are various syntaxes possible: from structurally perfect, to user-friendly.
.PP
First, find out which data structures can be present: when you compiled
your messages explicitly, you have picked your own names.  When the
call was initiated from a \s-1WSDL\s0 file, then you have to find the names of
the message parts which can be used: the part names for header blocks,
body blocks, headerfaults, and (body) faults.  Do not worry to much,
you will get (hopefully understandable) run-time error messages when
the structure is incorrect.
.PP
Let's say that the \s-1WSDL\s0 defines this (ignoring all name-space issues)
.PP
.Vb 5
\& <definitions xmlns:xx="MYNS"
\&   <message name="GetLastTradePriceInput">
\&    <part name="count" type="int" />
\&    <part name="request" element="xx:TradePriceRequest"/>
\&   </message>
\&
\&   <message name="GetLastTradePriceOutput">
\&    <part name="answer" element="xx:TradePrice"/>
\&   </message>
\&
\&   <binding
\&    <operation
\&     <input>
\&      <soap:header message="GetLastTradePriceInput" part="count"
\&      <soap:body message="GetLastTradePriceInput" parts="request"
\&     <output>
\&      <soap:body message="GetLastTradePriceOutput"
.Ve
.PP
The input message needs explicitly named parts in this case, where the
output message simply uses all defined in the body.  So, the input message
has one header part \f(CW\*(C`count\*(C'\fR, and one body part \f(CW\*(C`request\*(C'\fR.  The output
message only has one part named \f(CW\*(C`answer\*(C'\fR, which is all defined for the
message and therefore its name can be omitted.
.PP
Then, the definitions of the blocks:
.PP
.Vb 5
\& <schema targetNamespace="MYNS"
\&   <element name="TradePriceRequest">
\&    <complexType>
\&     <all>
\&      <element name="tickerSymbol" type="string"/>
\&
\&   <element name="TradePrice">
\&    <complexType>
\&     <all>
\&      <element name="price" type="float"/>
\& </schema>
.Ve
.PP
Now, calling the compiled function can be done like this:
.PP
.Vb 5
\&  my $got
\&     = $call\->(  count => 5, request => {tickerSymbol => \*(AqIBM\*(Aq}  );
\&     = $call\->({ count => 5, request => {tickerSymbol => \*(AqIBM\*(Aq} });
\&     = $call\->({ count => 5, request => {tickerSymbol => \*(AqIBM\*(Aq} }
\&        , \*(AqUTF\-8\*(Aq);
.Ve
.PP
If the first arguments for the code ref is a \s-1HASH\s0, then there may be
a second which specifies the required character-set.  The default is
\&\f(CW\*(C`UTF\-8\*(C'\fR, which is very much advised.
.PP
\fIParameter unpacking (Document Style)\fR
.IX Subsection "Parameter unpacking (Document Style)"
.PP
In the example situation of previous section, you may simplify the
call even further.  To understand how, we need to understand the
parameter unpacking algorithm.
.PP
The structure which we need to end up with, looks like this
.PP
.Vb 5
\&  $call\->(\e%data, $charset);
\&  %data = ( Header => {count => 5}
\&          , Body   =>
\&             { request => {tickerSymbol => \*(AqIBM\*(Aq} }
\&          );
.Ve
.PP
The structure of the \s-1SOAP\s0 message is directly mapped on this
nested complex \s-1HASH\s0.  But is inconvenient to write each call
like this, therefore the \f(CW$call\fR parameters are transformed into
the required structure according to the following rules:
.IP "1." 4
if called with a \s-1LIST\s0, then that will become a \s-1HASH\s0
.IP "2." 4
when a \f(CW\*(C`Header\*(C'\fR and/or \f(CW\*(C`Body\*(C'\fR are found in the \s-1HASH\s0, those are used
.IP "3." 4
if there are more parameters in the \s-1HASH\s0, then those with names of
known header and headerfault message parts are moved to the \f(CW\*(C`Header\*(C'\fR
sub-structure.  Body and fault message parts are moved to the \f(CW\*(C`Body\*(C'\fR
sub-structure.
.IP "4." 4
If the \f(CW\*(C`Body\*(C'\fR sub-structure is empty, and there is only one body part
expected, then all remaining parameters are put in a \s-1HASH\s0 for that part.
This also happens if there are not parameters: it will result in an
empty \s-1HASH\s0 for that block.
.PP
So, in our case this will also do, because \f(CW\*(C`count\*(C'\fR is a known part,
and \f(CW\*(C`request\*(C'\fR gets all left-overs, being the only body part.
.PP
.Vb 1
\& my $got = $call\->(count => 5, tickerSymbol => \*(AqIBM\*(Aq);
.Ve
.PP
This does not work if the block element is a simple type.  In most
existing Document style \s-1SOAP\s0 schemas, this simplification probably
is possible.
.PP
\fIUnderstanding the output (Document style)\fR
.IX Subsection "Understanding the output (Document style)"
.PP
The \f(CW$got\fR is a \s-1HASH\s0, which will not be simplified automatically:
it may change with future extensions of the interface.  The return
is a complex nested structure, and Data::Dumper is your friend.
.PP
.Vb 1
\& $got = { answer => { price => 16.3 } }
.Ve
.PP
To access the value use
.PP
.Vb 2
\& printf "%.2f US\e$\en", $got\->{answer}\->{price};
\& printf "%.2f US\e$\en", $got\->{answer}{price};   # same
.Ve
.PP
or
.PP
.Vb 2
\& my $answer = $got\->{answer};
\& printf "%.2f US\e$\en", $answer\->{price};
.Ve
.PP
\fICalling the server (SOAP-RPC style literal)\fR
.IX Subsection "Calling the server (SOAP-RPC style literal)"
.PP
SOAP-RPC style messages which have \f(CW\*(C`<use=literal\*(C'\fR> cannot be used
without a little help.  However, one extra definition per procedure
call suffices.
.PP
This a complete code example, although you need to fill in some
specifics about your environment.  If you have a \s-1WSDL\s0 file, then it
will be a little simpler, see \fIXML::Compile::WSDL11::compileClient()\fR.
.PP
.Vb 4
\& # You probably need these
\& use XML::Compile::SOAP11::Client;
\& use XML::Compile::Transport::SOAPHTTP;
\& use XML::Compile::Util  qw/pack_type/;
\&
\& # Literal style RPC
\& my $outtype = pack_type $MYNS, \*(AqmyFunction\*(Aq;
\& my $intype  = pack_type $MYNS, \*(AqmyFunctionResponse\*(Aq;
\&
\& # Encoded style RPC (see next section on these functions)
\& my $outtype = \e&my_pack_params;
\& my $intype  = \e&my_unpack_params;
\&
\& # For all RPC calls, you need this only once (or have a WSDL):
\& my $transp  = XML::Compile::Transport::SOAPHTTP\->new(...);
\& my $http    = $transp\->compileClient(...);
\& my $soap    = XML::Compile::SOAP11::Client\->new(...);
\& my $send    = $soap\->compileMessage(\*(AqSENDER\*(Aq,   style => $style, ...);
\& my $get     = $soap\->compileMessage(\*(AqRECEIVER\*(Aq, style => $style, ...);
\&
\& # Per RPC procedure
\& my $myproc = $soap\->compileClient
\&   ( name   => \*(AqMyProc\*(Aq
\&   , encode => $send, decode => $get, transport => $http
\&   );
\&
\& my $answer = $myproc\->(@parameters);   # as document style
.Ve
.PP
Actually, the \f(CW@paramers\fR are slightly less flexible as in document
style \s-1SOAP\s0.  If you use header blocks, then the called \s-1CODE\s0 reference
will not be able to distinguish between parameters for the \s-1RPC\s0 block and
parameters for the header blocks.
.PP
.Vb 4
\&  my $answer = $trade_price
\&    \->( {symbol => \*(AqIBM\*(Aq}    # the RPC package implicit
\&      , transaction => 5     # in the header
\&      );
.Ve
.PP
When the number of arguments is odd, the first is indicating the \s-1RPC\s0
element, and the other pairs refer to header blocks.
.PP
The \f(CW$answer\fR structure may contain a \f(CW\*(C`Fault\*(C'\fR entry, or a decoded
datastructure with the results of your query.  One call using
Data::Dumper will show you more than I can explain in a few hundred
words.
.PP
\fICalling the server (SOAP-RPC style, encoded)\fR
.IX Subsection "Calling the server (SOAP-RPC style, encoded)"
.PP
SOAP-RPC is a simplification of the interface description: basically,
the interface is not described at all, but left to good communication
between the client and server authors.  In strongly typed languages,
this is quite simple to enforce: the client side and server side use
the same method prototypes.  However, in Perl we are blessed to go
without these strongly typed prototypes.
.PP
The approach of SOAP::Lite, is to guess the types of the passed
parameters.  For instance, \*(L"42\*(R" will get passed as Integer.  This
may lead to nasty problems: a float parameter \*(L"2.0\*(R" will get passed
as integer \*(L"2\*(R", or a string representing a house number \*(L"8\*(R" is passed
as an number.  This may not be accepted by the \s-1SOAP\s0 server.
.PP
So, using SOAP-RPC in XML::Compile::SOAP will ask a little more
effort from you: you have to state parameter types explicitly.  In
the \fIexamples/namesservice/\fR directory, you find a detailed example.
You have to create a \s-1CODE\s0 ref which produces the message, using
methods defined provided by XML::Compile::SOAP11::Encoding.
.PP
\fIFaults (Document and \s-1RPC\s0 style)\fR
.IX Subsection "Faults (Document and RPC style)"
.PP
Faults and headerfaults are a slightly different story: the type which
is specified with them is not of the fault \s-1XML\s0 node itself, but of the
\&\f(CW\*(C`detail\*(C'\fR sub-element within the standard fault structure.
.PP
When producing the data for faults, you must be aware of the fact that
the structure is different for \s-1SOAP1\s0.1 and \s-1SOAP1\s0.2.  When interpreting
faults, the same problems are present, although the implementation
tries to help you by hiding the differences.
.PP
Check whether \s-1SOAP1\s0.1 or \s-1SOAP1\s0.2 is used by looking for a \f(CW\*(C`faultcode\*(C'\fR
(\s-1SOAP1\s0.1) or a \f(CW\*(C`Code\*(C'\fR (\s-1SOAP1\s0.2) field in the data:
.PP
.Vb 5
\&  if(my $fault = $got\->{Fault})
\&  {  if($fault\->{faultcode}) { ... SOAP1.1 ... }
\&     elsif($fault\->{Code})   { ... SOAP1.2 ... }
\&     else { die }
\&  }
.Ve
.PP
In either protocol case, the following will get you at a compatible
structure in two steps:
.PP
.Vb 5
\&  if(my $fault = $got\->{Fault})
\&  {   my $decoded = fault\->{_NAME}};
\&      print $got\->{$decoded}\->{code};
\&      ...
\&  }
.Ve
.PP
See the respective manuals XML::Compile::SOAP11 and
XML::Compile::SOAP12 for the hairy details.  But one thing can be said:
when the fault is declared formally, then the \f(CW\*(C`_NAME\*(C'\fR will be the name
of that part.
.SS "\s-1SOAP\s0 without \s-1WSDL\s0 (Document style)"
.IX Subsection "SOAP without WSDL (Document style)"
See the manual page of XML::Compile::WSDL11 to see how simple you
can use this module when you have a \s-1WSDL\s0 file at hand.  The creation of
a correct \s-1WSDL\s0 file is \s-1NOT\s0 \s-1SIMPLE\s0.
.PP
When using \s-1SOAP\s0 without \s-1WSDL\s0 file, it gets a little bit more complicate
to use: you need to describe the content of the messages yourself.
The following example is used as test-case \f(CW\*(C`t/10soap11.t\*(C'\fR, directly
taken from the \s-1SOAP11\s0 specs section 1.3 example 1.
.PP
.Vb 4
\& # for simplification
\& my $TestNS   = \*(Aqhttp://test\-types\*(Aq;
\& use XML::Compile::Util qw/SCHEMA2001/;
\& my $SchemaNS = SCHEMA2001;
.Ve
.PP
First, the schema (hopefully someone else created for you, because they
can be quite hard to create correctly) is in file \f(CW\*(C`myschema.xsd\*(C'\fR
.PP
.Vb 2
\& <schema targetNamespace="$TestNS"
\&   xmlns="$SchemaNS">
\&
\& <element name="GetLastTradePrice">
\&   <complexType>
\&      <all>
\&        <element name="symbol" type="string"/>
\&      </all>
\&   </complexType>
\& </element>
\&
\& <element name="GetLastTradePriceResponse">
\&   <complexType>
\&      <all>
\&         <element name="price" type="float"/>
\&      </all>
\&   </complexType>
\& </element>
\&
\& <element name="Transaction" type="int"/>
\& </schema>
.Ve
.PP
Ok, now the program you create the request:
.PP
.Vb 2
\& use XML::Compile::SOAP11;
\& use XML::Compile::Util  qw/pack_type/;
\&
\& my $soap   = XML::Compile::SOAP11\->new;
\& $soap\->schemas\->importDefinitions(\*(Aqmyschema.xsd\*(Aq);
\&
\& my $get_price = $soap\->compileMessage
\&   ( \*(AqSENDER\*(Aq
\&   , header =>
\&      [ transaction => pack_type($TestNS, \*(AqTransaction\*(Aq) ]
\&   , body  =>
\&      [ request => pack_type($TestNS, \*(AqGetLastTradePrice\*(Aq) ]
\&   , mustUnderstand => \*(Aqtransaction\*(Aq
\&   , destination    => [ transaction => \*(AqNEXT http://actor\*(Aq ]
\&   );
.Ve
.PP
\&\f(CW\*(C`INPUT\*(C'\fR is used in the \s-1WSDL\s0 terminology, indicating this message is
an input message for the server.  This \f(CW$get_price\fR is a \s-1WRITER\s0.  Above
is done only once in the initialization phase of your program.
.PP
At run-time, you have to call the \s-1CODE\s0 reference with a
data-structure which is compatible with the schema structure.
(See \fIXML::Compile::Schema::template()\fR if you have no clue how it should
look)  So: let's send this:
.PP
.Vb 3
\& # insert your data
\& my %data_in = (transaction => 5, request => {symbol => \*(AqDIS\*(Aq});
\& my %data_in = (transaction => 5, symbol => \*(AqDIS\*(Aq); # alternative
\&
\& # create a XML::LibXML tree
\& my $xml  = $get_price\->(\e%data_in, \*(AqUTF\-8\*(Aq);
\& print $xml\->toString;
.Ve
.PP
And the output is:
.PP
.Vb 10
\& <SOAP\-ENV:Envelope
\&    xmlns:x0="http://test\-types"
\&    xmlns:SOAP\-ENV="http://schemas.xmlsoap.org/soap/envelope/">
\&   <SOAP\-ENV:Header>
\&     <x0:Transaction
\&       mustUnderstand="1"
\&       actor="http://schemas.xmlsoap.org/soap/actor/next http://actor">
\&         5
\&     </x0:Transaction>
\&   </SOAP\-ENV:Header>
\&   <SOAP\-ENV:Body>
\&     <x0:GetLastTradePrice>
\&       <symbol>DIS</symbol>
\&     </x0:GetLastTradePrice>
\&   </SOAP\-ENV:Body>
\& </SOAP\-ENV:Envelope>
.Ve
.PP
Some transport protocol will sent this data from the client to the
server.  See XML::Compile::Transport::SOAPHTTP, as one example.
.PP
On the \s-1SOAP\s0 server side, we will parse the message.  The string \f(CW$soap\fR
contains the \s-1XML\s0.  The program looks like this:
.PP
.Vb 5
\& my $server = $soap\->compileMessage # create once
\&  ( \*(AqRECEIVER\*(Aq
\&  , header => [ transaction => pack_type($TestNS, \*(AqTransaction\*(Aq) ]
\&  , body   => [ request => pack_type($TestNS, \*(AqGetLastTradePrice\*(Aq) ]
\&  );
\&
\& my $data_out = $server\->($soap);   # call often
.Ve
.PP
Now, the \f(CW$data_out\fR reference on the server, is stucturally exactly 
equivalent to the \f(CW%data_in\fR from the client.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile-SOAP distribution version 3.21,
built on January 11, 2017. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2017 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
