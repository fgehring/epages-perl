.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::LibXML::Simple 3"
.TH XML::LibXML::Simple 3 "2016-04-12" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::LibXML::Simple \- XML::LibXML clone of XML::Simple::XMLin()
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 2
\& XML::LibXML::Simple
\&   is a Exporter
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $xml  = ...;  # filename, fh, string, or XML::LibXML\-node
.Ve
.PP
Imperative:
.PP
.Vb 2
\&  use XML::LibXML::Simple   qw(XMLin);
\&  my $data = XMLin $xml, %options;
.Ve
.PP
Or the Object Oriented way:
.PP
.Vb 3
\&  use XML::LibXML::Simple   ();
\&  my $xs   = XML::LibXML::Simple\->new(%options);
\&  my $data = $xs\->XMLin($xml, %options);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is a blunt rewrite of XML::Simple (by Grant McLean) to
use the XML::LibXML parser for \s-1XML\s0 structures, where the original
uses plain Perl or \s-1SAX\s0 parsers.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.IP "XML::LibXML::Simple\->\fBnew\fR(%options)" 4
.IX Item "XML::LibXML::Simple->new(%options)"
Instantiate an object, which can be used to call \fIXMLin()\fR on.  You can
provide \f(CW%options\fR to this constructor (to be reused for each call to XMLin)
and with each call of XMLin (to be used once)
.Sp
For descriptions of the \f(CW%options\fR see the \*(L"\s-1DETAILS\s0\*(R"
section of this manual page.
.SS "Translators"
.IX Subsection "Translators"
.ie n .IP "$obj\->\fBXMLin\fR($xmldata, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBXMLin\fR($xmldata, \f(CW%options\fR)" 4
.IX Item "$obj->XMLin($xmldata, %options)"
For \f(CW$xmldata\fR and descriptions of the \f(CW%options\fR see the \*(L"\s-1DETAILS\s0\*(R"
section of this manual page.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The functions \f(CW\*(C`XMLin\*(C'\fR (exported implictly) and \f(CW\*(C`xml_in\*(C'\fR
(exported on request) simply call \f(CW\*(C`<XML::LibXML::Simple\-\*(C'\fRnew\->\fIXMLin()\fR >>
with the provided parameters.
.SH "DETAILS"
.IX Header "DETAILS"
.ie n .SS "Parameter $xmldata"
.el .SS "Parameter \f(CW$xmldata\fP"
.IX Subsection "Parameter $xmldata"
As first parameter to \fIXMLin()\fR must provide the \s-1XML\s0 message to be
translated into a Perl structure.  Choose one of the following:
.IP "A filename" 4
.IX Item "A filename"
If the filename contains no directory components, \f(CW\*(C`XMLin()\*(C'\fR will look for the
file in each directory in the SearchPath (see \s-1OPTIONS\s0 below) and in the
current directory.  eg:
.Sp
.Vb 1
\&  $data = XMLin(\*(Aq/etc/params.xml\*(Aq, %options);
.Ve
.IP "A dash  (\-)" 4
.IX Item "A dash  (-)"
Parse from \s-1STDIN\s0.
.Sp
.Vb 1
\&  $data = XMLin(\*(Aq\-\*(Aq, %options);
.Ve
.IP "undef" 4
.IX Item "undef"
[deprecated]
If there is no \s-1XML\s0 specifier, \f(CW\*(C`XMLin()\*(C'\fR will check the script directory and
each of the SearchPath directories for a file with the same name as the script
but with the extension '.xml'.  Note: if you wish to specify options, you
must specify the value 'undef'.  eg:
.Sp
.Vb 1
\&  $data = XMLin(undef, ForceArray => 1);
.Ve
.Sp
This feature is available for backwards compatibility with XML::Simple,
but quite sensitive.  You can easily hit the wrong xml file as input.
Please do not use it: always use an explicit filename.
.IP "A string of \s-1XML\s0" 4
.IX Item "A string of XML"
A string containing \s-1XML\s0 (recognised by the presence of '<' and '>' characters)
will be parsed directly.  eg:
.Sp
.Vb 1
\&  $data = XMLin(\*(Aq<opt username="bob" password="flurp" />\*(Aq, %options);
.Ve
.IP "An IO::Handle object" 4
.IX Item "An IO::Handle object"
In this case, XML::LibXML::Parser will read the \s-1XML\s0 data directly from
the provided file.
.Sp
.Vb 2
\&  # $fh = IO::File\->new(\*(Aq/etc/params.xml\*(Aq) or die;
\&  open my $fh, \*(Aq<:encoding(utf8)\*(Aq, \*(Aq/etc/params.xml\*(Aq or die;
\&
\&  $data = XMLin($fh, %options);
.Ve
.IP "An XML::LibXML::Document or ::Element" 4
.IX Item "An XML::LibXML::Document or ::Element"
[Not available in XML::Simple] When you have a pre-parsed XML::LibXML
node, you can pass that.
.ie n .SS "Parameter %options"
.el .SS "Parameter \f(CW%options\fP"
.IX Subsection "Parameter %options"
XML::LibXML::Simple supports most options defined by XML::Simple, so
the interface is quite compatible.  Minor changes apply.  This explanation
is extracted from the XML::Simple manual-page.
.IP "\(bu" 4
check out \f(CW\*(C`ForceArray\*(C'\fR because you'll almost certainly want to turn it on
.IP "\(bu" 4
make sure you know what the \f(CW\*(C`KeyAttr\*(C'\fR option does and what its default
value is because it may surprise you otherwise.
.IP "\(bu" 4
Option names are case in-sensitive so you can use the mixed case versions
shown here; you can add underscores between the words (eg: key_attr)
if you like.
.PP
In alphabetic order:
.IP "ContentKey => 'keyname' \fI# seldom used\fR" 4
.IX Item "ContentKey => 'keyname' # seldom used"
When text content is parsed to a hash value, this option let's you specify a
name for the hash key to override the default 'content'.  So for example:
.Sp
.Vb 1
\&  XMLin(\*(Aq<opt one="1">Two</opt>\*(Aq, ContentKey => \*(Aqtext\*(Aq)
.Ve
.Sp
will parse to:
.Sp
.Vb 1
\&  { one => 1, text => \*(AqTwo\*(Aq }
.Ve
.Sp
instead of:
.Sp
.Vb 1
\&  { one => 1, content => \*(AqTwo\*(Aq }
.Ve
.Sp
You can also prefix your selected key name with a '\-' character to have 
\&\f(CW\*(C`XMLin()\*(C'\fR try a little harder to eliminate unnecessary 'content' keys after
array folding.  For example:
.Sp
.Vb 6
\&  XMLin(
\&    \*(Aq<opt><item name="one">First</item><item name="two">Second</item></opt>\*(Aq, 
\&    KeyAttr => {item => \*(Aqname\*(Aq}, 
\&    ForceArray => [ \*(Aqitem\*(Aq ],
\&    ContentKey => \*(Aq\-content\*(Aq
\&  )
.Ve
.Sp
will parse to:
.Sp
.Vb 6
\&  {
\&     item => {
\&      one =>  \*(AqFirst\*(Aq
\&      two =>  \*(AqSecond\*(Aq
\&    }
\&  }
.Ve
.Sp
rather than this (without the '\-'):
.Sp
.Vb 6
\&  {
\&    item => {
\&      one => { content => \*(AqFirst\*(Aq }
\&      two => { content => \*(AqSecond\*(Aq }
\&    }
\&  }
.Ve
.IP "ForceArray => 1 \fI# important\fR" 4
.IX Item "ForceArray => 1 # important"
This option should be set to '1' to force nested elements to be represented
as arrays even when there is only one.  Eg, with ForceArray enabled, this
\&\s-1XML:\s0
.Sp
.Vb 3
\&    <opt>
\&      <name>value</name>
\&    </opt>
.Ve
.Sp
would parse to this:
.Sp
.Vb 1
\&    { name => [ \*(Aqvalue\*(Aq ] }
.Ve
.Sp
instead of this (the default):
.Sp
.Vb 1
\&    { name => \*(Aqvalue\*(Aq }
.Ve
.Sp
This option is especially useful if the data structure is likely to be written
back out as \s-1XML\s0 and the default behaviour of rolling single nested elements up
into attributes is not desirable.
.Sp
If you are using the array folding feature, you should almost certainly
enable this option.  If you do not, single nested elements will not be
parsed to arrays and therefore will not be candidates for folding to a
hash.  (Given that the default value of 'KeyAttr' enables array folding,
the default value of this option should probably also have been enabled
as well).
.IP "ForceArray => [ names ] \fI# important\fR" 4
.IX Item "ForceArray => [ names ] # important"
This alternative (and preferred) form of the 'ForceArray' option allows you to
specify a list of element names which should always be forced into an array
representation, rather than the 'all or nothing' approach above.
.Sp
It is also possible to include compiled regular
expressions in the list \-\-any element names which match the pattern
will be forced to arrays.  If the list contains only a single regex,
then it is not necessary to enclose it in an arrayref.  Eg:
.Sp
.Vb 1
\&  ForceArray => qr/_list$/
.Ve
.IP "ForceContent => 1 \fI# seldom used\fR" 4
.IX Item "ForceContent => 1 # seldom used"
When \f(CW\*(C`XMLin()\*(C'\fR parses elements which have text content as well as attributes,
the text content must be represented as a hash value rather than a simple
scalar.  This option allows you to force text content to always parse to
a hash value even when there are no attributes.  So for example:
.Sp
.Vb 1
\&  XMLin(\*(Aq<opt><x>text1</x><y a="2">text2</y></opt>\*(Aq, ForceContent => 1)
.Ve
.Sp
will parse to:
.Sp
.Vb 4
\&  {
\&    x => {         content => \*(Aqtext1\*(Aq },
\&    y => { a => 2, content => \*(Aqtext2\*(Aq }
\&  }
.Ve
.Sp
instead of:
.Sp
.Vb 4
\&  {
\&    x => \*(Aqtext1\*(Aq,
\&    y => { \*(Aqa\*(Aq => 2, \*(Aqcontent\*(Aq => \*(Aqtext2\*(Aq }
\&  }
.Ve
.IP "GroupTags => { grouping tag => grouped tag } \fI# handy\fR" 4
.IX Item "GroupTags => { grouping tag => grouped tag } # handy"
You can use this option to eliminate extra levels of indirection in your Perl
data structure.  For example this \s-1XML:\s0
.Sp
.Vb 7
\&  <opt>
\&   <searchpath>
\&     <dir>/usr/bin</dir>
\&     <dir>/usr/local/bin</dir>
\&     <dir>/usr/X11/bin</dir>
\&   </searchpath>
\& </opt>
.Ve
.Sp
Would normally be read into a structure like this:
.Sp
.Vb 5
\&  {
\&    searchpath => {
\&       dir => [ \*(Aq/usr/bin\*(Aq, \*(Aq/usr/local/bin\*(Aq, \*(Aq/usr/X11/bin\*(Aq ]
\&    }
\&  }
.Ve
.Sp
But when read in with the appropriate value for 'GroupTags':
.Sp
.Vb 1
\&  my $opt = XMLin($xml, GroupTags => { searchpath => \*(Aqdir\*(Aq });
.Ve
.Sp
It will return this simpler structure:
.Sp
.Vb 3
\&  {
\&    searchpath => [ \*(Aq/usr/bin\*(Aq, \*(Aq/usr/local/bin\*(Aq, \*(Aq/usr/X11/bin\*(Aq ]
\&  }
.Ve
.Sp
The grouping element (\f(CW\*(C`<searchpath>\*(C'\fR in the example) must not contain any
attributes or elements other than the grouped element.
.Sp
You can specify multiple 'grouping element' to 'grouped element' mappings in
the same hashref.  If this option is combined with \f(CW\*(C`KeyAttr\*(C'\fR, the array
folding will occur first and then the grouped element names will be eliminated.
.IP "HookNodes => \s-1CODE\s0" 4
.IX Item "HookNodes => CODE"
Select document nodes to apply special tricks.
Introduced in [0.96], not available in XML::Simple.
.Sp
When this option is provided, the \s-1CODE\s0 will be called once the \s-1XML\s0 \s-1DOM\s0
tree is ready to get transformed into Perl.  Your \s-1CODE\s0 should return
either \f(CW\*(C`undef\*(C'\fR (nothing to do) or a \s-1HASH\s0 which maps values of
unique_key (see XML::LibXML::Node method \f(CW\*(C`unique_key\*(C'\fR onto \s-1CODE\s0
references to be called.
.Sp
Once the translater from \s-1XML\s0 into Perl reaches a selected node, it will
call your routine specific for that node.  That triggering node found
is the only parameter.  When you return \f(CW\*(C`undef\*(C'\fR, the node will not be
found in the final result.  You may return any data (even the node itself)
which will be included in the final result as is, under the name of the
original node.
.Sp
Example:
.Sp
.Vb 1
\&   my $out = XMLin $file, HookNodes => \e&protect_html;
\&
\&   sub protect_html($$)
\&   {   # $obj is the instantated XML::Compile::Simple object
\&       # $xml is a XML::LibXML::Element to get transformed
\&       my ($obj, $xml) = @_;
\&
\&       my %hooks;    # collects the table of hooks
\&
\&       # do an xpath search for HTML
\&       my $xpc   = XML::LibXML::XPathContext\->new($xml);
\&       my @nodes = $xpc\->findNodes(...); #XXX
\&       @nodes or return undef;
\&
\&       my $as_text = sub { $_[0]\->toString(0) };  # as text
\&       #  $as_node = sub { $_[0] };               # as node
\&       #  $skip    = sub { undef };               # not at all
\&
\&       # the same behavior for all xpath nodes, in this example
\&       $hook{$_\->unique_key} = $as_text
\&           for @nodes;
\& 
\&       \e%hook;
\&   }
.Ve
.IP "KeepRoot => 1 \fI# handy\fR" 4
.IX Item "KeepRoot => 1 # handy"
In its attempt to return a data structure free of superfluous detail and
unnecessary levels of indirection, \f(CW\*(C`XMLin()\*(C'\fR normally discards the root
element name.  Setting the 'KeepRoot' option to '1' will cause the root element
name to be retained.  So after executing this code:
.Sp
.Vb 1
\&  $config = XMLin(\*(Aq<config tempdir="/tmp" />\*(Aq, KeepRoot => 1)
.Ve
.Sp
You'll be able to reference the tempdir as
\&\f(CW\*(C`$config\->{config}\->{tempdir}\*(C'\fR instead of the default
\&\f(CW\*(C`$config\->{tempdir}\*(C'\fR.
.IP "KeyAttr => [ list ] \fI# important\fR" 4
.IX Item "KeyAttr => [ list ] # important"
This option controls the 'array folding' feature which translates nested
elements from an array to a hash.  It also controls the 'unfolding' of hashes
to arrays.
.Sp
For example, this \s-1XML:\s0
.Sp
.Vb 4
\&    <opt>
\&      <user login="grep" fullname="Gary R Epstein" />
\&      <user login="stty" fullname="Simon T Tyson" />
\&    </opt>
.Ve
.Sp
would, by default, parse to this:
.Sp
.Vb 10
\&    {
\&      user => [
\&         { login    => \*(Aqgrep\*(Aq,
\&           fullname => \*(AqGary R Epstein\*(Aq
\&         },
\&         { login    => \*(Aqstty\*(Aq,
\&           fullname => \*(AqSimon T Tyson\*(Aq
\&         }
\&      ]
\&    }
.Ve
.Sp
If the option 'KeyAttr => \*(L"login\*(R"' were used to specify that the 'login'
attribute is a key, the same \s-1XML\s0 would parse to:
.Sp
.Vb 6
\&    {
\&      user => {
\&         stty => { fullname => \*(AqSimon T Tyson\*(Aq },
\&         grep => { fullname => \*(AqGary R Epstein\*(Aq }
\&      }
\&    }
.Ve
.Sp
The key attribute names should be supplied in an arrayref if there is more
than one.  \f(CW\*(C`XMLin()\*(C'\fR will attempt to match attribute names in the order
supplied.
.Sp
Note 1: The default value for 'KeyAttr' is \f(CW\*(C`[\*(Aqname\*(Aq, \*(Aqkey\*(Aq, \*(Aqid\*(Aq]\*(C'\fR.
If you do not want folding on input or unfolding on output you must
setting this option to an empty list to disable the feature.
.Sp
Note 2: If you wish to use this option, you should also enable the
\&\f(CW\*(C`ForceArray\*(C'\fR option.  Without 'ForceArray', a single nested element will be
rolled up into a scalar rather than an array and therefore will not be folded
(since only arrays get folded).
.IP "KeyAttr => { list } \fI# important\fR" 4
.IX Item "KeyAttr => { list } # important"
This alternative (and preferred) method of specifiying the key attributes
allows more fine grained control over which elements are folded and on which
attributes.  For example the option 'KeyAttr => { package => 'id' } will cause
any package elements to be folded on the 'id' attribute.  No other elements
which have an 'id' attribute will be folded at all.
.Sp
Two further variations are made possible by prefixing a '+' or a '\-' character
to the attribute name:
.Sp
The option 'KeyAttr => { user => \*(L"+login\*(R" }' will cause this \s-1XML:\s0
.Sp
.Vb 4
\&    <opt>
\&      <user login="grep" fullname="Gary R Epstein" />
\&      <user login="stty" fullname="Simon T Tyson" />
\&    </opt>
.Ve
.Sp
to parse to this data structure:
.Sp
.Vb 12
\&    {
\&      user => {
\&         stty => {
\&            fullname => \*(AqSimon T Tyson\*(Aq,
\&            login    => \*(Aqstty\*(Aq
\&         },
\&         grep => {
\&            fullname => \*(AqGary R Epstein\*(Aq,
\&            login    => \*(Aqgrep\*(Aq
\&         }
\&      }
\&    }
.Ve
.Sp
The '+' indicates that the value of the key attribute should be copied
rather than moved to the folded hash key.
.Sp
A '\-' prefix would produce this result:
.Sp
.Vb 12
\&    {
\&      user => {
\&         stty => {
\&            fullname => \*(AqSimon T Tyson\*(Aq,
\&            \-login   => \*(Aqstty\*(Aq
\&         },
\&         grep => {
\&            fullname => \*(AqGary R Epstein\*(Aq,
\&            \-login    => \*(Aqgrep\*(Aq
\&         }
\&      }
\&    }
.Ve
.IP "NoAttr => 1 \fI# handy\fR" 4
.IX Item "NoAttr => 1 # handy"
When used with \f(CW\*(C`XMLin()\*(C'\fR, any attributes in the \s-1XML\s0 will be ignored.
.IP "NormaliseSpace => 0 | 1 | 2 \fI# handy\fR" 4
.IX Item "NormaliseSpace => 0 | 1 | 2 # handy"
This option controls how whitespace in text content is handled.  Recognised
values for the option are:
.RS 4
.ie n .IP """0""" 4
.el .IP "``0''" 4
.IX Item "0"
(default) whitespace is passed through unaltered (except of course for the
normalisation of whitespace in attribute values which is mandated by the \s-1XML\s0
recommendation)
.ie n .IP """1""" 4
.el .IP "``1''" 4
.IX Item "1"
whitespace is normalised in any value used as a hash key (normalising means
removing leading and trailing whitespace and collapsing sequences of whitespace
characters to a single space)
.ie n .IP """2""" 4
.el .IP "``2''" 4
.IX Item "2"
whitespace is normalised in all text content
.RE
.RS 4
.Sp
Note: you can spell this option with a 'z' if that is more natural for you.
.RE
.IP "Parser => \s-1OBJECT\s0" 4
.IX Item "Parser => OBJECT"
You may pass your own XML::LibXML object, in stead of having one
created for you. This is useful when you need specific configuration
on that object (See XML::LibXML::Parser) or have implemented your
own extension to that object.
.Sp
The internally created parser object is configured in safe mode.
Read the XML::LibXML::Parser manual about security issues with
certain parameter settings.  The default is unsafe!
.IP "ParserOpts => HASH|ARRAY" 4
.IX Item "ParserOpts => HASH|ARRAY"
Pass parameters to the creation of a new internal parser object. You
can overrule the options which will create a safe parser. It may be more
readible to use the \f(CW\*(C`Parser\*(C'\fR parameter.
.IP "SearchPath => [ list ] \fI# handy\fR" 4
.IX Item "SearchPath => [ list ] # handy"
If you pass \f(CW\*(C`XMLin()\*(C'\fR a filename, but the filename include no directory
component, you can use this option to specify which directories should be
searched to locate the file.  You might use this option to search first in the
user's home directory, then in a global directory such as /etc.
.Sp
If a filename is provided to \f(CW\*(C`XMLin()\*(C'\fR but SearchPath is not defined, the
file is assumed to be in the current directory.
.Sp
If the first parameter to \f(CW\*(C`XMLin()\*(C'\fR is undefined, the default SearchPath
will contain only the directory in which the script itself is located.
Otherwise the default SearchPath will be empty.
.IP "ValueAttr => [ names ] \fI# handy\fR" 4
.IX Item "ValueAttr => [ names ] # handy"
Use this option to deal elements which always have a single attribute and no
content.  Eg:
.Sp
.Vb 4
\&  <opt>
\&    <colour value="red" />
\&    <size   value="XXL" />
\&  </opt>
.Ve
.Sp
Setting \f(CW\*(C`ValueAttr => [ \*(Aqvalue\*(Aq ]\*(C'\fR will cause the above \s-1XML\s0 to parse to:
.Sp
.Vb 4
\&  {
\&    colour => \*(Aqred\*(Aq,
\&    size   => \*(AqXXL\*(Aq
\&  }
.Ve
.Sp
instead of this (the default):
.Sp
.Vb 4
\&  {
\&    colour => { value => \*(Aqred\*(Aq },
\&    size   => { value => \*(AqXXL\*(Aq }
\&  }
.Ve
.IP "NsExpand => 0  \fIadvised\fR" 4
.IX Item "NsExpand => 0  advised"
When name-spaces are used, the default behavior is to include the
prefix in the key name.  However, this is very dangerous: the prefixes
can be changed without a change of the \s-1XML\s0 message meaning.  Therefore,
you can better use this \f(CW\*(C`NsExpand\*(C'\fR option.  The downside, however, is
that the labels get very long.
.Sp
Without this option:
.Sp
.Vb 6
\&  <record xmlns:x="http://xyz">
\&    <x:field1>42</x:field1>
\&  </record>
\&  <record xmlns:y="http://xyz">
\&    <y:field1>42</y:field1>
\&  </record>
.Ve
.Sp
translates into
.Sp
.Vb 2
\&  { \*(Aqx:field1\*(Aq => 42 }
\&  { \*(Aqy:field1\*(Aq => 42 }
.Ve
.Sp
but both source component have exactly the same meaning.  When \f(CW\*(C`NsExpand\*(C'\fR
is used, the result is:
.Sp
.Vb 2
\&  { \*(Aq{http://xyz}field1\*(Aq => 42 }
\&  { \*(Aq{http://xyz}field1\*(Aq => 42 }
.Ve
.Sp
Of course, addressing these fields is more work.  It is advised to implement
it like this:
.Sp
.Vb 2
\&  my $ns = \*(Aqhttp://xyz\*(Aq;
\&  $data\->{"{$ns}field1"};
.Ve
.IP "NsStrip => 0 \fIsloppy coding\fR" 4
.IX Item "NsStrip => 0 sloppy coding"
[not available in XML::Simple]
Namespaces are really important to avoid name collissions, but they are
a bit of a hassle.  To do it correctly, use option \f(CW\*(C`NsExpand\*(C'\fR.  To do
it sloppy, use \f(CW\*(C`NsStrip\*(C'\fR.  With this option set, the above example will
return
.Sp
.Vb 2
\&  { field1 => 42 }
\&  { field1 => 42 }
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
When \f(CW\*(C`XMLin()\*(C'\fR reads the following very simple piece of \s-1XML:\s0
.PP
.Vb 1
\&    <opt username="testuser" password="frodo"></opt>
.Ve
.PP
it returns the following data structure:
.PP
.Vb 4
\&    {
\&      username => \*(Aqtestuser\*(Aq,
\&      password => \*(Aqfrodo\*(Aq
\&    }
.Ve
.PP
The identical result could have been produced with this alternative \s-1XML:\s0
.PP
.Vb 1
\&    <opt username="testuser" password="frodo" />
.Ve
.PP
Or this (although see 'ForceArray' option for variations):
.PP
.Vb 4
\&    <opt>
\&      <username>testuser</username>
\&      <password>frodo</password>
\&    </opt>
.Ve
.PP
Repeated nested elements are represented as anonymous arrays:
.PP
.Vb 9
\&    <opt>
\&      <person firstname="Joe" lastname="Smith">
\&        <email>joe@smith.com</email>
\&        <email>jsmith@yahoo.com</email>
\&      </person>
\&      <person firstname="Bob" lastname="Smith">
\&        <email>bob@smith.com</email>
\&      </person>
\&    </opt>
\&
\&    {
\&      person => [
\&        { email     => [ \*(Aqjoe@smith.com\*(Aq, \*(Aqjsmith@yahoo.com\*(Aq ],
\&          firstname => \*(AqJoe\*(Aq,
\&          lastname  => \*(AqSmith\*(Aq
\&        },
\&        { email     => \*(Aqbob@smith.com\*(Aq,
\&          firstname => \*(AqBob\*(Aq,
\&          lastname  => \*(AqSmith\*(Aq
\&        }
\&      ]
\&    }
.Ve
.PP
Nested elements with a recognised key attribute are transformed (folded) from
an array into a hash keyed on the value of that attribute (see the \f(CW\*(C`KeyAttr\*(C'\fR
option):
.PP
.Vb 5
\&    <opt>
\&      <person key="jsmith" firstname="Joe" lastname="Smith" />
\&      <person key="tsmith" firstname="Tom" lastname="Smith" />
\&      <person key="jbloggs" firstname="Joe" lastname="Bloggs" />
\&    </opt>
\&
\&    {
\&      person => {
\&         jbloggs => {
\&            firstname => \*(AqJoe\*(Aq,
\&            lastname  => \*(AqBloggs\*(Aq
\&         },
\&         tsmith  => {
\&            firstname => \*(AqTom\*(Aq,
\&            lastname  => \*(AqSmith\*(Aq
\&         },
\&         jsmith => {
\&            firstname => \*(AqJoe\*(Aq,
\&            lastname => \*(AqSmith\*(Aq
\&         }
\&      }
\&    }
.Ve
.PP
The <anon> tag can be used to form anonymous arrays:
.PP
.Vb 6
\&    <opt>
\&      <head><anon>Col 1</anon><anon>Col 2</anon><anon>Col 3</anon></head>
\&      <data><anon>R1C1</anon><anon>R1C2</anon><anon>R1C3</anon></data>
\&      <data><anon>R2C1</anon><anon>R2C2</anon><anon>R2C3</anon></data>
\&      <data><anon>R3C1</anon><anon>R3C2</anon><anon>R3C3</anon></data>
\&    </opt>
\&
\&    {
\&      head => [ [ \*(AqCol 1\*(Aq, \*(AqCol 2\*(Aq, \*(AqCol 3\*(Aq ] ],
\&      data => [ [ \*(AqR1C1\*(Aq, \*(AqR1C2\*(Aq, \*(AqR1C3\*(Aq ],
\&                [ \*(AqR2C1\*(Aq, \*(AqR2C2\*(Aq, \*(AqR2C3\*(Aq ],
\&                [ \*(AqR3C1\*(Aq, \*(AqR3C2\*(Aq, \*(AqR3C3\*(Aq ]
\&              ]
\&    }
.Ve
.PP
Anonymous arrays can be nested to arbirtrary levels and as a special case, if
the surrounding tags for an \s-1XML\s0 document contain only an anonymous array the
arrayref will be returned directly rather than the usual hashref:
.PP
.Vb 5
\&    <opt>
\&      <anon><anon>Col 1</anon><anon>Col 2</anon></anon>
\&      <anon><anon>R1C1</anon><anon>R1C2</anon></anon>
\&      <anon><anon>R2C1</anon><anon>R2C2</anon></anon>
\&    </opt>
\&
\&    [
\&      [ \*(AqCol 1\*(Aq, \*(AqCol 2\*(Aq ],
\&      [ \*(AqR1C1\*(Aq, \*(AqR1C2\*(Aq ],
\&      [ \*(AqR2C1\*(Aq, \*(AqR2C2\*(Aq ]
\&    ]
.Ve
.PP
Elements which only contain text content will simply be represented as a
scalar.  Where an element has both attributes and text content, the element
will be represented as a hashref with the text content in the 'content' key
(see the \f(CW\*(C`ContentKey\*(C'\fR option):
.PP
.Vb 4
\&  <opt>
\&    <one>first</one>
\&    <two attr="value">second</two>
\&  </opt>
\&
\&  {
\&    one => \*(Aqfirst\*(Aq,
\&    two => { attr => \*(Aqvalue\*(Aq, content => \*(Aqsecond\*(Aq }
\&  }
.Ve
.PP
Mixed content (elements which contain both text content and nested elements)
will be not be represented in a useful way \- element order and significant
whitespace will be lost.  If you need to work with mixed content, then
XML::Simple is not the right tool for your job \- check out the next section.
.SS "Differences to XML::Simple"
.IX Subsection "Differences to XML::Simple"
In general, the output and the options are equivalent, although this
module has some differences with XML::Simple to be aware of.
.IP "only \fIXMLin()\fR is supported" 4
.IX Item "only XMLin() is supported"
If you want to write \s-1XML\s0 then use a schema (for instance with
XML::Compile). Do not attempt to create \s-1XML\s0 by hand!  If you still
think you need it, then have a look at \fIXMLout()\fR as implemented by
XML::Simple or any of a zillion template systems.
.ie n .IP "no ""variables"" option" 4
.el .IP "no ``variables'' option" 4
.IX Item "no variables option"
\&\s-1IMO\s0, you should use a templating system if you want variables filled-in
in the input: it is not a task for this module.
.IP "empty elements are not removed" 4
.IX Item "empty elements are not removed"
Being empty has a meaning which should not be ignored.
.IP "ForceArray options" 4
.IX Item "ForceArray options"
There are a few small differences in the result of the \f(CW\*(C`forcearray\*(C'\fR option,
because XML::Simple seems to behave inconsequently.
.IP "hooks" 4
.IX Item "hooks"
XML::Simple does not support hooks.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
XML::Compile for processing \s-1XML\s0 when a schema is available.  When you
have a schema, the data and structure of your message get validated.
.PP
XML::Simple, the original implementation which interface is followed
as closely as possible.
.SH "COPYRIGHTS"
.IX Header "COPYRIGHTS"
The interface design and large parts of the documentation were taken
from the XML::Simple module, written by
Grant McLean <grantm@cpan.org>
.PP
Copyrights of the perl code and the related documentation by
2008\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
