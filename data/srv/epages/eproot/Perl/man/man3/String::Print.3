.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "String::Print 3"
.TH String::Print 3 "2014-03-14" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
String::Print \- printf alternative
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& ### Functional interface
\& use String::Print qw/printi printp/, %config;
\&
\& # interpolation of arrays and hashes
\& printi \*(Aqage {years}\*(Aq, years => 12;
\& printi \*(Aqprice\-list: {prices%.2f}\*(Aq, prices => \e@prices, _join => "+";
\& printi \*(Aqdump: {hash}\*(Aq, hash => \e%config;
\&
\& # same with positional parameters
\& printp \*(Aqage %d", 12;
\& printp \*(Aqprice\-list: %.2f\*(Aq, \e@prices;
\& printp \*(Aqdump: %s\*(Aq, \e%settings;
\&
\& ### Object Oriented interface
\& use String::Print \*(Aqoo\*(Aq;      # import nothing 
\& my $f = String::Print\->new(%config);
\&
\& # same, called directly
\& $f\->printi(\*(Aqage {years}\*(Aq, years => 12);
\& $f\->printp(\*(Aqage %d\*(Aq, 12);
\&
\& ### via Log::Report\*(Aqs _\|_* functions
\& use Log::Report::Optional;
\& print _\|_x"age {years}", years => 12;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module inserts values into (translated) strings.  It provides
\&\f(CW\*(C`printf\*(C'\fR and \f(CW\*(C`sprintf\*(C'\fR alternatives via both an object oriented and a
functional interface.
.PP
Read in the \*(L"\s-1DETAILS\s0\*(R" chapter below, why this module provides a better
alternative for \f(CW\*(C`printf()\*(C'\fR.  Also, some extended \fBexamples\fR can be
found there.  Take a look at them first, when you start using this
module!
.SH "METHODS"
.IX Header "METHODS"
.SS "The Object Oriented interface"
.IX Subsection "The Object Oriented interface"
See functions \fIprinti()\fR, \fIsprinti()\fR, \fIprintp()\fR, and \fIsprintp()\fR: you
can also call them as method.
.PP
.Vb 3
\&  use String::Print \*(Aqoo\*(Aq;
\&  my $f = String::Print\->new(%config);
\&  $f\->printi($format, @params);
\&
\&  # exactly the same functionality:
\&  use String::Print \*(Aqprinti\*(Aq, %config;
\&  printi $format, @params;
.Ve
.PP
The Object Oriented interface wins when you need the same configuration
in multiple source files, or when you need different configurations
within one program.  In these cases, the hassle of explicitly using the
object has some benefits.
.SS "Constructors"
.IX Subsection "Constructors"
.IP "String::Print\->\fBnew\fR(%options)" 4
.IX Item "String::Print->new(%options)"
.Vb 3
\& \-Option     \-\-Default
\&  modifiers    [ qr/^%\eS+/ = \e&format_printf]>
\&  serializers  <useful defaults>
.Ve
.RS 4
.IP "modifiers => \s-1ARRAY\s0" 2
.IX Item "modifiers => ARRAY"
Add one or more modifier handlers to power of the formatter.  They will
get preference over the predefined modifiers, but lower than the modifiers
passed to \f(CW\*(C`print[ip]\*(C'\fR itself.
.IP "serializers => HASH|ARRAY" 2
.IX Item "serializers => HASH|ARRAY"
How to serialize data elements.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 4
\&  my $f = String::Print\->new
\&    ( modifiers   => [ EUR   => sub {sprintf "%5.2f e", $_[0]} ]
\&    , serializers => [ UNDEF => sub {\*(Aq\-\*(Aq} ]
\&    );
\&
\&  $f\->printi("price: {p EUR}", p => 3.1415); # price: XX3.14 e
\&  $f\->printi("count: {c}", c => undef);      # count: \-
.Ve
.RE
.SS "Attributes"
.IX Subsection "Attributes"
.ie n .IP "$obj\->\fBaddModifiers\fR(\s-1PAIRS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddModifiers\fR(\s-1PAIRS\s0)" 4
.IX Item "$obj->addModifiers(PAIRS)"
The \s-1PAIRS\s0 are a combination of an selector and a \s-1CODE\s0 which processes the
value when the modifier matches.  The selector is a string or (preferred)
a regular expression. Later modifiers with the same name overrule earlier
definitions.  You may also specify an \s-1ARRAY\s0 of modifiers per \f(CW\*(C`print\*(C'\fR.
.Sp
See section \*(L"Interpolation: Modifiers\*(R" about the details.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The functional interface creates a hidden object.  You may import any of
these functions explicitly, or all together by not specifying the names.
.ie n .IP "\fBprinti\fR( [$fh], $format, PAIRS|HASH )" 4
.el .IP "\fBprinti\fR( [$fh], \f(CW$format\fR, PAIRS|HASH )" 4
.IX Item "printi( [$fh], $format, PAIRS|HASH )"
Calls \fIsprinti()\fR to fill the data in \s-1PAIRS\s0 or \s-1HASH\s0 in \f(CW$format\fR, and
then sends it to the \f(CW$fh\fR (by default the selected file)
.Sp
.Vb 2
\&  open my $fh, \*(Aq>\*(Aq, $file;
\&  printi $fh, ...
\&
\&  printi \e*STDERR, ...
.Ve
.ie n .IP "\fBprintp\fR( [$fh], $format, PAIRS|HASH )" 4
.el .IP "\fBprintp\fR( [$fh], \f(CW$format\fR, PAIRS|HASH )" 4
.IX Item "printp( [$fh], $format, PAIRS|HASH )"
Calls \fIsprintp()\fR to fill the data in \s-1PAIRS\s0 or \s-1HASH\s0 in \f(CW$format\fR, and
then sends it to the \f(CW$fh\fR (by default the selected file)
.IP "\fBsprinti\fR($format, PAIRS|HASH)" 4
.IX Item "sprinti($format, PAIRS|HASH)"
The \f(CW$format\fR refers to some string, maybe the result of a translation.
.Sp
The \s-1PAIRS\s0 (which may be passed as \s-1LIST\s0 or \s-1HASH\s0) contains a mixture of
special and normal variables to be filled in.  The names of the special
variables (the options) start with an underscore (\f(CW\*(C`_\*(C'\fR).
.Sp
.Vb 5
\& \-Option  \-\-Default
\&  _append   undef
\&  _count    undef
\&  _join     \*(Aq, \*(Aq
\&  _prepend  undef
.Ve
.RS 4
.IP "_append => STRING|OBJECT" 2
.IX Item "_append => STRING|OBJECT"
Text as \s-1STRING\s0 appended after \f(CW$format\fR, without interpolation.
.IP "_count => \s-1INTEGER\s0" 2
.IX Item "_count => INTEGER"
Result of the translation process: when Log::Report subroutine _\|_xn is
are used for count-sensitive translation.  Those function may add
more specials to the parameter list.
.IP "_join => \s-1STRING\s0" 2
.IX Item "_join => STRING"
Which \s-1STRING\s0 to use when an \s-1ARRAY\s0 is being filled-in as parameter.
.IP "_prepend => STRING|OBJECT" 2
.IX Item "_prepend => STRING|OBJECT"
Text as \s-1STRING\s0 prepended before \f(CW$format\fR, without interpolation.  This
may also be an \s-1OBJECT\s0 which gets stringified, but variables not filled-in.
.RE
.RS 4
.RE
.IP "\fBsprintp\fR($format, \s-1LIST\s0, \s-1PAIRS\s0)" 4
.IX Item "sprintp($format, LIST, PAIRS)"
Where \fIsprinti()\fR uses named parameters \-\-especially useful when the
strings need translation\*(-- this function stays close to the standard
\&\f(CW\*(C`sprintf()\*(C'\fR.  All features of \s-1POSIX\s0 formats are supported.  This
should say enough: you can use \f(CW\*(C`%3$0#5.*d\*(C'\fR, if you like.
.Sp
It may be useful to know that the positional \f(CW$format\fR is rewritten and
then fed into \fIsprinti()\fR.  \fBBe careful\fR with the length of the \s-1LIST:\s0
superfluous parameter \s-1PAIRS\s0 are passed along to \f(CW\*(C`sprinti()\*(C'\fR, and
should only contain \*(L"specials\*(R".
.Sp
example: of the rewrite
.Sp
.Vb 3
\&  # positional parameters
\&  my $x = sprintp "dumpfiles: %s\en", \e@dumpfiles
\&     , _join => \*(Aq:\*(Aq;
\&
\&  # is rewriten into, and then processed as
\&  my $x = sprinti "dumpfiles: {filenames}\en"
\&     , filenames => \e@dumpfiles, _join => \*(Aq:\*(Aq;
.Ve
.SH "DETAILS"
.IX Header "DETAILS"
.ie n .SS "Why use ""printi()"", not ""printf()""?"
.el .SS "Why use \f(CWprinti()\fP, not \f(CWprintf()\fP?"
.IX Subsection "Why use printi(), not printf()?"
The \f(CW\*(C`printf()\*(C'\fR function is provided by Perl's \s-1CORE\s0; you do not need
to install any module to use it.  Why would you use consider using
this module?
.IP "translating" 4
.IX Item "translating"
\&\f(CW\*(C`printf()\*(C'\fR uses positional parameters, where \fIprinti()\fR uses names
to refer to the values to be filled-in.  Especially in a set-up with
translations, where the format strings get extracted into PO-files,
it is much clearer to use names.  This is also a disadvantage of
\&\fIprintp()\fR
.IP "pluggable serializers" 4
.IX Item "pluggable serializers"
\&\f(CW\*(C`printi()\*(C'\fR supports serialization for specific data-types: how to
interpolate \f(CW\*(C`undef\*(C'\fR, HASHes, etc.
.IP "pluggable modifiers" 4
.IX Item "pluggable modifiers"
Especially useful in context of translations, the \s-1FORMAT\s0 string may
contain (language specific) helpers to insert the values correctly.
.IP "correct use of utf8" 4
.IX Item "correct use of utf8"
Sized string formatting in \f(CW\*(C`printf()\*(C'\fR is broken: it takes your string
as bytes, not Perl strings (which may be utf8).  In unicode, one
\&\*(L"character\*(R" may use many bytes.  Also, some characters are displayed
double wide, for instance in Chinese.  The \fIprinti()\fR implementation
will use Unicode::GCString for correct behavior.
.SS "Three components"
.IX Subsection "Three components"
To fill-in a \s-1FORMAT\s0, three clearly separated components play a role:
.IP "1. modifiers" 4
.IX Item "1. modifiers"
How to change the provided values, for instance to hide locale
differences.
.IP "2. serializer" 4
.IX Item "2. serializer"
How to represent (the modified) the values correctly, for instance \f(CW\*(C`undef\*(C'\fR
and ARRAYs.
.IP "3. conversion" 4
.IX Item "3. conversion"
The standard \s-1UNIX\s0 format rules, like \f(CW%d\fR.  One conversion rule
has been added 'S', which provides unicode correct behavior.
.PP
Simplified:
.PP
.Vb 2
\&  # sprinti() replaces "{$key$modifiers$conversion}" by
\&  $conversion\->($serializer\->($modifiers\->($args{$key})))
\&
\&  # sprintp() replaces "%pos{$modifiers}$conversion" by
\&  $conversion\->($serializer\->($modifiers\->($arg[$pos])))
.Ve
.PP
Example:
.PP
.Vb 2
\&  printi "price: {price X %\-10s}", price => $cost;
\&  printp "price: %\-10{X}s", $cost;
\&
\&  $conversion = column width %\-10s
\&  $serializer = show float as string
\&  $modifier   = X to local currency
\&  $value      = $cost (in X)
.Ve
.SS "Interpolation: Serialization"
.IX Subsection "Interpolation: Serialization"
The 'interpolation' functions have named \s-1VARIABLES\s0 to be filled-in, but
also additional \s-1OPTIONS\s0.  To distinguish between the \s-1OPTIONS\s0 and \s-1VARIABLES\s0
(both a list of key-value pairs), the keys of the \s-1OPTIONS\s0 start with
an underscore \f(CW\*(C`_\*(C'\fR.  As result of this, please avoid the use of keys
which start with an underscore in variable names.  On the other hand,
you are allowed to interpolate \s-1OPTION\s0 values in your strings.
.PP
There is no way of checking beforehand whether you have provided all
values to be interpolated in the translated string.  When you refer to
value which is missing, it will be interpreted as \f(CW\*(C`undef\*(C'\fR.
.IP "\s-1CODE\s0" 4
.IX Item "CODE"
When a value is passed as \s-1CODE\s0 reference, that function will get called
to return the value to be filled in.
For interpolating, the following rules apply:
.IP "strings" 4
.IX Item "strings"
Simple scalar values are interpolated \*(L"as is\*(R"
.IP "\s-1SCALAR\s0" 4
.IX Item "SCALAR"
Takes the value where the scalar reference points to.
.IP "\s-1ARRAY\s0" 4
.IX Item "ARRAY"
All members will be interpolated with \f(CW\*(C`,X\*(C'\fR between the elements.
Alternatively (maybe nicer), you can pass an interpolation parameter
via the \f(CW\*(C`_join\*(C'\fR \s-1OPTION\s0.
.Sp
.Vb 1
\&  printi "matching files: {files}", files => \e@files, _join => \*(Aq, \*(Aq
.Ve
.IP "\s-1HASH\s0" 4
.IX Item "HASH"
By default, HASHes are interpolated with sorted keys,
.Sp
.Vb 1
\&   $key => $value, $key2 => $value2, ...
.Ve
.Sp
There is no quoting on the keys or values (yet).  Usually, this will
produce an ugly result anyway.
.IP "Objects" 4
.IX Item "Objects"
With the \f(CW\*(C`serialization\*(C'\fR parameter, you can overrule the interpolation
of above defaults, but also add rules for your own objects.  By default,
objects get stringified.
.Sp
.Vb 1
\&  serialization => [ $myclass => \e&name_in_reverse ]
\&
\&  sub name_in_reverse($$$)
\&  {   my ($formatter, $object, $args) = @_;
\&      # the $args are all parameters to be filled\-in
\&      scalar reverse $object\->name;
\&  }
.Ve
.SS "Interpolation: Modifiers"
.IX Subsection "Interpolation: Modifiers"
Modifiers are used to change the value to be inserted, before the characters
get interpolated in the line.
.PP
\fIModifiers: unix format\fR
.IX Subsection "Modifiers: unix format"
.PP
Next to the name, you can specify a format code.  With (gnu) \f(CW\*(C`gettext()\*(C'\fR,
you often see this:
.PP
.Vb 1
\& printf gettext("approx pi: %.6f\en"), PI;
.Ve
.PP
Locale::TextDomain has two ways:
.PP
.Vb 2
\& printf _\|_"approx pi: %.6f\en", PI;
\& print _\|_x"approx pi: {approx}\en", approx => sprintf("%.6f", PI);
.Ve
.PP
The first does not respect the wish to be able to reorder the arguments
during translation (although there are ways to work around that)  The
second version is quite long.  The content of the translation table
differs between the examples.
.PP
With \f(CW\*(C`Log::Report\*(C'\fR, above syntaxes do work, but you can also do:
.PP
.Vb 2
\& # with optional translations
\& print _\|_x"approx pi: {pi%.6f}\en", pi => PI;
.Ve
.PP
The base for \f(CW\*(C`_\|_x()\*(C'\fR is the \fIprinti()\fR provided by this module. Internally,
it will call \f(CW\*(C`printi\*(C'\fR to fill in parameters:
.PP
.Vb 1
\& printi   "approx pi: {pi%.6f}\en", pi => PI;
.Ve
.PP
Another example:
.PP
.Vb 3
\& printi "{perms} {links%2d} {user%\-8s} {size%10d} {fn}\en"
\&   , perms => \*(Aq\-rw\-r\-\-r\-\-\*(Aq, links => 7, user => \*(Aqme\*(Aq
\&   , size => 12345, fn => $filename;
.Ve
.PP
An additional advantage is the fact that not all languages produce
comparable length strings.  Now, the translators can take care that
the layout of tables is optimal.  Above example in \fIprintp()\fR syntax,
shorter but less maintainable:
.PP
.Vb 2
\& printp "%s %2d %\-8s 10d %s\en"
\&   , \*(Aq\-rw\-r\-\-r\-\-\*(Aq, 7, \*(Aqme\*(Aq, 12345, $filename;
.Ve
.PP
\fIModifiers: unix format improvements\fR
.IX Subsection "Modifiers: unix format improvements"
.PP
The \s-1POSIX\s0 \f(CW\*(C`printf()\*(C'\fR does not handle unicode strings.  Perl does
understand that the 's' modifier may need to insert utf8 so does not
count bytes but characters.  \f(CW\*(C`printi()\*(C'\fR does not use characters but
\&\*(L"grapheme clusters\*(R" via Unicode::GCString.  Now, also composed
characters do work correctly.
.PP
Additionally, you can use the \fBnew 'S' conversion\fR to count in columns.
In fixed-width fonts, graphemes can have width 0, 1 or 2.  For instance,
Chinese characters have width 2.  When printing in fixed-width, this
\&'S' is probably the better choice over 's'.  When the field does not
specify its width, then there is no performance penalty for using 'S'.
.PP
\fIModifiers: private modifiers\fR
.IX Subsection "Modifiers: private modifiers"
.PP
You may pass your own modifiers.  A modifier consists of a selector and
a \s-1CODE\s0, which is called when the selector matches.  The selector is either
a string or a regular expression.
.PP
.Vb 4
\&  # in Object Oriented syntax:
\&  my $f = String::Print\->new
\&    ( modifiers => [ qr/[XX]/ => \e&money ]
\&    );
\&
\&  # in function syntax:
\&  use String::Print \*(Aqprinti\*(Aq, \*(Aqsprinti\*(Aq
\&    , modifiers => [ qr/[XX]/ => \e&money ];
\&
\&  # the implementation:
\&  sub money$$$$)
\&  { my ($formatter, $modif, $value, $args) = @_;
\&
\&      $modif eq \*(AqX\*(Aq ? sprintf("%.2f EUR", $value+0.0001)
\&    : $modif eq \*(AqX\*(Aq ? sprintf("%.2f GBP", $value/1.16+0.0001)
\&    :                 \*(AqERROR\*(Aq;
\&  }
.Ve
.PP
Using \fIprintp()\fR makes it a little shorter, but will become quite
complex when there are more parameter in one string.
.PP
.Vb 2
\&  printi "price: {pX}", p => $pi;   # price: 3.14 EUR
\&  printi "price: {pX}", p => $pi;   # price: 2.71 GBP
\&
\&  printp "price: %{X}s", $pi;       # price: 3.14 EUR
\&  printp "price: %{X}s", $pi;       # price: 2.71 GBP
.Ve
.PP
This is very useful in the translation context, where the translator can
specify abstract formatting rules.  As example, see the (\s-1GNU\s0) gettext
files, in the translation table for Dutch into English.  The translator
tells us which currency to use in the display.
.PP
.Vb 2
\&  msgid  "kostprijs: {pX}"
\&  msgstr "price: {pX}"
.Ve
.PP
Another example.  Now, we want to add timestamps.  In this case, we
decide for modifier names in \f(CW\*(C`\ew\*(C'\fR, so we need a blank to separate
the paramter from the modifer.
.PP
.Vb 2
\&  use POSIX  qw/strftime/;
\&  use String::Print modifiers => [ qr/T|DT|D/ => \e&_timestamp ];
\&
\&  sub _timestamp($$$$)
\&    { my ($formatter, $modif, $value, $args) = @_;
\&      my $time_format
\&        = $modif eq \*(AqT\*(Aq  ? \*(Aq%T\*(Aq
\&        : $modif eq \*(AqD\*(Aq  ? \*(Aq%F\*(Aq
\&        : $modif eq \*(AqDT\*(Aq ? \*(Aq%FT%TZ\*(Aq
\&        :                  \*(AqERROR\*(Aq;
\&      strftime $time_format, gmtime($value);
\&    };
\&
\&  printi "time: {t T}",  t => $now;  # time: 10:59:17
\&  printi "date: {t D }", t => $now;  # date: 2013\-04\-13
\&  printi "both: {t DT}", t => $now;  # both: 2013\-04\-13T10:59:17Z
\&
\&  printp "time: %{T}s",  $now;       # time: 10:59:17
\&  printp "date: %{D}s",  $now;       # date: 2013\-04\-13
\&  printp "both: %{DT}s", $now;       # both: 2013\-04\-13T10:59:17Z
.Ve
.PP
\fIModifiers: stacking\fR
.IX Subsection "Modifiers: stacking"
.PP
You can add more than one modifier.  The modifiers detect the extend of
their own information (via a regular expression), and therefore the
formatter understands where one ends and the next begins.
.PP
The modifiers are called in order:
.PP
.Vb 2
\&  printi "price: {pX%9s}\en", p => $p; # price: XXX123.45
\&  printi ">{t T%10s}<", t => $now;    # >XX12:59:17<
\&
\&  printp "price: %9{X}s\en", $p;       # price: XXX123.45
\&  printp ">%10{T}s<", $now;           # >XX12:59:17<
.Ve
.SS "Compared to other modules on \s-1CPAN\s0"
.IX Subsection "Compared to other modules on CPAN"
There are a quite a number of modules on \s-1CPAN\s0 which extend the functionality
of \f(CW\*(C`printf()\*(C'\fR.  To name a few:
String::Format <http://search.cpan.org/~darren/String-Format>,
String::Errf <http://http://search.cpan.org/~rjbs/String-Errf>,
String::Formatter <http://http://search.cpan.org/~rjbs/String-Formatter>,
Text::Sprintf::Named <http://search.cpan.org/~shlomif/Text-Sprintf-Named>,
Acme::StringFormat <http://search.cpan.org/~gfuji/Acme-StringFormat>,
Text::sprintf <http://search.cpan.org/~sharyanto/Text-sprintfn>,
Log::Sprintf <http://search.cpan.org/~frew/Log-Sprintf>, and
String::Sprintf <http://search.cpan.org/~bartl/String-Sprintf>.
They are all slightly different.
.PP
When the \f(CW\*(C`String::Print\*(C'\fR module was created, none of the modules
mentioned above handled unicode correctly.  Global configuration
of serializers and modifiers is also usually not possible, sometimes
provided per explicit function call.  Only \f(CW\*(C`String::Print\*(C'\fR cleanly
separates the roles of serializers, modifiers, and conversions.
.PP
\&\f(CW\*(C`String::Print\*(C'\fR is nicely integrated with Log::Report.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of String-Print distribution version 0.15,
built on March 14, 2014. Website: \fIhttp://perl.overmeer.net/log\-report/\fR
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2013\-2014 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
