.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::WSDL11 3"
.TH XML::Compile::WSDL11 3 "2017-01-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::WSDL11 \- create SOAP messages defined by WSDL 1.1
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 4
\& XML::Compile::WSDL11
\&   is a XML::Compile::Cache
\&   is a XML::Compile::Schema
\&   is a XML::Compile
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& # preparation
\& use XML::Compile::WSDL11;      # use WSDL version 1.1
\& use XML::Compile::SOAP11;      # use SOAP version 1.1
\& use XML::Compile::Transport::SOAPHTTP;
\&
\& # you want some trace?
\& use Log::Report mode => \*(AqDEBUG\*(Aq;   # or \*(AqVERBOSE\*(Aq
\&
\& # collect one or more wsdls and xsds in one object
\& my $wsdl = XML::Compile::WSDL11\->new($wsdlfile
\&   , server_type => \*(AqBEA\*(Aq
\&   );
\& $wsdl\->addWSDL(...more WSDL files...);
\& $wsdl\->importDefinitions(...more schemas...);
\&
\& # during initiation, for each used call
\& my $call = $wsdl\->compileClient(\*(AqGetStockPrice\*(Aq, ...);
\&
\& # at "run\-time", call as often as you want (fast)
\& my $answer = $call\->(%request);
\&
\& # capture useful trace information
\& my ($answer, $trace) = $call\->(%request);
\& if($trace\->errors)
\& {   $trace\->printError;
\& }
\&
\& # no need to administer the operations by hand: alternative
\& $wsdl\->compileCalls;  # at initiation
\& my $answer = $wsdl\->call(GetStockPrice => %request);
\&
\& # investigate the %request structure (server input)
\& print $wsdl\->explain(\*(AqGetStockPrice\*(Aq, PERL => \*(AqINPUT\*(Aq, recurse => 1);
\&
\& # investigate the $answer structure (server output)
\& print $wsdl\->explain(\*(AqGetStockPrice\*(Aq, PERL => \*(AqOUTPUT\*(Aq);
\&
\& # when you like, get all operation definitions
\& my @all_ops = $wsdl\->operations;
\&
\& # Install XML::Compile::SOAP::Daemon
\& my $server  = XML::Compile::SOAP::HTTPDaemon\->new;
\& $server\->operationsFromWSDL($wsdl);
\& undef $wsdl;    # not needed any further
\& 
\& # For debug info, start your script with:
\& use Log::Report mode => \*(AqDEBUG\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module understands \s-1WSDL\s0 version 1.1.  An \s-1WSDL\s0 file defines a set of
messages to be send and received over (\s-1SOAP\s0) connections. This involves
encoding of the message to be send into \s-1XML\s0, sending the message to the
server, collect the answer, and finally decoding the \s-1XML\s0 to Perl.
.PP
As end-user, you do not have to worry about the complex details of the
messages and the way to exchange them: it's all simple Perl for you.
Also, faults are handled automatically.  The only complication you have
to worry about is to shape a nested \s-1HASH\s0 structure to the sending
message structure.  \fIXML::Compile::Schema::template()\fR may help you.
.PP
When the definitions are spread over multiple files you will need to
use \fIaddWSDL()\fR (wsdl) or \fIimportDefinitions()\fR (additional schema's)
explicitly. Usually, interreferences between those files are broken.
Often they reference over networks (you should never trust). So, on
purpose you \fBmust explicitly load\fR the files you need from local disk!
(of course, it is simple to find one-liners as work-arounds, but I will
not tell you how!  See XML::Compile::SOAP::FAQ)
.PP
Extends \*(L"\s-1DESCRIPTION\s0\*(R" in XML::Compile::Cache.
.SH "METHODS"
.IX Header "METHODS"
Extends \*(L"\s-1METHODS\s0\*(R" in XML::Compile::Cache.
.SS "Constructors"
.IX Subsection "Constructors"
Extends \*(L"Constructors\*(R" in XML::Compile::Cache.
.ie n .IP "XML::Compile::WSDL11\->\fBnew\fR( [$xml], %options )" 4
.el .IP "XML::Compile::WSDL11\->\fBnew\fR( [$xml], \f(CW%options\fR )" 4
.IX Item "XML::Compile::WSDL11->new( [$xml], %options )"
The \f(CW$xml\fR is the \s-1WSDL\s0 file, which is anything accepted by
\&\fIXML::Compile::dataToXML()\fR.
.Sp
.Vb 10
\& \-Option            \-\-Defined in          \-\-Default
\&  allow_undeclared    XML::Compile::Cache   <false>
\&  any_element         XML::Compile::Cache   \*(AqATTEMPT\*(Aq
\&  block_namespace     XML::Compile::Schema  []
\&  hook                XML::Compile::Schema  undef
\&  hooks               XML::Compile::Schema  []
\&  ignore_unused_tags  XML::Compile::Schema  <false>
\&  key_rewrite         XML::Compile::Schema  []
\&  opts_readers        XML::Compile::Cache   []
\&  opts_rw             XML::Compile::Cache   []
\&  opts_writers        XML::Compile::Cache   []
\&  parser_options      XML::Compile          <many>
\&  prefixes            XML::Compile::Cache   <smart>
\&  schema_dirs         XML::Compile          undef
\&  server_type                               undef
\&  typemap             XML::Compile::Cache   {}
\&  xsi_type            XML::Compile::Cache   {}
.Ve
.RS 4
.IP "allow_undeclared => \s-1BOOLEAN\s0" 2
.IX Item "allow_undeclared => BOOLEAN"
.PD 0
.IP "any_element => CODE|'\s-1TAKE_ALL\s0'|'\s-1SKIP_ALL\s0'|'\s-1ATTEMPT\s0'|'\s-1SLOPPY\s0'" 2
.IX Item "any_element => CODE|'TAKE_ALL'|'SKIP_ALL'|'ATTEMPT'|'SLOPPY'"
.IP "block_namespace => NAMESPACE|TYPE|HASH|CODE|ARRAY" 2
.IX Item "block_namespace => NAMESPACE|TYPE|HASH|CODE|ARRAY"
.IP "hook => HOOK|ARRAY" 2
.IX Item "hook => HOOK|ARRAY"
.IP "hooks => \s-1ARRAY\s0" 2
.IX Item "hooks => ARRAY"
.IP "ignore_unused_tags => BOOLEAN|REGEXP" 2
.IX Item "ignore_unused_tags => BOOLEAN|REGEXP"
.IP "key_rewrite => HASH|CODE|ARRAY" 2
.IX Item "key_rewrite => HASH|CODE|ARRAY"
.IP "opts_readers => HASH|ARRAY\-of\-PAIRS" 2
.IX Item "opts_readers => HASH|ARRAY-of-PAIRS"
.IP "opts_rw => HASH|ARRAY\-of\-PAIRS" 2
.IX Item "opts_rw => HASH|ARRAY-of-PAIRS"
.IP "opts_writers => HASH|ARRAY\-of\-PAIRS" 2
.IX Item "opts_writers => HASH|ARRAY-of-PAIRS"
.IP "parser_options => HASH|ARRAY" 2
.IX Item "parser_options => HASH|ARRAY"
.IP "prefixes => HASH|ARRAY\-of\-PAIRS" 2
.IX Item "prefixes => HASH|ARRAY-of-PAIRS"
.IP "schema_dirs => DIRECTORY|ARRAY\-OF\-DIRECTORIES" 2
.IX Item "schema_dirs => DIRECTORY|ARRAY-OF-DIRECTORIES"
.IP "server_type => \s-1NAME\s0" 2
.IX Item "server_type => NAME"
.PD
[3.01] When you specify the implementation of the server, we can work
around some of the known bugs and limitation.
Read XML::Compile::SOAP section \*(L"Supported servers\*(R" for supported
servers.
.IP "typemap => HASH|ARRAY" 2
.IX Item "typemap => HASH|ARRAY"
.PD 0
.IP "xsi_type => HASH|ARRAY" 2
.IX Item "xsi_type => HASH|ARRAY"
.RE
.RS 4
.RE
.PD
.SS "Accessors"
.IX Subsection "Accessors"
Extends \*(L"Accessors\*(R" in XML::Compile::Cache.
.ie n .IP "$obj\->\fBaddHook\fR($hook|LIST|undef)" 4
.el .IP "\f(CW$obj\fR\->\fBaddHook\fR($hook|LIST|undef)" 4
.IX Item "$obj->addHook($hook|LIST|undef)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBaddHooks\fR( $hook, [$hook, ...] )" 4
.el .IP "\f(CW$obj\fR\->\fBaddHooks\fR( \f(CW$hook\fR, [$hook, ...] )" 4
.IX Item "$obj->addHooks( $hook, [$hook, ...] )"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBaddKeyRewrite\fR($predef|CODE|HASH, ...)" 4
.el .IP "\f(CW$obj\fR\->\fBaddKeyRewrite\fR($predef|CODE|HASH, ...)" 4
.IX Item "$obj->addKeyRewrite($predef|CODE|HASH, ...)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBaddSchemaDirs\fR(@directories|$filename)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSchemaDirs\fR(@directories|$filename)" 4
.IX Item "$obj->addSchemaDirs(@directories|$filename)"
.PD 0
.IP "XML::Compile::WSDL11\->\fBaddSchemaDirs\fR(@directories|$filename)" 4
.IX Item "XML::Compile::WSDL11->addSchemaDirs(@directories|$filename)"
.PD
Inherited, see \*(L"Accessors\*(R" in XML::Compile
.ie n .IP "$obj\->\fBaddSchemas\fR($xml, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBaddSchemas\fR($xml, \f(CW%options\fR)" 4
.IX Item "$obj->addSchemas($xml, %options)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBaddTypemap\fR(\s-1PAIR\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddTypemap\fR(\s-1PAIR\s0)" 4
.IX Item "$obj->addTypemap(PAIR)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBaddTypemaps\fR(\s-1PAIRS\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddTypemaps\fR(\s-1PAIRS\s0)" 4
.IX Item "$obj->addTypemaps(PAIRS)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBaddXsiType\fR( [HASH|ARRAY|LIST] )" 4
.el .IP "\f(CW$obj\fR\->\fBaddXsiType\fR( [HASH|ARRAY|LIST] )" 4
.IX Item "$obj->addXsiType( [HASH|ARRAY|LIST] )"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBallowUndeclared\fR( [\s-1BOOLEAN\s0] )" 4
.el .IP "\f(CW$obj\fR\->\fBallowUndeclared\fR( [\s-1BOOLEAN\s0] )" 4
.IX Item "$obj->allowUndeclared( [BOOLEAN] )"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBanyElement\fR('\s-1ATTEMPT\s0'|'\s-1SLOPPY\s0'|'\s-1SKIP_ALL\s0'|'\s-1TAKE_ALL\s0'|CODE)" 4
.el .IP "\f(CW$obj\fR\->\fBanyElement\fR('\s-1ATTEMPT\s0'|'\s-1SLOPPY\s0'|'\s-1SKIP_ALL\s0'|'\s-1TAKE_ALL\s0'|CODE)" 4
.IX Item "$obj->anyElement('ATTEMPT'|'SLOPPY'|'SKIP_ALL'|'TAKE_ALL'|CODE)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBblockNamespace\fR($ns|$type|HASH|CODE|ARRAY)" 4
.el .IP "\f(CW$obj\fR\->\fBblockNamespace\fR($ns|$type|HASH|CODE|ARRAY)" 4
.IX Item "$obj->blockNamespace($ns|$type|HASH|CODE|ARRAY)"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBhooks\fR( [<'\s-1READER\s0'|'\s-1WRITER\s0'>] )" 4
.el .IP "\f(CW$obj\fR\->\fBhooks\fR( [<'\s-1READER\s0'|'\s-1WRITER\s0'>] )" 4
.IX Item "$obj->hooks( [<'READER'|'WRITER'>] )"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBtypemap\fR( [HASH|ARRAY|PAIRS] )" 4
.el .IP "\f(CW$obj\fR\->\fBtypemap\fR( [HASH|ARRAY|PAIRS] )" 4
.IX Item "$obj->typemap( [HASH|ARRAY|PAIRS] )"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBuseSchema\fR( $schema, [$schema, ...] )" 4
.el .IP "\f(CW$obj\fR\->\fBuseSchema\fR( \f(CW$schema\fR, [$schema, ...] )" 4
.IX Item "$obj->useSchema( $schema, [$schema, ...] )"
Inherited, see \*(L"Accessors\*(R" in XML::Compile::Schema
.SS "Prefix management"
.IX Subsection "Prefix management"
Extends \*(L"Prefix management\*(R" in XML::Compile::Cache.
.ie n .IP "$obj\->\fBaddNicePrefix\fR(\s-1BASE\s0, \s-1NAMESPACE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBaddNicePrefix\fR(\s-1BASE\s0, \s-1NAMESPACE\s0)" 4
.IX Item "$obj->addNicePrefix(BASE, NAMESPACE)"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBaddPrefixes\fR( [PAIRS|ARRAY|HASH] )" 4
.el .IP "\f(CW$obj\fR\->\fBaddPrefixes\fR( [PAIRS|ARRAY|HASH] )" 4
.IX Item "$obj->addPrefixes( [PAIRS|ARRAY|HASH] )"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBlearnPrefixes\fR($node)" 4
.el .IP "\f(CW$obj\fR\->\fBlearnPrefixes\fR($node)" 4
.IX Item "$obj->learnPrefixes($node)"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBprefix\fR($prefix)" 4
.el .IP "\f(CW$obj\fR\->\fBprefix\fR($prefix)" 4
.IX Item "$obj->prefix($prefix)"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBprefixFor\fR($uri)" 4
.el .IP "\f(CW$obj\fR\->\fBprefixFor\fR($uri)" 4
.IX Item "$obj->prefixFor($uri)"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBprefixed\fR( $type|<$ns,$local> )" 4
.el .IP "\f(CW$obj\fR\->\fBprefixed\fR( \f(CW$type\fR|<$ns,$local> )" 4
.IX Item "$obj->prefixed( $type|<$ns,$local> )"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBprefixes\fR( [$params] )" 4
.el .IP "\f(CW$obj\fR\->\fBprefixes\fR( [$params] )" 4
.IX Item "$obj->prefixes( [$params] )"
Inherited, see \*(L"Prefix management\*(R" in XML::Compile::Cache
.SS "Compilers"
.IX Subsection "Compilers"
Extends \*(L"Compilers\*(R" in XML::Compile::Cache.
.ie n .IP "$obj\->\fBaddCompileOptions\fR( ['\s-1READERS\s0'|'\s-1WRITERS\s0'|'\s-1RW\s0'], %options )" 4
.el .IP "\f(CW$obj\fR\->\fBaddCompileOptions\fR( ['\s-1READERS\s0'|'\s-1WRITERS\s0'|'\s-1RW\s0'], \f(CW%options\fR )" 4
.IX Item "$obj->addCompileOptions( ['READERS'|'WRITERS'|'RW'], %options )"
Inherited, see \*(L"Compilers\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBcall\fR($opname, $data)" 4
.el .IP "\f(CW$obj\fR\->\fBcall\fR($opname, \f(CW$data\fR)" 4
.IX Item "$obj->call($opname, $data)"
[2.20] Call the \f(CW$opname\fR (operation name) with \f(CW$data\fR (\s-1HASH\s0 or \s-1LIST\s0 of parameters).
This only works when you have called \fIcompileCalls()\fR beforehand,
always during the initiation phase of the program.
.Sp
example:
.Sp
.Vb 2
\&   # at initiation time (compile once)
\&   $wsdl\->compileCalls;
\&
\&   # at runtime (run often)
\&   my $answer = $wsdl\->call($operation, $request);
.Ve
.ie n .IP "$obj\->\fBcompile\fR( <'\s-1READER\s0'|'\s-1WRITER\s0'>, $type, %options )" 4
.el .IP "\f(CW$obj\fR\->\fBcompile\fR( <'\s-1READER\s0'|'\s-1WRITER\s0'>, \f(CW$type\fR, \f(CW%options\fR )" 4
.IX Item "$obj->compile( <'READER'|'WRITER'>, $type, %options )"
Inherited, see \*(L"Compilers\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBcompileAll\fR( [ <'\s-1READERS\s0'|'\s-1WRITERS\s0'|'\s-1RW\s0'|'\s-1CALLS\s0'>, [$ns] ] )" 4
.el .IP "\f(CW$obj\fR\->\fBcompileAll\fR( [ <'\s-1READERS\s0'|'\s-1WRITERS\s0'|'\s-1RW\s0'|'\s-1CALLS\s0'>, [$ns] ] )" 4
.IX Item "$obj->compileAll( [ <'READERS'|'WRITERS'|'RW'|'CALLS'>, [$ns] ] )"
[2.20] With explicit \f(CW\*(C`CALLS\*(C'\fR or without any parameter, it will call
\&\fIcompileCalls()\fR. Otherwise, see \fIXML::Compile::Cache::compileAll()\fR.
.ie n .IP "$obj\->\fBcompileCall\fR($operation|$opname, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBcompileCall\fR($operation|$opname, \f(CW%options\fR)" 4
.IX Item "$obj->compileCall($operation|$opname, %options)"
[2.37] The call to the \f(CW$operation\fR object (which extends
XML::Compile::SOAP::Operation) gets compiled and cached so it can
be used with \fIcall()\fR.
.Sp
[2.38] Alteratively to an \f(CW$operation\fR object, you may also specify an
operation by name.
.Sp
.Vb 2
\& \-Option\-\-Default
\&  alias   undef
.Ve
.RS 4
.IP "alias => \s-1NAME\s0" 2
.IX Item "alias => NAME"
[3.03] When defined, the compiled operation will be stored with the
alias name in stead of the operation name.  This may make your code
more readible or solve naming conflicts.
.RE
.RS 4
.Sp
example:
.Sp
.Vb 2
\&  my $op = $wsdl\->operation(name => \*(AqgetInfo\*(Aq);
\&  $wsdl\->compileCall($op);
\&
\&  # as often as you need it
\&  my ($answer, $trace) = $wsdl\->call(\*(AqgetInfo\*(Aq)\->(%request);
.Ve
.RE
.ie n .IP "$obj\->\fBcompileCalls\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBcompileCalls\fR(%options)" 4
.IX Item "$obj->compileCalls(%options)"
[2.20] Compile a handler for each of the available operations. The \f(CW%options\fR are
passed to each call of \fIcompileClient()\fR, but will be overruled by more
specific declared options.
.Sp
Additionally, \f(CW%options\fR can contain \f(CW\*(C`service\*(C'\fR, \f(CW\*(C`port\*(C'\fR, and \f(CW\*(C`binding\*(C'\fR
to limit the set of involved calls. See \fIoperations()\fR for details on
these options.
.Sp
You may declare additional specific compilation options with the
\&\fIdeclare()\fR method.
.Sp
.Vb 2
\& \-Option    \-\-Default
\&  long_names  false
.Ve
.RS 4
.IP "long_names => \s-1BOOLEAN\s0" 2
.IX Item "long_names => BOOLEAN"
[3.03] Prepend the service name to the operation name to produce an alias
(see compileCall(alias)) for the compiled call.  If the service name is
\&'X' and the operation name is 'Y', then the alias becomes 'X#Y'.
.Sp
You will need this if you have multiple operations with the same name
in your \s-1WSDL\s0 (\-collection).
.RE
.RS 4
.Sp
example:
.Sp
.Vb 3
\&   my $trans = XML::Compile::Transport::SOAPHTTP
\&     \->new(timeout => 500, address => $wsdl\->endPoint);
\&   $wsdl\->compileCalls(transport => $trans);
\&
\&   # alternatives for simple cases
\&   $wsdl\->compileAll(\*(AqCALLS\*(Aq);
\&   $wsdl\->compileAll;
\&   
\&   my $answer = $wsdl\->call($myop, $request);
.Ve
.RE
.ie n .IP "$obj\->\fBcompileType\fR( <'\s-1READER\s0'|'\s-1WRITER\s0'>, $type, %options )" 4
.el .IP "\f(CW$obj\fR\->\fBcompileType\fR( <'\s-1READER\s0'|'\s-1WRITER\s0'>, \f(CW$type\fR, \f(CW%options\fR )" 4
.IX Item "$obj->compileType( <'READER'|'WRITER'>, $type, %options )"
Inherited, see \*(L"Compilers\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBdataToXML\fR($node|REF\-XML|XML\-STRING|$filename|$fh|$known)" 4
.el .IP "\f(CW$obj\fR\->\fBdataToXML\fR($node|REF\-XML|XML\-STRING|$filename|$fh|$known)" 4
.IX Item "$obj->dataToXML($node|REF-XML|XML-STRING|$filename|$fh|$known)"
.PD 0
.IP "XML::Compile::WSDL11\->\fBdataToXML\fR($node|REF\-XML|XML\-STRING|$filename|$fh|$known)" 4
.IX Item "XML::Compile::WSDL11->dataToXML($node|REF-XML|XML-STRING|$filename|$fh|$known)"
.PD
Inherited, see \*(L"Compilers\*(R" in XML::Compile
.ie n .IP "$obj\->\fBinitParser\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBinitParser\fR(%options)" 4
.IX Item "$obj->initParser(%options)"
.PD 0
.IP "XML::Compile::WSDL11\->\fBinitParser\fR(%options)" 4
.IX Item "XML::Compile::WSDL11->initParser(%options)"
.PD
Inherited, see \*(L"Compilers\*(R" in XML::Compile
.ie n .IP "$obj\->\fBreader\fR($type|$name, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBreader\fR($type|$name, \f(CW%options\fR)" 4
.IX Item "$obj->reader($type|$name, %options)"
Inherited, see \*(L"Compilers\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBtemplate\fR( <'\s-1XML\s0'|'\s-1PERL\s0'|'\s-1TREE\s0'>, $element, %options )" 4
.el .IP "\f(CW$obj\fR\->\fBtemplate\fR( <'\s-1XML\s0'|'\s-1PERL\s0'|'\s-1TREE\s0'>, \f(CW$element\fR, \f(CW%options\fR )" 4
.IX Item "$obj->template( <'XML'|'PERL'|'TREE'>, $element, %options )"
Inherited, see \*(L"Compilers\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBwriter\fR($type|$name)" 4
.el .IP "\f(CW$obj\fR\->\fBwriter\fR($type|$name)" 4
.IX Item "$obj->writer($type|$name)"
Inherited, see \*(L"Compilers\*(R" in XML::Compile::Cache
.SS "Extension"
.IX Subsection "Extension"
.ie n .IP "$obj\->\fBaddWSDL\fR($xmldata|\e@xmldata, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBaddWSDL\fR($xmldata|\e@xmldata, \f(CW%options\fR)" 4
.IX Item "$obj->addWSDL($xmldata|@xmldata, %options)"
The \f(CW$xmldata\fR must be acceptable to \fIXML::Compile::dataToXML()\fR and 
should represent the top-level of a (partial) \s-1WSDL\s0 document.
The specification can be spread over multiple files, each of
which must have a \f(CW\*(C`definition\*(C'\fR root element.
.ie n .IP "$obj\->\fBcompileClient\fR( [$name], %options )" 4
.el .IP "\f(CW$obj\fR\->\fBcompileClient\fR( [$name], \f(CW%options\fR )" 4
.IX Item "$obj->compileClient( [$name], %options )"
Creates an XML::Compile::SOAP::Operation temporary object using
\&\fIoperation()\fR, and then calls \f(CW\*(C`compileClient()\*(C'\fR on that.  This
results in a code reference which will handle all client-server
\&\s-1SOAP\s0 exchange.
.Sp
The \f(CW%options\fR available include all of the options for:
.RS 4
.IP "\(bu" 4
\&\fIoperation()\fR (i.e. \f(CW\*(C`service\*(C'\fR and \f(CW\*(C`port\*(C'\fR), and all of
.IP "\(bu" 4
\&\fIXML::Compile::SOAP::Operation::compileClient()\fR (there are many of
these, for instance \f(CW\*(C`transport_hook\*(C'\fR and \f(CW\*(C`server\*(C'\fR)
.RE
.RS 4
.Sp
You \fBcannot\fR pass options for \fIXML::Compile::Schema::compile()\fR, like
\&\f(CW\*(C`<sloppy_integers =\*(C'\fR 0>>, hooks or typemaps this way. Use new(opts_rw)
and friends to declare those.
.Sp
When you use \fIcompileCall()\fR, the compiled code references get cached
for you.  In that case, you can use \fIcall()\fR to use them.
.Sp
example:
.Sp
.Vb 5
\&  my $call = $wsdl\->compileClient
\&    ( operation => \*(AqHelloWorld\*(Aq
\&    , port      => \*(AqPrefillSoap\*(Aq # only required when multiple ports
\&    );
\&  my ($answer, $trace) = $call\->($request);
\&
\&  # \*(Aqoperation\*(Aq keyword optional
\&  my $call = $wsdl\->compileClient(\*(AqHelloWorld\*(Aq);
.Ve
.RE
.ie n .IP "$obj\->\fBnamesFor\fR($class)" 4
.el .IP "\f(CW$obj\fR\->\fBnamesFor\fR($class)" 4
.IX Item "$obj->namesFor($class)"
Returns the list of names available for a certain definition \f(CW$class\fR in
the \s-1WSDL\s0. See \fIindex()\fR for a way to determine the available \f(CW$class\fR
information.
.ie n .IP "$obj\->\fBoperation\fR( [$name], %options )" 4
.el .IP "\f(CW$obj\fR\->\fBoperation\fR( [$name], \f(CW%options\fR )" 4
.IX Item "$obj->operation( [$name], %options )"
Collect all information for a certain operation.  Returned is an
XML::Compile::SOAP::Operation object.
.Sp
An operation is defined by a service name, a port, some bindings,
and an operation name, which can be specified explicitly and is often
left-out: in the many configurations where there are no alternative
choices. In case there are alternatives, you will be requested to
pick an option.
.Sp
.Vb 6
\& \-Option     \-\-Default
\&  action       <undef>
\&  operation    <required>
\&  port         <only when just one port in WSDL>
\&  server_type  undef
\&  service      <only when just one service in WSDL>
.Ve
.RS 4
.IP "action => \s-1STRING\s0" 2
.IX Item "action => STRING"
Overrule the soapAction from the \s-1WSDL\s0.
.IP "operation => \s-1NAME\s0" 2
.IX Item "operation => NAME"
Ignored when the parameter list starts with a \f(CW$name\fR (which is an
alternative for this option).  Optional when there is only
one operation defined within the portType.
.IP "port => \s-1NAME\s0" 2
.IX Item "port => NAME"
Required when more than one port is defined.
.IP "server_type => \s-1NAME\s0" 2
.IX Item "server_type => NAME"
Overrules new(server_type).
.IP "service => QNAME|PREFIXED" 2
.IX Item "service => QNAME|PREFIXED"
Required when more than one service is defined.
.RE
.RS 4
.RE
.SS "Administration"
.IX Subsection "Administration"
Extends \*(L"Administration\*(R" in XML::Compile::Cache.
.ie n .IP "$obj\->\fBdeclare\fR($group, $component|ARRAY, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBdeclare\fR($group, \f(CW$component\fR|ARRAY, \f(CW%options\fR)" 4
.IX Item "$obj->declare($group, $component|ARRAY, %options)"
Register specific compile \f(CW%options\fR for the specific \f(CW$component\fR. See also
\&\fIXML::Compile::Cache::declare()\fR. The \f(CW$group\fR is either \f(CW\*(C`READER\*(C'\fR,
\&\f(CW\*(C`WRITER\*(C'\fR, \f(CW\*(C`RW\*(C'\fR (both reader and writer), or \f(CW\*(C`OPERATION\*(C'\fR.  As \f(CW$component\fR,
you specify the element name (for readers and writers) or operation name
(for operations). \f(CW%options\fR are specified as \s-1LIST\s0, \s-1ARRAY\s0 or \s-1HASH\s0.
.Sp
example:
.Sp
.Vb 3
\&   $wsdl\->declare(OPERATION => \*(AqGetStockPrice\*(Aq, @extra_opts);
\&   $wsdl\->compileCalls;
\&   my $answer = $wsdl\->call(GetStockPrice => %request);
.Ve
.ie n .IP "$obj\->\fBdoesExtend\fR($exttype, $basetype)" 4
.el .IP "\f(CW$obj\fR\->\fBdoesExtend\fR($exttype, \f(CW$basetype\fR)" 4
.IX Item "$obj->doesExtend($exttype, $basetype)"
Inherited, see \*(L"Administration\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBelements\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBelements\fR()" 4
.IX Item "$obj->elements()"
Inherited, see \*(L"Administration\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBfindName\fR($name)" 4
.el .IP "\f(CW$obj\fR\->\fBfindName\fR($name)" 4
.IX Item "$obj->findName($name)"
Inherited, see \*(L"Administration\*(R" in XML::Compile::Cache
.ie n .IP "$obj\->\fBfindSchemaFile\fR($filename)" 4
.el .IP "\f(CW$obj\fR\->\fBfindSchemaFile\fR($filename)" 4
.IX Item "$obj->findSchemaFile($filename)"
.PD 0
.IP "XML::Compile::WSDL11\->\fBfindSchemaFile\fR($filename)" 4
.IX Item "XML::Compile::WSDL11->findSchemaFile($filename)"
.PD
Inherited, see \*(L"Administration\*(R" in XML::Compile
.ie n .IP "$obj\->\fBimportDefinitions\fR($xmldata, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBimportDefinitions\fR($xmldata, \f(CW%options\fR)" 4
.IX Item "$obj->importDefinitions($xmldata, %options)"
Inherited, see \*(L"Administration\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBknownNamespace\fR($ns|PAIRS)" 4
.el .IP "\f(CW$obj\fR\->\fBknownNamespace\fR($ns|PAIRS)" 4
.IX Item "$obj->knownNamespace($ns|PAIRS)"
.PD 0
.IP "XML::Compile::WSDL11\->\fBknownNamespace\fR($ns|PAIRS)" 4
.IX Item "XML::Compile::WSDL11->knownNamespace($ns|PAIRS)"
.PD
Inherited, see \*(L"Administration\*(R" in XML::Compile
.ie n .IP "$obj\->\fBnamespaces\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnamespaces\fR()" 4
.IX Item "$obj->namespaces()"
Inherited, see \*(L"Administration\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBtypes\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtypes\fR()" 4
.IX Item "$obj->types()"
Inherited, see \*(L"Administration\*(R" in XML::Compile::Schema
.ie n .IP "$obj\->\fBwalkTree\fR($node, \s-1CODE\s0)" 4
.el .IP "\f(CW$obj\fR\->\fBwalkTree\fR($node, \s-1CODE\s0)" 4
.IX Item "$obj->walkTree($node, CODE)"
Inherited, see \*(L"Administration\*(R" in XML::Compile
.SS "Introspection"
.IX Subsection "Introspection"
All of the following methods are usually \s-1NOT\s0 meant for end-users. End-users
should stick to the \fIoperation()\fR and \fIcompileClient()\fR methods.
.ie n .IP "$obj\->\fBendPoint\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBendPoint\fR(%options)" 4
.IX Item "$obj->endPoint(%options)"
[2.20] Returns the address of the server, as specified by the \s-1WSDL\s0. When
there are no alternatives for service or port, you not not need to
specify those parameters.
.Sp
The endpoint in the \s-1WSDL\s0 is often wrong.  All compile functions accept
the \f(CW\*(C`server\*(C'\fR and \f(CW\*(C`endpoint\*(C'\fR parameters to overrule the value.  With
\&\f(CW\*(C`server\*(C'\fR, only the hostname:port is being replaced.  With \f(CW\*(C`endpoint\*(C'\fR,
everything is replaced.
.Sp
.Vb 3
\& \-Option \-\-Default
\&  port     <undef>
\&  service  <undef>
.Ve
.RS 4
.IP "port => \s-1NAME\s0" 2
.IX Item "port => NAME"
.PD 0
.IP "service => QNAME|PREFIXED" 2
.IX Item "service => QNAME|PREFIXED"
.RE
.RS 4
.PD
.Sp
example:
.Sp
.Vb 3
\& my $devel = URI\->new($wsdl\->endPoint);
\& $devel\->path(\*(Aq/sdk\*(Aq);
\& my $call = $wsdl\->compileCall($opname, endpoint => $devel);
.Ve
.RE
.ie n .IP "$obj\->\fBexplain\fR($operation, $format, $direction, %options)" 4
.el .IP "\f(CW$obj\fR\->\fBexplain\fR($operation, \f(CW$format\fR, \f(CW$direction\fR, \f(CW%options\fR)" 4
.IX Item "$obj->explain($operation, $format, $direction, %options)"
[2.13]
Produce templates (see \fIXML::Compile::Schema::template()\fR which detail
the use of the \f(CW$operation\fR. Currently, only the \f(CW\*(C`PERL\*(C'\fR template \f(CW$format\fR
is available.
.Sp
The \f(CW$direction\fR of operation is either \f(CW\*(C`INPUT\*(C'\fR (input for the server,
hence to be produced by the client), or \f(CW\*(C`OUTPUT\*(C'\fR (from the server,
received by the client).
.Sp
The actual work is done by \fIXML::Compile::SOAP::Operation::explain()\fR. The
\&\f(CW%options\fR passed to that method include \f(CW\*(C`recurse\*(C'\fR and \f(CW\*(C`skip_header\*(C'\fR.
.Sp
example:
.Sp
.Vb 1
\&  print $wsdl\->explain(\*(AqCheckStatus\*(Aq, PERL => \*(AqINPUT\*(Aq);
\&
\&  print $wsdl\->explain(\*(AqCheckStatus\*(Aq, PERL => \*(AqOUTPUT\*(Aq
\&     , recurse => 1                 # explain options
\&     , port    => \*(AqSoap12PortName\*(Aq  # operation options
\&     );
\&
\&  foreach my $op ($wsdl\->operations)
\&  {  print $op\->explain($wsdl, PERL => \*(AqINPUT\*(Aq);
\&  }
.Ve
.ie n .IP "$obj\->\fBfindDef\fR( $class, <$qname|$prefixed|$name> )" 4
.el .IP "\f(CW$obj\fR\->\fBfindDef\fR( \f(CW$class\fR, <$qname|$prefixed|$name> )" 4
.IX Item "$obj->findDef( $class, <$qname|$prefixed|$name> )"
With a \f(CW$qname\fR, the \s-1HASH\s0 which contains the parsed \s-1XML\s0 information
from the \s-1WSDL\s0 template for that \f(CW$class\fR\-$name combination is returned.
You may also have a \f(CW$prefixed\fR name, using one of the predefined namespace
abbreviations.  Otherwise, \f(CW$name\fR is considered to be the localName in
that class.  When the \f(CW$name\fR is not found, an error is produced.
.Sp
Without \f(CW$qname\fR in \s-1SCALAR\s0 context, there may only be one such name
defined otherwise an error is produced.  In \s-1LIST\s0 context, all definitions
in \f(CW$class\fR are returned.
.Sp
example:
.Sp
.Vb 2
\& $service  = $obj\->findDef(service => \*(Aqhttp://xyz\*(Aq);
\& @services = $obj\->findDef(\*(Aqservice\*(Aq);
.Ve
.ie n .IP "$obj\->\fBindex\fR( [$class, [$qname]] )" 4
.el .IP "\f(CW$obj\fR\->\fBindex\fR( [$class, [$qname]] )" 4
.IX Item "$obj->index( [$class, [$qname]] )"
With a \f(CW$class\fR and \f(CW$qname\fR, it returns one \s-1WSDL\s0 definition \s-1HASH\s0 or undef.
Returns the index for the \f(CW$class\fR group of names as \s-1HASH\s0.  When no \f(CW$class\fR is
specified, a \s-1HASH\s0 of HASHes is returned with the CLASSes on the top-level.
.Sp
\&\f(CW$class\fR includes \f(CW\*(C`service\*(C'\fR, \f(CW\*(C`binding\*(C'\fR, \f(CW\*(C`portType\*(C'\fR, and \f(CW\*(C`message\*(C'\fR.
.ie n .IP "$obj\->\fBoperations\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBoperations\fR(%options)" 4
.IX Item "$obj->operations(%options)"
Return a list with all operations defined in the \s-1WSDL\s0.
.Sp
.Vb 5
\& \-Option     \-\-Default
\&  binding      <undef>
\&  port         <undef>
\&  server_type  undef
\&  service      <undef>
.Ve
.RS 4
.IP "binding => \s-1NAME\s0" 2
.IX Item "binding => NAME"
Only return operations which use the binding with the specified \s-1NAME\s0.
By default, all bindings are accepted.
.IP "port => \s-1NAME\s0" 2
.IX Item "port => NAME"
Return only operations related to the specified port \s-1NAME\s0.
By default operations from all ports.
.IP "server_type => \s-1STRING\s0" 2
.IX Item "server_type => STRING"
[3.06]
.IP "service => \s-1NAME\s0" 2
.IX Item "service => NAME"
Only return operations related to the NAMEd service, by default all services.
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBprintIndex\fR( [$fh], %options )" 4
.el .IP "\f(CW$obj\fR\->\fBprintIndex\fR( [$fh], \f(CW%options\fR )" 4
.IX Item "$obj->printIndex( [$fh], %options )"
For available \f(CW%options\fR, see \fIoperations()\fR.  This method is useful to
understand the structure of your \s-1WSDL:\s0 it shows a nested list of
services, bindings, ports and portTypes.
.Sp
.Vb 2
\& \-Option       \-\-Defined in         \-\-Default
\&  show_declared  XML::Compile::Cache  <true>
.Ve
.RS 4
.IP "show_declared => \s-1BOOLEAN\s0" 2
.IX Item "show_declared => BOOLEAN"
.RE
.RS 4
.RE
.SH "DETAILS"
.IX Header "DETAILS"
Extends \*(L"\s-1DETAILS\s0\*(R" in XML::Compile::Cache.
.SS "Distribution collection overview"
.IX Subsection "Distribution collection overview"
Extends \*(L"Distribution collection overview\*(R" in XML::Compile::Cache.
.SS "Comparison"
.IX Subsection "Comparison"
Extends \*(L"Comparison\*(R" in XML::Compile::Cache.
.SS "Collecting definitions"
.IX Subsection "Collecting definitions"
Extends \*(L"Collecting definitions\*(R" in XML::Compile::Cache.
.SS "Addressing components"
.IX Subsection "Addressing components"
Extends \*(L"Addressing components\*(R" in XML::Compile::Cache.
.SS "Representing data-structures"
.IX Subsection "Representing data-structures"
Extends \*(L"Representing data-structures\*(R" in XML::Compile::Cache.
.SS "Schema hooks"
.IX Subsection "Schema hooks"
Extends \*(L"Schema hooks\*(R" in XML::Compile::Cache.
.SS "Typemaps"
.IX Subsection "Typemaps"
Extends \*(L"Typemaps\*(R" in XML::Compile::Cache.
.SS "Handling xsi:type"
.IX Subsection "Handling xsi:type"
Extends \*(L"Handling xsi:type\*(R" in XML::Compile::Cache.
.SS "Key rewrite"
.IX Subsection "Key rewrite"
Extends \*(L"Key rewrite\*(R" in XML::Compile::Cache.
.SS "Initializing \s-1SOAP\s0 operations via \s-1WSDL\s0"
.IX Subsection "Initializing SOAP operations via WSDL"
When you have a \s-1WSDL\s0 file, then \s-1SOAP\s0 is simple.  If there is no such file
at hand, then it is still possible to use \s-1SOAP\s0.  See the \s-1DETAILS\s0 chapter
in XML::Compile::SOAP.
.PP
The \s-1WSDL\s0 file contains operations which can be addressed by name.
In the \s-1WSDL\s0 file you need to find the name of the port to be used.
In most cases, the \s-1WSDL\s0 has only one service, one port, one binding,
and one portType and those names can therefore be omitted.  If there is
a choice, then you must explicitly select one.
.PP
.Vb 1
\& use XML::Compile::WSDL11 ();
\&
\& # once in your program
\& my $wsdl   = XML::Compile::WSDL11\->new(\*(Aqdef.wsdl\*(Aq);
\&
\& # XML::Compile::Schema refuses to follow "include" and
\& # "import" commands, so you need to invoke them explicitly.
\& # $wsdl\->addWSDL(\*(Aqfile2.wsdl\*(Aq);            # optional
\& # $wsdl\->importDefinitions(\*(Aqschema1.xsd\*(Aq); # optional
\&
\& # once for each of the defined operations
\& my $call   = $wsdl\->compileClient(\*(AqGetStockPrice\*(Aq);
\&
\& # see XML::Compile::SOAP chapter DETAILS about call params
\& my $answer = $call\->(%request);
.Ve
.SH "DESCRIPTIONS"
.IX Header "DESCRIPTIONS"
Extends \*(L"\s-1DESCRIPTIONS\s0\*(R" in XML::Compile::Cache.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML\-Compile\-WSDL11 distribution version 3.06,
built on January 11, 2017. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2014\-2017 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
