.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::Passphrase::DESCrypt 3"
.TH Authen::Passphrase::DESCrypt 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::Passphrase::DESCrypt \- passphrases using the DES\-based Unix
crypt()
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Authen::Passphrase::DESCrypt;
\&
\&        $ppr = Authen::Passphrase::DESCrypt\->new(
\&                        salt_base64 => "my",
\&                        hash_base64 => "TYK.j.88/9s");
\&
\&        $ppr = Authen::Passphrase::DESCrypt\->new(
\&                        salt_random => 12,
\&                        passphrase => "passphrase");
\&
\&        $ppr = Authen::Passphrase::DESCrypt
\&                \->from_crypt(\*(AqmyTYK.j.88/9s\*(Aq);
\&
\&        $ppr = Authen::Passphrase::DESCrypt\->new(
\&                        fold => 1,
\&                        initial => "xyzzy!!!",
\&                        nrounds => 500,
\&                        salt_base64 => "quux",
\&                        hash_base64 => "QCKcHlgVsRY");
\&
\&        $fold = $ppr\->fold;
\&        $initial = $ppr\->initial;
\&        $initial_base64 = $ppr\->initial_base64;
\&        $nrounds = $ppr\->nrounds;
\&        $nrounds_base64 = $ppr\->nrounds_base64_4;
\&        $salt = $ppr\->salt;
\&        $salt_base64 = $ppr\->salt_base64_2;
\&        $salt_base64 = $ppr\->salt_base64_4;
\&        $hash = $ppr\->hash;
\&        $hash_base64 = $ppr\->hash_base64;
\&
\&        if($ppr\->match($passphrase)) { ...
\&
\&        $passwd = $ppr\->as_crypt;
\&        $userPassword = $ppr\->as_rfc2307;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class encapsulates a passphrase hashed using some
form of the DES-based Unix \fIcrypt()\fR hash function.  This is a subclass
of Authen::Passphrase, and this document assumes that the reader is
familiar with the documentation for that class.
.PP
The \fIcrypt()\fR function in a modern Unix actually supports several different
passphrase schemes.  That is not what this class is about.  This class
is concerned only with one family of schemes, variants of the DES-based
scheme that \fIcrypt()\fR originally implemented, which confusingly is usually
referred to merely as \*(L"\fIcrypt()\fR\*(R".  To handle the whole range of passphrase
schemes supported by the modern \fIcrypt()\fR, see the
from_crypt constructor and the
as_crypt method in Authen::Passphrase.
.PP
\&\fIWarning:\fR this password scheme is weak by modern standards, and in
any case does not support a large password space.  Cracking \fIcrypt()\fRed
passwords has been a routine activity since the early 1990s.  This scheme
is supported for compatibility reasons only, and should not be used
except when compatibility is required.  Do not use this in the design of
any new system or for new passwords in any system that supports better
passphrase schemes.
.SS "The traditional DES-based Unix \fIcrypt()\fP password scheme"
.IX Subsection "The traditional DES-based Unix crypt() password scheme"
The traditional Unix \fIcrypt()\fR password scheme is based on the \s-1DES\s0 block
encryption algorithm.  Using the password as a 56\-bit key, it passes a
64\-bit data block, initialised to zero, through the encryption function
25 times, and the hash is the 64\-bit output of this process.  A 12\-bit
salt is used to tweak the encryption algorithm.
.PP
The 56\-bit key is extracted from the password in a very poor way.
Only the first eight bytes of the password are used, and any remainder
is ignored.  This makes it impossible to use a passphrase, rather than
a password, hence the terminology in this section.  Of the eight bytes
used, the top bit is also ignored; this function hails from the days of
pure \s-1ASCII\s0.
.PP
A password hash of this scheme is conventionally represented in \s-1ASCII\s0 as
a 13\-character string using a base 64 encoding.  The base 64 digits are
"\fB.\fR\*(L", \*(R"\fB/\fR\*(L", \*(R"\fB0\fR\*(L" to \*(R"\fB9\fR\*(L", \*(R"\fBA\fR\*(L" to \*(R"\fBZ\fR\*(L", \*(R"\fBa\fR\*(L" to \*(R"\fBz\fR"
(in \s-1ASCII\s0 order).  The first two characters give the 12\-bit salt.
The remaining eleven characters give the 64\-bit hash.  Because the base
64 encoding can represent 66 bits in eleven digits, more than the 64
required, the last character of the string can only take sixteen of the
base 64 digit values.
.SS "Variant DES-based Unix \fIcrypt()\fP passphrase schemes"
.IX Subsection "Variant DES-based Unix crypt() passphrase schemes"
To make password cracking more difficult, historically some Unix sites
modified the \fIcrypt()\fR function to be incompatible with the standard one.
This was easily achieved by initialising the data block to something
other than the standard all-bits-zero.  Another variation used was to
increase the number of encryption rounds, which makes cracking take
longer in addition to being non-standard.  Password hashes on such a
system looked normal but were not interoperable with standard \fIcrypt()\fR
implementations.  To interpret them properly it is necessary to know
the modified parameters.
.PP
BSDi standardised an extended DES-based scheme.  The salt is extended to
24 bits, and the number of encryption rounds is variable.  Passphrases
longer than 8 characters are handled by an additional step that folds
(hashes) them down to 8 characters, rather than just throwing away
the characters after the eighth.  Passphrase hashes in this scheme
are conventionally represented in \s-1ASCII\s0 as a "\fB_\fR" followed by 19
characters of base 64.  The first four base 64 digits give the number
of encryption rounds, the next four give the salt, and the remaining
eleven give the hash.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.IP "Authen::Passphrase::DESCrypt\->new(\s-1ATTR\s0 => \s-1VALUE\s0, ...)" 4
.IX Item "Authen::Passphrase::DESCrypt->new(ATTR => VALUE, ...)"
Generates a new passphrase recogniser object using the generalised
DES-based \fIcrypt()\fR algorithm.  The following attributes may be given:
.RS 4
.IP "\fBfold\fR" 4
.IX Item "fold"
Truth value indicating whether the BSDi passphrase folding scheme should be
used for long passphrases.  Default false, for compatibility with the
original DES-based scheme.
.IP "\fBinitial\fR" 4
.IX Item "initial"
The initial data block to encrypt, as a string of exactly eight bytes.
Default all bits zero, for compatibility with the original DES-based
scheme.
.IP "\fBinitial_base64\fR" 4
.IX Item "initial_base64"
The initial data block to encrypt, as a string of eleven base 64 digits.
.IP "\fBnrounds\fR" 4
.IX Item "nrounds"
The number of encryption rounds to use, as a Perl integer.  Default 25,
for compatibility with the original DES-based scheme.
.IP "\fBnrounds_base64\fR" 4
.IX Item "nrounds_base64"
The number of encryption rounds to use, as a string of four base 64
digits.
.IP "\fBsalt\fR" 4
.IX Item "salt"
The salt, as an integer in the range [0, 16777216).
.IP "\fBsalt_base64\fR" 4
.IX Item "salt_base64"
The salt, as a string of two or four base 64 digits.
.IP "\fBsalt_random\fR" 4
.IX Item "salt_random"
Causes salt to be generated randomly.  The value given for this attribute
must be either 12 or 24, giving the number of bits of salt to generate.
The source of randomness may be controlled by the facility described
in Data::Entropy.
.IP "\fBhash\fR" 4
.IX Item "hash"
The hash (output of encryption), as a string of exactly eight bytes.
.IP "\fBhash_base64\fR" 4
.IX Item "hash_base64"
The hash, as a string of eleven base 64 digits.
.IP "\fBpassphrase\fR" 4
.IX Item "passphrase"
A passphrase that will be accepted.
.RE
.RS 4
.Sp
The salt must be given, and either the hash or the passphrase.  The other
parameters default to those used in the original DES-based \fIcrypt()\fR.
.RE
.IP "Authen::Passphrase::DESCrypt\->from_crypt(\s-1PASSWD\s0)" 4
.IX Item "Authen::Passphrase::DESCrypt->from_crypt(PASSWD)"
Generates a new passphrase recogniser object using the DES-based \fIcrypt()\fR
algorithm, from a crypt string.  Two forms of crypt string are supported.
.Sp
The first form of crypt string must consist of 13 base 64 digits.
The first two give the salt, and the next eleven give the hash.
Long passphrases are not folded, the initial block is all bits zero,
and 25 encryption rounds are performed.
.Sp
The second form of crypt string must consist of an "\fB_\fR" followed
by 19 base 64 digits.  The first four give the number of encryption
rounds, the next four give the salt, and the next eleven give the hash.
Long passphrases are folded, and the initial block is all bits zero.
.IP "Authen::Passphrase::DESCrypt\->from_rfc2307(\s-1USERPASSWORD\s0)" 4
.IX Item "Authen::Passphrase::DESCrypt->from_rfc2307(USERPASSWORD)"
Generates a new passphrase recogniser object using the DES-based
\&\fIcrypt()\fR algorithm, from an \s-1RFC\s0 2307 string.  The string must consist of
"\fB{\s-1CRYPT\s0}\fR" (case insensitive) followed by an acceptable crypt string.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ppr\->fold" 4
.el .IP "\f(CW$ppr\fR\->fold" 4
.IX Item "$ppr->fold"
Returns a truth value indicating whether passphrase folding is used.
.ie n .IP "$ppr\->initial" 4
.el .IP "\f(CW$ppr\fR\->initial" 4
.IX Item "$ppr->initial"
Returns the initial block, as a string of eight bytes.
.ie n .IP "$ppr\->initial_base64" 4
.el .IP "\f(CW$ppr\fR\->initial_base64" 4
.IX Item "$ppr->initial_base64"
Returns the initial block, as a string of eleven base 64 digits.
.ie n .IP "$ppr\->nrounds" 4
.el .IP "\f(CW$ppr\fR\->nrounds" 4
.IX Item "$ppr->nrounds"
Returns the number of encryption rounds, as a Perl integer.
.ie n .IP "$ppr\->nrounds_base64_4" 4
.el .IP "\f(CW$ppr\fR\->nrounds_base64_4" 4
.IX Item "$ppr->nrounds_base64_4"
Returns the number of encryption rounds, as a string of four base
64 digits.
.ie n .IP "$ppr\->salt" 4
.el .IP "\f(CW$ppr\fR\->salt" 4
.IX Item "$ppr->salt"
Returns the salt, as a Perl integer.
.ie n .IP "$ppr\->salt_base64_2" 4
.el .IP "\f(CW$ppr\fR\->salt_base64_2" 4
.IX Item "$ppr->salt_base64_2"
Returns the salt, as a string of two base 64 digits.  \f(CW\*(C`die\*(C'\fRs if it
doesn't fit into two digits.
.ie n .IP "$ppr\->salt_base64_4" 4
.el .IP "\f(CW$ppr\fR\->salt_base64_4" 4
.IX Item "$ppr->salt_base64_4"
Returns the salt, as a string of four base 64 digits.
.ie n .IP "$ppr\->hash" 4
.el .IP "\f(CW$ppr\fR\->hash" 4
.IX Item "$ppr->hash"
Returns the hash value, as a string of eight bytes.
.ie n .IP "$ppr\->hash_base64" 4
.el .IP "\f(CW$ppr\fR\->hash_base64" 4
.IX Item "$ppr->hash_base64"
Returns the hash value, as a string of eleven base 64 digits.
.ie n .IP "$ppr\->match(\s-1PASSPHRASE\s0)" 4
.el .IP "\f(CW$ppr\fR\->match(\s-1PASSPHRASE\s0)" 4
.IX Item "$ppr->match(PASSPHRASE)"
.PD 0
.ie n .IP "$ppr\->as_crypt" 4
.el .IP "\f(CW$ppr\fR\->as_crypt" 4
.IX Item "$ppr->as_crypt"
.ie n .IP "$ppr\->as_rfc2307" 4
.el .IP "\f(CW$ppr\fR\->as_rfc2307" 4
.IX Item "$ppr->as_rfc2307"
.PD
These methods are part of the standard Authen::Passphrase interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::Passphrase,
Crypt::UnixCrypt_XS
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
