.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OAuth::Lite::Util 3"
.TH OAuth::Lite::Util 3 "2014-01-05" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OAuth::Lite::Util \- utility for OAuth
.SH "SYNPSIS"
.IX Header "SYNPSIS"
.Vb 7
\&    use OAuth::Lite::Util qw(
\&        gen_random_key
\&        encode_param
\&        decode_param
\&        create_signature_base_string
\&        parse_auth_header
\&    );
\&
\&    my $random = gen_random_key(8);
\&    my $enocded = encode_param($param);
\&    my $deocded = decode_param($encoded);
\&
\&    my $base_string = create_signature_base_string(\*(AqGET\*(Aq,
\&        \*(Aqhttp://example.com/path?query\*(Aq, $params);
\&
\&    my $header = q{OAuth realm="http://example.com/api/resource", oauth_consumer_key="hogehoge", ... };
\&    my ($realm, $oauth_params) = parse_auth_header($header);
\&    say $realm;
\&    say $oauth_params\->{oauth_consumer_key};
\&    say $oauth_params\->{oauth_version};
\&    ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Utilty functions for OAuth are implemented here.
.SH "PAY ATTENTION"
.IX Header "PAY ATTENTION"
If you use OAuth 1.31 or older version, its has invalid way to normalize params.
(when there are two or more same key and they contain \s-1ASCII\s0 and non \s-1ASCII\s0 value)
.PP
But the many services have already supported deprecated version, 
and the correct way breaks backward compatibility.
So, from 1.32, supported both correct and deprecated method.
.PP
use \f(CW$OAuth::Lite::USE_DEPRECATED_NORMALIZER\fR to switch behaviour.
Currently 1 is set by default to keep backward compatibility.
.PP
.Vb 4
\&    use OAuth::Lite::Util;
\&    use OAuth::Lite;
\&    $OAuth::Lite::USE_DEPRECATED_NORMALIZER = 0;
\&    ...
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "gen_random_key($length)"
.IX Subsection "gen_random_key($length)"
Generate random octet string.
You can indicate the byte-length of generated string. (10 is set by default)
If 10 is passed, returns 20\-length octet string.
.PP
.Vb 3
\&    use OAuth::Lite::Util qw(gen_random_key);
\&    my $key1 = gen_random_key();
\&    my $key2 = gen_random_key();
.Ve
.SS "encode_param($param)"
.IX Subsection "encode_param($param)"
Encode parameter according to the way defined in OAuth Core spec.
.SS "decode_param($encoded_param)"
.IX Subsection "decode_param($encoded_param)"
Decode the encoded parameter.
.ie n .SS "create_signature_base_string($http_method, $request_uri, $params);"
.el .SS "create_signature_base_string($http_method, \f(CW$request_uri\fP, \f(CW$params\fP);"
.IX Subsection "create_signature_base_string($http_method, $request_uri, $params);"
.Vb 9
\&    my $method = "GET";
\&    my $uri = "http://example.com/api/for/some\-resource";
\&    my $parmas = {
\&        oauth_consumer_key     => \*(Aqfoo\-bar\*(Aq,
\&        oauth_signature_method => \*(AqHMAC\-SHA1\*(Aq,
\&        oauth_version => \*(Aq1.0\*(Aq,
\&        ...
\&    };
\&    my $base_string = create_signature_base_string($method, $uri, $params);
.Ve
.SS "normalize_request_url($url);"
.IX Subsection "normalize_request_url($url);"
Normalize url according to the way the OAuth Core spec defines.
.PP
.Vb 6
\&    my $string = normalize_request_url(\*(Aqhttp://Example.com:80/path?query\*(Aq);
\&    # http://example.com/path
\&    my $string = normalize_request_url(\*(Aqhttps://Example.com:443/path?query\*(Aq);
\&    # https://example.com/path
\&    my $string = normalize_request_url(\*(Aqhttp://Example.com:8080/path?query\*(Aq);
\&    # http://example.com:8080/path
.Ve
.SS "normalize_params($params);"
.IX Subsection "normalize_params($params);"
Sort and encode params and concatenates them
according to the way OAuth Core spec defines.
.PP
.Vb 3
\&    my $string = normalize_params({
\&        a => 1, c => \*(Aqhi%20there\*(Aq, f => [25, 50, \*(Aqa\*(Aq], z => [ \*(Aqp\*(Aq, \*(Aqt\*(Aq ]
\&    });
.Ve
.SS "parse_auth_header($header)"
.IX Subsection "parse_auth_header($header)"
Parse authorization/www\-authentication header for OAuth.
And return the realm and other params.
.PP
.Vb 7
\&    # service provider side
\&    my $header = $r\->headers_in\->{Authorization};
\&    my ($realm, $params) = parse_auth_header($header);
\&    say $params\->{oauth_token};
\&    say $params\->{oauth_consumer_key};
\&    say $params\->{oauth_signature_method};
\&    ...
\&
\&    # consumer side
\&    my $header = $res\->header(\*(AqWWW\-Authenticate\*(Aq);
\&    my ($realm) = parse_auth_header($header);
.Ve
.SS "build_auth_header(%params)"
.IX Subsection "build_auth_header(%params)"
.Vb 5
\&    my $header = build_auth_header($realm, {
\&        oauth_consumer_key     => \*(Aq...\*(Aq, 
\&        oauth_signature_method => \*(Aq...\*(Aq,
\&        ... and other oauth params
\&    });
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Lyo Kato, \f(CW\*(C`lyo.kato _at_ gmail.com\*(C'\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.6 or,
at your option, any later version of Perl 5 you may have available.
