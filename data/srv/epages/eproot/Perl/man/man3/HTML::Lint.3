.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::Lint 3"
.TH HTML::Lint 3 "2012-04-06" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::Lint \- check for HTML errors in a string or file
.SH "VERSION"
.IX Header "VERSION"
Version 2.20
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    my $lint = HTML::Lint\->new;
\&    $lint\->only_types( HTML::Lint::Error::STRUCTURE );
\&
\&    $lint\->parse( $data );
\&    $lint\->parse_file( $filename );
\&
\&    my $error_count = $lint\->errors;
\&
\&    foreach my $error ( $lint\->errors ) {
\&        print $error\->as_string, "\en";
\&    }
.Ve
.PP
HTML::Lint also comes with a wrapper program called \fIweblint\fR that handles
linting from the command line:
.PP
.Vb 6
\&    $ weblint http://www.cnn.com/
\&    http://www.cnn.com/ (395:83) <IMG SRC="spacer.gif"> tag has no HEIGHT and WIDTH attributes.
\&    http://www.cnn.com/ (395:83) <IMG SRC="goofus.gif"> does not have ALT text defined
\&    http://www.cnn.com/ (396:217) Unknown element <nobr>
\&    http://www.cnn.com/ (396:241) </nobr> with no opening <nobr>
\&    http://www.cnn.com/ (842:7) target attribute in <a> is repeated
.Ve
.PP
And finally, you can also get Apache::HTML::Lint that passes any
mod_perl\-generated code through HTML::Lint and get it dumped into your
Apache \fIerror_log\fR.
.PP
.Vb 3
\&    [Mon Jun  3 14:03:31 2002] [warn] /foo.pl (1:45) </p> with no opening <p>
\&    [Mon Jun  3 14:03:31 2002] [warn] /foo.pl (1:49) Unknown element <gronk>
\&    [Mon Jun  3 14:03:31 2002] [warn] /foo.pl (1:56) Unknown attribute "x" for tag <table>
.Ve
.SH "METHODS"
.IX Header "METHODS"
\&\s-1NOTE:\s0 Some of these methods mirror HTML::Parser's methods, but HTML::Lint
is not a subclass of HTML::Parser.
.SS "\fInew()\fP"
.IX Subsection "new()"
Create an HTML::Lint object, which inherits from HTML::Parser.
You may pass the types of errors you want to check for in the
\&\f(CW\*(C`only_types\*(C'\fR parm.
.PP
.Vb 1
\&    my $lint = HTML::Lint\->new( only_types => HTML::Lint::Error::STRUCTURE );
.Ve
.PP
If you want more than one, you must pass an arrayref:
.PP
.Vb 2
\&    my $lint = HTML::Lint\->new(
\&        only_types => [HTML::Lint::Error::STRUCTURE, HTML::Lint::Error::FLUFF] );
.Ve
.ie n .SS "$lint\->\fIparser()\fP"
.el .SS "\f(CW$lint\fP\->\fIparser()\fP"
.IX Subsection "$lint->parser()"
Returns the parser object for this object, creating one if necessary.
.ie n .SS "$lint\->parse( $text )"
.el .SS "\f(CW$lint\fP\->parse( \f(CW$text\fP )"
.IX Subsection "$lint->parse( $text )"
.ie n .SS "$lint\->parse( $code_ref )"
.el .SS "\f(CW$lint\fP\->parse( \f(CW$code_ref\fP )"
.IX Subsection "$lint->parse( $code_ref )"
Passes in a chunk of \s-1HTML\s0 to be linted, either as a piece of text,
or a code reference.
See HTML::Parser's \f(CW\*(C`parse_file\*(C'\fR method for details.
.ie n .SS "$lint\->parse_file( $file )"
.el .SS "\f(CW$lint\fP\->parse_file( \f(CW$file\fP )"
.IX Subsection "$lint->parse_file( $file )"
Analyzes \s-1HTML\s0 directly from a file. The \f(CW$file\fR argument can be a filename,
an open file handle, or a reference to an open file handle.
See HTML::Parser's \f(CW\*(C`parse_file\*(C'\fR method for details.
.ie n .SS "$lint\->eof"
.el .SS "\f(CW$lint\fP\->eof"
.IX Subsection "$lint->eof"
Signals the end of a block of text getting passed in.  This must be
called to make sure that all parsing is complete before looking at errors.
.PP
Any parameters (and there shouldn't be any) are passed through to
HTML::Parser's \fIeof()\fR method.
.ie n .SS "$lint\->\fIerrors()\fP"
.el .SS "\f(CW$lint\fP\->\fIerrors()\fP"
.IX Subsection "$lint->errors()"
In list context, \f(CW\*(C`errors\*(C'\fR returns all of the errors found in the
parsed text.  Each error is an object of the type HTML::Lint::Error.
.PP
In scalar context, it returns the number of errors found.
.ie n .SS "$lint\->\fIclear_errors()\fP"
.el .SS "\f(CW$lint\fP\->\fIclear_errors()\fP"
.IX Subsection "$lint->clear_errors()"
Clears the list of errors, in case you want to print and clear, print and clear.
.ie n .SS "$lint\->only_types( $type1[, $type2...] )"
.el .SS "\f(CW$lint\fP\->only_types( \f(CW$type1\fP[, \f(CW$type2\fP...] )"
.IX Subsection "$lint->only_types( $type1[, $type2...] )"
Specifies to only want errors of a certain type.
.PP
.Vb 1
\&    $lint\->only_types( HTML::Lint::Error::STRUCTURE );
.Ve
.PP
Calling this without parameters makes the object return all possible
errors.
.PP
The error types are \f(CW\*(C`STRUCTURE\*(C'\fR, \f(CW\*(C`HELPER\*(C'\fR and \f(CW\*(C`FLUFF\*(C'\fR.
See HTML::Lint::Error for details on these types.
.ie n .SS "$lint\->gripe( $errcode, [$key1=>$val1, ...] )"
.el .SS "\f(CW$lint\fP\->gripe( \f(CW$errcode\fP, [$key1=>$val1, ...] )"
.IX Subsection "$lint->gripe( $errcode, [$key1=>$val1, ...] )"
Adds an error message, in the form of an HTML::Lint::Error object,
to the list of error messages for the current object.  The file,
line and column are automatically passed to the HTML::Lint::Error
constructor, as well as whatever other key value pairs are passed.
.PP
For example:
.PP
.Vb 1
\&    $lint\->gripe( \*(Aqattr\-repeated\*(Aq, tag => $tag, attr => $attr );
.Ve
.PP
Usually, the user of the object won't call this directly, but just
in case, here you go.
.ie n .SS "$lint\->newfile( $filename )"
.el .SS "\f(CW$lint\fP\->newfile( \f(CW$filename\fP )"
.IX Subsection "$lint->newfile( $filename )"
Call \f(CW\*(C`newfile()\*(C'\fR whenever you switch to another file in a batch
of linting.  Otherwise, the object thinks everything is from the
same file.  Note that the list of errors is \s-1NOT\s0 cleared.
.PP
Note that \fI\f(CI$filename\fI\fR does \s-1NOT\s0 need to match what's put into \fIparse()\fR
or \fIparse_file()\fR.  It can be a description, a \s-1URL\s0, or whatever.
.SH "MODIFYING HTML::LINT'S BEHAVIOR"
.IX Header "MODIFYING HTML::LINT'S BEHAVIOR"
Sometimes you'll have \s-1HTML\s0 that for some reason cannot conform to
HTML::Lint's expectations.  For those instances, you can use \s-1HTML\s0
comments to modify HTML::Lint's behavior.
.PP
Say you have an image where for whatever reason you can't get
dimensions for the image.  This \s-1HTML\s0 snippet:
.PP
.Vb 2
\&    <img src="logo.png" height="120" width="50" alt="Company logo">
\&    <img src="that.png">
.Ve
.PP
causes this error:
.PP
.Vb 1
\&    foo.html (14:20) <img src="that.png"> tag has no HEIGHT and WIDTH attributes
.Ve
.PP
But if for some reason you can't get those dimensions when you build
the page, you can at least stop HTML::Lint complaining about it.
.PP
.Vb 4
\&    <img src="this.png" height="120" width="50" alt="Company logo">
\&    <!\-\- html\-lint elem\-img\-sizes\-missing: off, elem\-img\-alt\-missing: off \-\->
\&    <img src="that.png">
\&    <!\-\- html\-lint elem\-img\-sizes\-missing: on, elem\-img\-alt\-missing: off \-\->
.Ve
.PP
If you want to turn off all HTML::Lint warnings for a block of code, use
.PP
.Vb 1
\&    <!\-\- html\-lint all: off \-\->
.Ve
.PP
And turn them back on with
.PP
.Vb 1
\&    <!\-\- html\-lint all: off \-\->
.Ve
.PP
You don't have to use \*(L"on\*(R" and \*(L"off\*(R".  For \*(L"on\*(R", you can use \*(L"true\*(R"
or \*(L"1\*(R".  For \*(L"off\*(R", you can use \*(L"0\*(R" or \*(L"false\*(R".
.PP
For a list of possible errors and their codes, see HTML::Lint::Error,
or run \fIperldoc HTML::Lint::Error\fR.
.SH "BUGS, WISHES AND CORRESPONDENCE"
.IX Header "BUGS, WISHES AND CORRESPONDENCE"
All bugs and requests are now being handled through GitHub.
.PP
.Vb 1
\&    https://github.com/petdance/html\-lint/issues
.Ve
.PP
\&\s-1DO\s0 \s-1NOT\s0 send bug reports to http://rt.cpan.org/ or http://code.google.com/
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Check for attributes that require values
.IP "\(bu" 4
<\s-1TABLE\s0>s that have no rows.
.IP "\(bu" 4
Form fields that aren't in a \s-1FORM\s0
.IP "\(bu" 4
Check for valid entities, and that they end with semicolons
.IP "\(bu" 4
DIVs with nothing in them.
.IP "\(bu" 4
HEIGHT= that have percents in them.
.IP "\(bu" 4
Check for goofy stuff like:
.Sp
.Vb 1
\&    <b><li></b><b>Hello Reader \- Spanish Level 1 (K\-3)</b>
.Ve
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2005\-2012 Andy Lester.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the Artistic License v2.0.
.PP
http://www.opensource.org/licenses/Artistic\-2.0
.PP
Please note that these modules are not products of or supported by the
employers of the various contributors to the code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Andy Lester, andy at petdance.com
