.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Date::Manip::Base 3"
.TH Date::Manip::Base 3 "2011-06-03" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Date::Manip::Base \- Base methods for date manipulation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Date::Manip::Base;
\&   $dmb = new Date::Manip::Base;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Date::Manip package of modules consists of several modules
for doing high level date operations with full error checking
and a lot of flexibility.
.PP
The high level operations, though intended to be used in most
situations, have a lot of overhead associated with them. As such, a
number of the most useful low level routines (which the high level
routines use to do much of the real work) are included in this module
and are available directly to users.
.PP
These low level routines are powerful enough that they can be used
independent of the high level routines and perform useful (though much
simpler) operations. They are also significantly faster than the high
level routines.
.PP
These routines do \s-1NO\s0 error checking on input. Invalid data will result
in meaningless results.  If you need error checking, you must call the
higher level Date::Manip routines instead of these.
.PP
These routines also ignore all effects of time zones and daylight
saving time. One way to think of these routines is working with times
and dates in the \s-1GMT\s0 time zone.
.SH "BASE METHODS"
.IX Header "BASE METHODS"
This class inherits several base methods from the Date::Manip::Obj
class. Please refer to the documentation for that class for a
description of those methods.
.IP "\fBerr\fR" 4
.IX Item "err"
.PD 0
.IP "\fBnew\fR" 4
.IX Item "new"
.IP "\fBnew_config\fR" 4
.IX Item "new_config"
.PD
Please refer to the Date::Manip::Obj documentation for these methods.
.IP "\fBconfig\fR" 4
.IX Item "config"
.Vb 1
\&   $dmb\->config($var1,$val1,$var2,$val2,...);
.Ve
.Sp
This will set the value of any configuration variable. Please refer to the
Date::Manip::Config manual for a list of all configuration variables and their
description.
.SH "DATE METHODS"
.IX Header "DATE METHODS"
In all of the following methods, the following variables are used:
.ie n .IP "\fB\fB$date\fB\fR" 4
.el .IP "\fB\f(CB$date\fB\fR" 4
.IX Item "$date"
This is a list reference containing a full date and time:
.Sp
.Vb 1
\&   [$y, $m, $d, $h, $mn, $s]
.Ve
.ie n .IP "\fB\fB$ymd\fB\fR" 4
.el .IP "\fB\f(CB$ymd\fB\fR" 4
.IX Item "$ymd"
A list reference containing only the date portion:
.Sp
.Vb 1
\&   [$y, $m, $d]
.Ve
.ie n .IP "\fB\fB$hms\fB\fR" 4
.el .IP "\fB\f(CB$hms\fB\fR" 4
.IX Item "$hms"
A list reference containing only the time portion:
.Sp
.Vb 1
\&   [$h, $mn, $s]
.Ve
.ie n .IP "\fB\fB$time\fB\fR" 4
.el .IP "\fB\f(CB$time\fB\fR" 4
.IX Item "$time"
A list reference containing an amount of time:
.Sp
.Vb 1
\&   [$dh, $dmn, $ds]
.Ve
.ie n .IP "\fB\fB$delta\fB\fR" 4
.el .IP "\fB\f(CB$delta\fB\fR" 4
.IX Item "$delta"
A list containing a full delta:
.Sp
.Vb 1
\&   [$dy, $dm, $dw, $dd, $dh, $dmn, $ds]
.Ve
.ie n .IP "\fB\fB$offset\fB\fR" 4
.el .IP "\fB\f(CB$offset\fB\fR" 4
.IX Item "$offset"
A list containing a time zone expressed as an offset:
.Sp
.Vb 1
\&   [ $offh, $offm, $offs ]
.Ve
.PP
In all of the above, the elements ($y, \f(CW$m\fR, \f(CW$d\fR, \f(CW$h\fR, \f(CW$mn\fR, \f(CW$s\fR) are all
numeric. In most of the routines described below, no error checking is
done on the input.  \f(CW$y\fR should be between 1 and 9999, \f(CW$m\fR between 1 and
12, \f(CW$d\fR between 1 and 31, \f(CW$h\fR should be between 0 and 23, \f(CW$mn\fR and \f(CW$s\fR
between 0 and 59.
.PP
\&\f(CW$hms\fR can be between 00:00:00 and 24:00:00, but an \f(CW$offset\fR must be
between \-23:59:59 and +23:59:59.
.PP
Years are not translated to 4 digit years, so passing in a year of
\&\*(L"04\*(R" will be equivalent to \*(L"0004\*(R", \s-1NOT\s0 \*(L"2004\*(R".
.PP
The elements ($dy, \f(CW$dm\fR, \f(CW$dw\fR, \f(CW$dd\fR, \f(CW$dh\fR, \f(CW$dmn\fR, \f(CW$ds\fR) are all numeric,
but can be positive or negative. They represent an elapsed amount
of time measured in years, months, weeks, etc.
.PP
Since no error checking is done, passing in ($y,$m,$d) = (2004,2,31)
will \s-1NOT\s0 trigger an error, even though February does not have 31 days.
Instead, some meaningless result will be returned.
.IP "\fBcalc_date_date\fR" 4
.IX Item "calc_date_date"
.PD 0
.IP "\fBcalc_date_days\fR" 4
.IX Item "calc_date_days"
.IP "\fBcalc_date_delta\fR" 4
.IX Item "calc_date_delta"
.IP "\fBcalc_date_time\fR" 4
.IX Item "calc_date_time"
.IP "\fBcalc_time_time\fR" 4
.IX Item "calc_time_time"
.PD
These are all routines for doing simple date and time calculations.
As mentioned above, they ignore all affects of time zones and daylight
saving time.
.Sp
The following methods are available:
.Sp
.Vb 1
\&   $time = $dmb\->calc_date_date($date1,$date2);
.Ve
.Sp
This take two dates and determine the amount of time between them.
.Sp
.Vb 2
\&   $date = $dmb\->calc_date_days($date,$n [,$subtract]);
\&   $ymd  = $dmb\->calc_date_days($ymd,$n [,$subtract]);
.Ve
.Sp
This returns a date \f(CW$n\fR days later (if \f(CW$n\fR>0) or earlier (if \f(CW$n\fR<0) than
the date passed in. If \f(CW$subtract\fR is passed in, the sign of \f(CW$n\fR is reversed.
.Sp
.Vb 1
\&   $date = $dmb\->calc_date_delta($date,$delta [,$subtract]);
.Ve
.Sp
This take a date and add the given delta to it (or subtract the delta
if \f(CW$subtract\fR is non-zero).
.Sp
.Vb 1
\&   $date = $dmb\->calc_date_time($date,$time [,$subtract]);
.Ve
.Sp
This take a date and add the given time to it (or subtract the time
if \f(CW$subtract\fR is non-zero).
.Sp
.Vb 1
\&   $time = $dmb\->calc_time_time(@time1,@time2 [,$subtract]);
.Ve
.Sp
This take two times and add them together (or subtract the second from
the first if \f(CW$subtract\fR is non-zero).
.IP "\fBcheck\fR" 4
.IX Item "check"
.PD 0
.IP "\fBcheck_time\fR" 4
.IX Item "check_time"
.PD
.Vb 2
\&   $valid = $dmb\->check($date);
\&   $valid = $dmb\->check_time($hms);
.Ve
.Sp
This tests a list of values to see if they form a valid date or time
ignoring all time zone affects. The date/time would be valid in \s-1GMT\s0,
but perhaps not in all time zones.
.Sp
1 is returned if the the fields are valid, 0 otherwise.
.Sp
\&\f(CW$hms\fR is in the range 00:00:00 to 24:00:00.
.IP "\fBcmp\fR" 4
.IX Item "cmp"
.Vb 1
\&   $flag = $dmb\->cmp($date1,$date2);
.Ve
.Sp
Returns \-1, 0, or 1 if date1 is before, the same as, or after date2.
.IP "\fBday_of_week\fR" 4
.IX Item "day_of_week"
.Vb 2
\&   $day = $dmb\->day_of_week($date);
\&   $day = $dmb\->day_of_week($ymd);
.Ve
.Sp
Returns the day of the week (1 for Monday, 7 for Sunday).
.IP "\fBday_of_year\fR" 4
.IX Item "day_of_year"
.Vb 2
\&   $day = $dmb\->day_of_year($ymd);
\&   $day = $dmb\->day_of_year($date);
.Ve
.Sp
In the first case, returns the day of the year (1 to 366) for \f(CW$y\fR, \f(CW$m\fR,
\&\f(CW$d\fR.  In the second case, it returns a fractional day (1.0 <= \f(CW$day\fR <
366.0 or 1.0 <= \f(CW$day\fR < 367.0 for a leap-year).  For example, day 1.5
falls on Jan 1, at noon.  The somewhat non-intuitive answer (1.5
instead of 0.5) is to make the two forms return numerically equivalent
answers for times of 00:00:00 . You can look at the integer part of
the number as being the day of the year, and the fractional part of
the number as the fraction of the day that has passed at the given
time.
.Sp
The inverse operations can also be done:
.Sp
.Vb 2
\&   $ymd   = $dmb\->day_of_year($y,$day);
\&   $date  = $dmb\->day_of_year($y,$day);
.Ve
.Sp
If \f(CW$day\fR is an integer, the year, month, and day is returned. If \f(CW$day\fR
is a floating point number, it returns the year, month, day, hour,
minutes, and decimal seconds.
.Sp
\&\f(CW$day\fR must be greater than or equal to 1 and less than 366 on non-leap years
or 367 on leap years.
.IP "\fBdays_in_month\fR" 4
.IX Item "days_in_month"
.Vb 1
\&   $days = $dmb\->days_in_month($y,$m);
.Ve
.Sp
Returns the number of days in the month.
.Sp
.Vb 1
\&   @days = $dmb\->days_in_month($y,0);
.Ve
.Sp
Returns a list of 12 elements with the days in each month of the year.
.IP "\fBdays_in_year\fR" 4
.IX Item "days_in_year"
.Vb 1
\&   $days = $dmb\->days_in_year($y);
.Ve
.Sp
Returns the number of days in the year (365 or 366)
.IP "\fBdays_since_1BC\fR" 4
.IX Item "days_since_1BC"
.Vb 2
\&   $days = $dmb\->days_since_1BC($date);
\&   $days = $dmb\->days_since_1BC($ymd);
.Ve
.Sp
Returns the number of days since Dec 31, 1BC. Since the calendar has
changed a number of times, the number returned is based on the current
calendar projected backwards in time, and in no way reflects a true
number of days since then. As such, the result is largely meaningless,
except when called twice as a means of determining the number of days
separating two dates.
.Sp
The inverse operation is also available:
.Sp
.Vb 1
\&   $ymd = $dmb\->days_since_1BC($days);
.Ve
.Sp
Returns the date \f(CW$days\fR since Dec 31, 1BC. So day 1 is Jan 1, 0001.
.IP "\fBleapyear\fR" 4
.IX Item "leapyear"
.Vb 1
\&   $flag = $dmb\->leapyear($y);
.Ve
.Sp
Returns 1 if the argument is a leap year.  Originally copied from code
written by David Muir Sharnoff <muir@idiom.com>.
.IP "\fBnth_day_of_week\fR" 4
.IX Item "nth_day_of_week"
.Vb 1
\&   $ymd = $dmb\->nth_day_of_week($y,$n,$dow);
.Ve
.Sp
Returns the \f(CW$n\fR'th occurrence of \f(CW$dow\fR (1 for Monday, 7 for Sunday) in the
year.  \f(CW$n\fR must be between 1 and 53 or \-1 through \-53.
.Sp
.Vb 1
\&   $ymd = $dmb\->nth_day_of_week($y,$n,$dow,$m);
.Ve
.Sp
Returns the \f(CW$n\fR'th occurrence of \f(CW$dow\fR in the given month.  \f(CW$n\fR must be between
1 and 5 or it can be \-1 through \-5.
.Sp
In all cases, nothing is returned if \f(CW$n\fR is beyond the last actual
result (i.e. the 5th Sunday in a month with only four Sundays).
.IP "\fBsecs_since_1970\fR" 4
.IX Item "secs_since_1970"
.Vb 1
\&   $secs = $dmb\->secs_since_1970($date);
.Ve
.Sp
Returns the number of seconds since Jan 1, 1970 00:00:00 (negative if date is
earlier).
.Sp
.Vb 1
\&   $date = $dmb\->secs_since_1970($secs);
.Ve
.Sp
Translates number of seconds into a date.
.IP "\fBsplit\fR" 4
.IX Item "split"
.PD 0
.IP "\fBjoin\fR" 4
.IX Item "join"
.PD
The split and join functions are used to take a string containing a common
type of time data and split it into a list of fields. The join function takes
the list and forms it into a string.
.Sp
Rudimentary error checking is performed with both of these functions
and undef is returned in the case of any error. No error checking is done
on the specific values.
.Sp
The following are allowed:
.Sp
.Vb 2
\&   $date = $dmb\->split("date",$string);
\&   $string = $dmb\->join("date",$date);
.Ve
.Sp
This splits a string containing a date or creates one from a list reference.
The string split must be of one of the forms:
.Sp
.Vb 3
\&   YYYYMMDDHH:MN:SS
\&   YYYYMMDDHHMNSS
\&   YYYY\-MM\-DD\-HH:MN:SS
.Ve
.Sp
The string formed by join is one of the above, depending on the value of
the Printable config variable. The default format is \s-1YYYYMMDDHH:MN:SS\s0,
but if Printable is set to 1, \s-1YYYYMMDDHHMNSS\s0 is produced, and if Printable
is set to 2, the \s-1YYYY\-MM\-DD\-HH:MN:SS\s0 form is produced.
.Sp
.Vb 2
\&   $hms = $dmb\->split("hms",$string);
\&   $string = $dmb\->join("hms",$hms);
.Ve
.Sp
This works with the hours, minutes, and seconds portion of a date.
.Sp
When splitting a string, the string can be of any of the forms:
.Sp
.Vb 6
\&   H
\&   H:MN
\&   H:MN:SS
\&   HH
\&   HHMN
\&   HHMNSS
.Ve
.Sp
Here, H is a 1 or 2 digit representation of the hours. All other fields are
two digit representations.
.Sp
The string formed by the join function will always be of the form \s-1HH:MN:SS\s0.
.Sp
The time must be between 00:00:00 and 24:00:00.
.Sp
.Vb 2
\&   $offset = $dmb\->split("offset",$string);
\&   $string = $dmb\->join("offset",$offset);
.Ve
.Sp
An offset string should have a sign (though it is optional if it is
positive) and is any of the forms:
.Sp
.Vb 6
\&   +H
\&   +H:MN
\&   +H:MN:SS
\&   +HH
\&   +HHMN
\&   +HHMNSS
.Ve
.Sp
Here, H is a 1 or 2 digit representation of the hours. All other fields are
two digit representations.
.Sp
The string formed by the join function will always be of the form
+HH:MN:SS.
.Sp
.Vb 2
\&   $time = $dmb\->split("time",$string);
\&   $string = $dmb\->join("time",$time);
.Ve
.Sp
This works with an amount of time in hours, minutes, and seconds. The
string is of the format:
.Sp
.Vb 1
\&   +H:MN:S
.Ve
.Sp
where all signs are optional. The returned value (whether a list reference
from the split function, or a string from the join function) will have
all fields normalized (see Date::Manip::Delta for an explanation).
.Sp
.Vb 2
\&   $delta = $dmb\->split("delta",$string);
\&   $delta = $dmb\->split("business",$string);
\&
\&   $string = $dmb\->join("delta",$delta);
\&   $string = $dmb\->join("business",$delta);
.Ve
.Sp
Both of these split a string containing a delta, or create a string
containing one. The difference is whether the delta is treated as
a business or non-business delta (see Date::Manip::Delta documentation
for a detailed description).
.Sp
The string that can be split is of the form:
.Sp
.Vb 1
\&  +Y:M:+W:+D:H:MN:S
.Ve
.Sp
All signs are optional in the string being split. The string
produced is of the form +Y:M:+W:D:H:MN:S (for a non-business
delta) or +Y:M:+W:+D:H:MN:S (for a business delta).
.Sp
Fields may be omitted entirely. For example:
.Sp
.Vb 2
\&  D:H:MN:S
\&  D:::S
.Ve
.Sp
are both valid.
.Sp
The string or list output is normalized.
.IP "\fBweek1_day1\fR" 4
.IX Item "week1_day1"
.Vb 1
\&   $ymd = $dmb\->week1_day1($y);
.Ve
.Sp
This returns the date of the 1st day of the 1st week in the given year.
Note that this uses the \s-1ISO\s0 8601 definition of week, so the year returned
may be the year before the one passed in.
.Sp
This uses the FirstDay and Jan1Week1 config variables to evaluate the
results.
.IP "\fBweeks_in_year\fR" 4
.IX Item "weeks_in_year"
.Vb 1
\&   $w = $dmb\->weeks_in_year($y);
.Ve
.Sp
This returns the number of \s-1ISO\s0 8601 weeks in the year. It will always be
52 or 53.
.IP "\fBweek_of_year\fR" 4
.IX Item "week_of_year"
.Vb 2
\&   ($y,$w) = $dmb\->week_of_year($date);
\&   ($y,$w) = $dmb\->week_of_year($ymd);
.Ve
.Sp
This returns the week number (1\-53) of the given date and the year
that it falls in. Since the \s-1ISO\s0 8601 definition of a week is used, the
year returned is not necessarily the one passed in (it may differ for
the first or last week of the year).
.Sp
The inverse operation is also available:
.Sp
.Vb 1
\&   $ymd = $dmb\->week_of_year($y,$w);
.Ve
.Sp
which returns the first day of the given week.
.Sp
This uses the FirstDay and Jan1Week1 config variables to evaluate the
results.
.SH "KNOWN BUGS"
.IX Header "KNOWN BUGS"
None known.
.SH "BUGS AND QUESTIONS"
.IX Header "BUGS AND QUESTIONS"
Please refer to the Date::Manip::Problems documentation for
information on submitting bug reports or questions to the author.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Date::Manip        \- main module documentation
.SH "LICENSE"
.IX Header "LICENSE"
This script is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sullivan Beck (sbeck@cpan.org)
