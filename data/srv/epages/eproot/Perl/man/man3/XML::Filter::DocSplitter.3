.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Filter::DocSplitter 3"
.TH XML::Filter::DocSplitter 3 "2009-06-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Filter::DocSplitter \- Multipass processing of documents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    ## See XML::SAX::???? for an easier way to use this filter.
\&
\&    use XML::SAX::Machines qw( Machine ) ;
\&
\&    my $m = Machine(
\&        [ Intake => "XML::Filter::DocSplitter" => qw( Filter ) ],
\&        [ Filter => "My::Filter"               => qw( Merger ) ],
\&        [ Merger => "XML::Filter::Merger" => qw( Output ) ],
\&        [ Output => \e*STDOUT ],
\&    );
\&
\&    ## Let the distributor coordinate with the merger
\&    ## XML::SAX::Manifold does this for you.
\&    $m\->Intake\->set_aggregator( $m\->Merger );
\&
\&    $m\->parse_file( "foo" );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
XML::Filter::DocSplitter is a \s-1SAX\s0 filter that allows you to apply a
filter to repeated sections of a document.  It splits a document up at a
predefined elements in to multiple documents and the filter is run on
each document.  The result can be left as a stream of separate documents
or combined back in to a single document using a filter like
XML::SAX::Merger.
.PP
By default, the input document is split in all children of the root
element.  By that reckoning, this document has three sub-documents in
it:
.PP
.Vb 5
\&    <doc>
\&        <subdoc> .... </subdoc>
\&        <subdoc> .... </subdoc>
\&        <subdoc> .... </subdoc>
\&    </doc>
.Ve
.PP
When using without an aggregator, all events up to the first record are
lost; with an aggregator, they are passed directly in to the aggregator
as the \*(L"first\*(R" document.  All elements between the records (the \*(L"\en    \*(R"
text nodes, in this case) are also passed directly to the merger (these
will arrive between the end_document and start_document calls for each
of the records), as are all events from the last record until the end
of the input document.  This means that the first document, as seen by
the merger, is incomplete; it's missing it's end_element, which is
passed later.
.PP
The approach of passing events from the input document right on through
to the merger differs from the way XML::Filter::Distributor works.
.PP
This class is derived from XML::SAX::Base, see that for details.
.SH "METHODS"
.IX Header "METHODS"
.IP "new" 4
.IX Item "new"
.Vb 4
\&    my $d = XML::Filter::DocSplitter\->new(
\&        Handler    => $h,
\&        Aggregator => $a,    ## optional
\&    );
.Ve
.IP "set_aggregator" 4
.IX Item "set_aggregator"
.Vb 1
\&    $h\->set_aggregator( $a );
.Ve
.Sp
Sets the \s-1SAX\s0 filter that will stitch the resulting subdocuments back
together.  Set to \f(CW\*(C`undef\*(C'\fR to prevent such stitchery.
.Sp
The aggregator should support the \f(CW\*(C`start_manifold_document\*(C'\fR,
\&\f(CW\*(C`end_manifold_document\*(C'\fR, and \f(CW\*(C`set_include_all_roots\*(C'\fR methods as
described in XML::Filter::Merger.
.IP "get_aggregator" 4
.IX Item "get_aggregator"
.Vb 1
\&    my $a = $h\->get_aggregator;
.Ve
.Sp
Gets the \s-1SAX\s0 filter that will stitch the resulting subdocuments back
together.
.IP "set_split_path" 4
.IX Item "set_split_path"
.Vb 1
\&    $h\->set_split_path( "/a/b/c" );
.Ve
.Sp
Sets the pattern to use when splitting the document.  Patterns are a
tiny little subset of the XPath language:
.Sp
.Vb 6
\&    Pattern     Description
\&    =======     ===========
\&    /*/*        splits the document on children of the root elt (default)
\&    //record    splits each <record> elt in to a document
\&    /*/record   splits each <record> child of the root elt
\&    /a/b/c/d    splits each of the <d> elts in to a document
.Ve
.IP "get_split_path" 4
.IX Item "get_split_path"
.Vb 1
\&    my $a = $h\->get_split_path;
.Ve
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Can only feed a single aggregator at the moment :).  I can fix this with
a bit of effort.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&    Barrie Slaymaker <barries@slaysys.com>
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 1
\&    Copyright 2000, Barrie Slaymaker, All Rights Reserved.
.Ve
.PP
You may use this module under the terms of the Artistic, \s-1GPL\s0, or the \s-1BSD\s0
licenses.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 284:" 4
.IX Item "Around line 284:"
You forgot a '=back' before '=head1'
