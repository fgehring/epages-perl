.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Authen::Passphrase::Crypt16 3"
.TH Authen::Passphrase::Crypt16 3 "2013-11-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Authen::Passphrase::Crypt16 \- passphrases using Ultrix crypt16 algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Authen::Passphrase::Crypt16;
\&
\&        $ppr = Authen::Passphrase::Crypt16\->new(
\&                salt_base64 => "qi",
\&                hash_base64 => "8H8R7OM4xMUNMPuRAZxlY.");
\&
\&        $ppr = Authen::Passphrase::Crypt16\->new(
\&                salt_random => 12,
\&                passphrase => "passphrase");
\&
\&        $salt = $ppr\->salt;
\&        $salt_base64 = $ppr\->salt_base64_2;
\&        $hash = $ppr\->hash;
\&        $hash_base64 = $ppr\->hash_base64;
\&
\&        $ppr0 = $ppr\->first_half;
\&        $ppr1 = $ppr\->second_half;
\&
\&        if($ppr\->match($passphrase)) { ...
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An object of this class encapsulates a passphrase hashed using the
\&\*(L"crypt16\*(R" hash function found in Ultrix and Tru64.  Do not confuse
this with the \*(L"bigcrypt\*(R" found on HP-UX, Digital Unix, and \s-1OSF/1\s0 (for
which see Authen::Passphrase::BigCrypt).  This is a subclass of
Authen::Passphrase, and this document assumes that the reader is
familiar with the documentation for that class.
.PP
This is a derivation of the original DES-based crypt function found on all
Unices (see Authen::Passphrase::DESCrypt).  The first eight bytes of
the passphrase are used as a \s-1DES\s0 key to encrypt the all-bits-zero block
through 20 rounds of (12\-bit) salted \s-1DES\s0.  (The standard crypt function
does this, but with 25 encryption rounds instead of 20.)  Then the
next eight bytes, or the null string if the passphrase is eight bytes
or shorter, are used as a \s-1DES\s0 key to encrypt the all-bits-zero block
through 5 rounds of salted \s-1DES\s0 with the same salt.  The two eight-byte
ciphertexts are concatenated to form the sixteen-byte hash.
.PP
A password hash of this scheme is conventionally represented in \s-1ASCII\s0 as
a 24\-character string using a base 64 encoding.  The first two characters
give the salt, the next eleven give the hash of the first half, and the
last eleven give the hash of the second half.  A hash thus encoded is
used as a crypt string, on those systems where the crypt16 algorithm
is part of \fIcrypt()\fR, but the syntax clashes with that of bigcrypt.
This module does not treat it as a crypt string syntax.
.PP
Because the two halves of the passphrase are hashed separately, it
is possible to manipulate (e.g., crack) a half hash in isolation.
See Authen::Passphrase::DESCrypt for handling of a single half.
.PP
\&\fIWarning:\fR This is a fatally flawed design, often providing \fIless\fR
security than the plain \s-1DES\s0 scheme alone.  Do not use seriously.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.IP "Authen::Passphrase::Crypt16\->new(\s-1ATTR\s0 => \s-1VALUE\s0, ...)" 4
.IX Item "Authen::Passphrase::Crypt16->new(ATTR => VALUE, ...)"
Generates a new passphrase recogniser object using the crypt16 hash
algorithm.  The following attributes may be given:
.RS 4
.IP "\fBsalt\fR" 4
.IX Item "salt"
The salt, as an integer in the range [0, 4096).
.IP "\fBsalt_base64\fR" 4
.IX Item "salt_base64"
The salt, as a string of two base 64 digits.
.IP "\fBsalt_random\fR" 4
.IX Item "salt_random"
Causes salt to be generated randomly.  The value given for this
attribute must be 12, indicating generation of 12 bits of salt.
The source of randomness may be controlled by the facility described
in Data::Entropy.
.IP "\fBhash\fR" 4
.IX Item "hash"
The hash, as a string of 16 bytes.
.IP "\fBhash_base64\fR" 4
.IX Item "hash_base64"
The hash, as a string of 22 base 64 digits.
.IP "\fBpassphrase\fR" 4
.IX Item "passphrase"
A passphrase that will be accepted.
.RE
.RS 4
.Sp
The salt must be given, and either the hash or the passphrase.
.RE
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ppr\->salt" 4
.el .IP "\f(CW$ppr\fR\->salt" 4
.IX Item "$ppr->salt"
Returns the salt, as a Perl integer.
.ie n .IP "$ppr\->salt_base64_2" 4
.el .IP "\f(CW$ppr\fR\->salt_base64_2" 4
.IX Item "$ppr->salt_base64_2"
Returns the salt, as a string of two base 64 digits.
.ie n .IP "$ppr\->hash" 4
.el .IP "\f(CW$ppr\fR\->hash" 4
.IX Item "$ppr->hash"
Returns the hash value, as a string of 16 bytes.
.ie n .IP "$ppr\->hash_base64" 4
.el .IP "\f(CW$ppr\fR\->hash_base64" 4
.IX Item "$ppr->hash_base64"
Returns the hash value, as a string of 22 base 64 digits.  This is the
concatenation of the base 64 encodings of the two hashes, rather than
a base64 encoding of the combined hash.
.ie n .IP "$ppr\->first_half" 4
.el .IP "\f(CW$ppr\fR\->first_half" 4
.IX Item "$ppr->first_half"
Returns the hash of the first half of the passphrase, as an
Authen::Passphrase::DESCrypt passphrase recogniser.
.ie n .IP "$ppr\->second_half" 4
.el .IP "\f(CW$ppr\fR\->second_half" 4
.IX Item "$ppr->second_half"
Returns the hash of the second half of the passphrase, as an
Authen::Passphrase::DESCrypt passphrase recogniser.
.ie n .IP "$ppr\->match(\s-1PASSPHRASE\s0)" 4
.el .IP "\f(CW$ppr\fR\->match(\s-1PASSPHRASE\s0)" 4
.IX Item "$ppr->match(PASSPHRASE)"
This method is part of the standard Authen::Passphrase interface.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Authen::Passphrase,
Authen::Passphrase::DESCrypt
.SH "AUTHOR"
.IX Header "AUTHOR"
Andrew Main (Zefram) <zefram@fysh.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006, 2007, 2009, 2010, 2012
Andrew Main (Zefram) <zefram@fysh.org>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
