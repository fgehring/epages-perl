.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Spellunker 3"
.TH Test::Spellunker 3 "2017-06-14" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::Spellunker \- check for spelling errors in POD files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Test::Spellunker;
\&    all_pod_files_spelling_ok();
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "all_pod_files_spelling_ok( [@files/@directories] )" 4
.IX Item "all_pod_files_spelling_ok( [@files/@directories] )"
Checks all the files for \s-1POD\s0 spelling. It gathers \fIall_pod_files()\fR on
each file/directory, and declares a \*(L"plan\*(R" in Test::More for you (one
test for each file), so you must not call \*(L"plan\*(R" yourself.
.Sp
If \f(CW@files\fR is empty, the function finds all \s-1POD\s0 files in the blib
directory; or the lib, bin and scripts directories if blib does not exist.
A \s-1POD\s0 file is one that ends with .pod, .pl, .plx, or .pm; or any file
where the first line looks like a perl shebang line.
.Sp
If you're testing a distribution, just create a t/pod\-spell.t with the
code in the \*(L"\s-1SYNOPSIS\s0\*(R".
.Sp
Returns true if every \s-1POD\s0 file has correct spelling, or false if any of
them fail.  This function will show any spelling errors as diagnostics.
.ie n .IP "pod_file_spelling_ok( $filename[, $testname ] )" 4
.el .IP "pod_file_spelling_ok( \f(CW$filename\fR[, \f(CW$testname\fR ] )" 4
.IX Item "pod_file_spelling_ok( $filename[, $testname ] )"
\&\*(L"pod_file_spelling_ok\*(R" will test that the given \s-1POD\s0 file has no
spelling errors.
.Sp
When it fails, \*(L"pod_file_spelling_ok\*(R" will show any spelling errors as
diagnostics.
.Sp
The optional second argument is the name of the test.  If it is
omitted, \*(L"pod_file_spelling_ok\*(R" chooses a default test name \*(L"\s-1POD\s0
spelling for \f(CW$filename\fR\*(R".
.IP "all_pod_files( [@dirs] )" 4
.IX Item "all_pod_files( [@dirs] )"
Returns a list of all the Perl files in each directory and its
subdirectories, recursively. If no directories are passed, it defaults
to blib if blib exists, or else lib if not. Skips any files in \s-1CVS\s0 or
\&.svn directories.
.Sp
A Perl file is:
.Sp
.Vb 2
\&   Any file that ends in .PL, .pl, .plx, .pm, .pod or .t.
\&   Any file that has a first line with a shebang and "perl" on it.
.Ve
.Sp
Furthermore, files for which the filter set by \*(L"set_pod_file_filter\*(R"
return false are skipped. By default, this filter passes everything
through.
.Sp
The order of the files returned is machine-dependent.  If you want them
sorted, you'll have to sort them yourself.
.IP "add_stopwords(@words)" 4
.IX Item "add_stopwords(@words)"
Add words that should be skipped by the spellcheck. Note that
Pod::Spell already skips words believed to be code, such as everything
in verbatim (indented) blocks and code marked up with "\*(L"...\*(R"", as well
as some common Perl jargon.
.IP "load_dictionary($filename_or_fh)" 4
.IX Item "load_dictionary($filename_or_fh)"
Load stopwords from \f(CW$filename_or_fh\fR. You may want to use it as \f(CW\*(C`load_dictionary(\e*DATA)\*(C'\fR.
.SH "HOW DO I ADD FILE SPECIFIC STOPWORDS?"
.IX Header "HOW DO I ADD FILE SPECIFIC STOPWORDS?"
You can put it by following style \s-1POD\s0 annotation.
.PP
.Vb 1
\&    _\|_END_\|_
\&
\&    =for stopwords foo bar
\&
\&    =head1 NAME
\&
\&    ...
.Ve
.SH "THANKS TO"
.IX Header "THANKS TO"
Inspired from Test::Spelling. And most of document was taken from Test::Spelling.
